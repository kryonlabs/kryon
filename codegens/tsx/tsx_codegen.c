/**
 * TSX Code Generator
 * Generates TypeScript React components from KIR JSON
 */

#include "tsx_codegen.h"
#include "../codegen_common.h"
#include "codegen_common.h"
#include "../../third_party/cJSON/cJSON.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char* tsx_codegen_from_json(const char* kir_json) {
    if (!kir_json) return NULL;

    // Parse JSON
    cJSON* root = cJSON_Parse(kir_json);
    if (!root) {
        fprintf(stderr, "Error: Failed to parse KIR JSON\n");
        return NULL;
    }

    // Build React context with TypeScript mode
    ReactContext ctx = {
        .mode = REACT_MODE_TYPESCRIPT,
        .logic_functions = NULL,
        .event_bindings = NULL,
        .indent_level = 0
    };

    // Extract logic functions if present (support both old "logic" and new "logic_block")
    cJSON* logic = cJSON_GetObjectItem(root, "logic_block");
    if (!logic) {
        logic = cJSON_GetObjectItem(root, "logic");  // Fallback to old format
    }

    if (logic && cJSON_IsObject(logic)) {
        ctx.logic_functions = cJSON_GetObjectItem(logic, "functions");
        ctx.event_bindings = cJSON_GetObjectItem(logic, "event_bindings");
    }

    // Get root component
    cJSON* component = cJSON_GetObjectItem(root, "root");
    if (!component) component = cJSON_GetObjectItem(root, "component");
    if (!component) component = root;

    // Extract window configuration from "app" section first, then fallback to component
    cJSON* app_section = cJSON_GetObjectItem(root, "app");
    WindowConfig win_config = react_extract_window_config(app_section ? app_section : component);

    // If background wasn't set from app section, try to get it from root component
    if (app_section && (!win_config.background || strcmp(win_config.background, "#1E1E1E") == 0)) {
        cJSON* bg = cJSON_GetObjectItem(component, "background");
        if (bg && cJSON_IsString(bg)) {
            free(win_config.background);
            win_config.background = strdup(cJSON_GetStringValue(bg));
        }
    }

    // Get reactive manifest for state hooks
    cJSON* manifest = cJSON_GetObjectItem(root, "reactive_manifest");

    // Start generating TSX
    StringBuilder* sb = sb_create(8192);

    // Add header
    sb_append(sb, "// Generated by Kryon Code Generator (TypeScript React-Hooks Style)\n\n");
    sb_append(sb, react_generate_imports(ctx.mode));
    sb_append(sb, "\n\n");

    // Generate state hooks if there's a reactive manifest
    char* state_hooks = react_generate_state_hooks(manifest, &ctx);

    // Generate main app export
    sb_append(sb, "export default kryonApp({\n");
    sb_append_fmt(sb, "  width: %d,\n", win_config.width);
    sb_append_fmt(sb, "  height: %d,\n", win_config.height);
    sb_append_fmt(sb, "  title: \"%s\",\n", win_config.title);
    sb_append_fmt(sb, "  background: \"%s\",\n\n", win_config.background);

    sb_append(sb, "  render: () => {\n");

    // Add state hooks inside render
    if (state_hooks && strlen(state_hooks) > 0) {
        sb_append(sb, state_hooks);
        sb_append(sb, "\n");
    }

    sb_append(sb, "    return (\n");

    // Check if root is a simple Container with background - if so, generate only its children
    // to avoid redundancy (kryonApp already handles the background)
    cJSON* root_type = cJSON_GetObjectItem(component, "type");
    cJSON* root_children = cJSON_GetObjectItem(component, "children");
    bool is_simple_container = root_type && cJSON_IsString(root_type) &&
                               strcmp(cJSON_GetStringValue(root_type), "Container") == 0 &&
                               root_children && cJSON_IsArray(root_children);

    if (is_simple_container && cJSON_GetArraySize(root_children) == 1) {
        // Generate only the child element
        cJSON* child = cJSON_GetArrayItem(root_children, 0);
        char* child_elem = react_generate_element(child, &ctx, 3);
        sb_append(sb, child_elem);
        free(child_elem);
    } else {
        // Generate full root element
        char* root_elem = react_generate_element(component, &ctx, 3);
        sb_append(sb, root_elem);
        free(root_elem);
    }

    sb_append(sb, "\n    );\n");
    sb_append(sb, "  }\n");
    sb_append(sb, "});\n");

    // Clean up
    free(state_hooks);
    react_free_window_config(&win_config);
    cJSON_Delete(root);

    char* result = strdup(sb_get(sb));
    sb_free(sb);
    return result;
}

bool tsx_codegen_generate(const char* kir_path, const char* output_path) {
    if (!kir_path || !output_path) return false;

    // Set error prefix for this codegen
    codegen_set_error_prefix("TSX");

    // Read KIR file using shared utility
    char* kir_json = codegen_read_kir_file(kir_path, NULL);
    if (!kir_json) {
        return false;
    }

    // Generate TSX code
    char* tsx_code = tsx_codegen_from_json(kir_json);
    free(kir_json);

    if (!tsx_code) {
        return false;
    }

    // Write output using shared utility
    bool success = codegen_write_output_file(output_path, tsx_code);
    free(tsx_code);

    if (success) {
        printf("✓ Generated TSX code: %s\n", output_path);
    }
    return success;
}

bool tsx_codegen_generate_with_options(const char* kir_path,
                                        const char* output_path,
                                        TsxCodegenOptions* options) {
    if (!kir_path || !output_path) {
        return false;
    }

    // Use defaults if no options provided
    TsxCodegenOptions default_opts = {
        .format = true,
        .use_prettier = false,
        .semicolons = true
    };
    if (!options) {
        options = &default_opts;
    }

    // Set error prefix for this codegen
    codegen_set_error_prefix("TSX");

    // Read KIR file using shared utility
    char* kir_json = codegen_read_kir_file(kir_path, NULL);
    if (!kir_json) {
        return false;
    }

    // Generate TSX code
    char* tsx_code = tsx_codegen_from_json(kir_json);
    free(kir_json);

    if (!tsx_code) {
        return false;
    }

    // Write output using shared utility
    bool success = codegen_write_output_file(output_path, tsx_code);
    free(tsx_code);

    if (!success) {
        return false;
    }

    printf("✓ Generated TSX code: %s\n", output_path);

    // Apply formatting if requested
    if (options->use_prettier) {
        char cmd[2048];
        snprintf(cmd, sizeof(cmd), "prettier --write \"%s\" 2>/dev/null", output_path);
        int result = system(cmd);
        if (result == 0) {
            printf("  Formatted with Prettier\n");
        }
    }

    // Note: semicolons option would affect generation in tsx_codegen_from_json
    // For now, TypeScript style defaults to including semicolons

    return true;
}
