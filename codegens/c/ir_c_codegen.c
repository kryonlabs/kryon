/**
 * C Code Generator - KIR → C Source Code
 *
 * Generates idiomatic C code with Kryon DSL from KIR JSON files
 */

#include "ir_c_codegen.h"
#include "../codegen_common.h"
#include "../../ir/src/utils/ir_c_metadata.h"
#include "../../third_party/cJSON/cJSON.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <ctype.h>

// ============================================================================
// Code Generation Context
// ============================================================================

typedef struct {
    FILE* output;
    int indent_level;
    cJSON* root_json;           // Full KIR JSON
    cJSON* component_tree;      // Root component
    cJSON* c_metadata;          // C metadata section
    cJSON* variables;           // Variables array
    cJSON* event_handlers;      // Event handlers array
    cJSON* helper_functions;    // Helper functions array
    cJSON* includes;            // Includes array
    cJSON* preprocessor_dirs;   // Preprocessor directives array
} CCodegenContext;

// ============================================================================
// Utility Functions
// ============================================================================

static void write_indent(CCodegenContext* ctx) {
    for (int i = 0; i < ctx->indent_level; i++) {
        fprintf(ctx->output, "    ");
    }
}

static void writeln(CCodegenContext* ctx, const char* str) {
    write_indent(ctx);
    fprintf(ctx->output, "%s\n", str);
}

static void write_raw(CCodegenContext* ctx, const char* str) __attribute__((unused));
static void write_raw(CCodegenContext* ctx, const char* str) {
    fprintf(ctx->output, "%s", str);
}

// Get variable name for a component ID
static const char* get_variable_for_component_id(CCodegenContext* ctx, int component_id) {
    if (!ctx->variables) return NULL;

    int var_count = cJSON_GetArraySize(ctx->variables);
    for (int i = 0; i < var_count; i++) {
        cJSON* var = cJSON_GetArrayItem(ctx->variables, i);
        cJSON* id_item = cJSON_GetObjectItem(var, "component_id");
        if (id_item && id_item->valueint == component_id) {
            cJSON* name = cJSON_GetObjectItem(var, "name");
            if (name && name->valuestring) {
                return name->valuestring;
            }
        }
    }
    return NULL;
}

// Map component type to C DSL macro name
static const char* get_component_macro(const char* type) {
    if (strcmp(type, "Container") == 0) return "CONTAINER";
    if (strcmp(type, "Column") == 0) return "COLUMN";
    if (strcmp(type, "Row") == 0) return "ROW";
    if (strcmp(type, "Center") == 0) return "CENTER";
    if (strcmp(type, "Text") == 0) return "TEXT";
    if (strcmp(type, "Button") == 0) return "BUTTON";
    if (strcmp(type, "Input") == 0) return "INPUT";
    if (strcmp(type, "Checkbox") == 0) return "CHECKBOX";
    if (strcmp(type, "Dropdown") == 0) return "DROPDOWN";
    if (strcmp(type, "Image") == 0) return "IMAGE";
    if (strcmp(type, "TabGroup") == 0) return "TAB_GROUP";
    if (strcmp(type, "TabBar") == 0) return "TAB_BAR";
    if (strcmp(type, "Tab") == 0) return "TAB";
    if (strcmp(type, "TabContent") == 0) return "TAB_CONTENT";
    if (strcmp(type, "TabPanel") == 0) return "TAB_PANEL";
    if (strcmp(type, "Table") == 0) return "TABLE";
    if (strcmp(type, "TableHead") == 0) return "TABLE_HEAD";
    if (strcmp(type, "TableBody") == 0) return "TABLE_BODY";
    if (strcmp(type, "TableRow") == 0) return "TABLE_ROW";
    if (strcmp(type, "TableCell") == 0) return "TABLE_CELL";
    if (strcmp(type, "TableHeaderCell") == 0) return "TABLE_HEADER_CELL";
    return "CONTAINER";  // Fallback
}

// ============================================================================
// Header Generation
// ============================================================================

static void generate_includes(CCodegenContext* ctx) {
    fprintf(ctx->output, "/**\n");
    fprintf(ctx->output, " * Auto-generated C code from .kir file\n");
    fprintf(ctx->output, " * Generated by Kryon C Code Generator\n");
    fprintf(ctx->output, " */\n\n");

    // Generate includes from metadata
    if (ctx->includes && cJSON_IsArray(ctx->includes)) {
        int count = cJSON_GetArraySize(ctx->includes);
        for (int i = 0; i < count; i++) {
            cJSON* inc = cJSON_GetArrayItem(ctx->includes, i);
            cJSON* include_str = cJSON_GetObjectItem(inc, "include");
            if (include_str && include_str->valuestring) {
                fprintf(ctx->output, "#include %s\n", include_str->valuestring);
            }
        }
    } else {
        // Default includes if no metadata
        fprintf(ctx->output, "#include <kryon.h>\n");
        fprintf(ctx->output, "#include <kryon_dsl.h>\n");
        fprintf(ctx->output, "#include <stdio.h>\n");
        fprintf(ctx->output, "#include <stdbool.h>\n");
    }
    fprintf(ctx->output, "\n");
}

static void generate_preprocessor_directives(CCodegenContext* ctx) {
    if (!ctx->preprocessor_dirs || !cJSON_IsArray(ctx->preprocessor_dirs)) {
        return;
    }

    int count = cJSON_GetArraySize(ctx->preprocessor_dirs);
    if (count == 0) return;

    for (int i = 0; i < count; i++) {
        cJSON* dir = cJSON_GetArrayItem(ctx->preprocessor_dirs, i);
        cJSON* type = cJSON_GetObjectItem(dir, "directive_type");
        cJSON* condition = cJSON_GetObjectItem(dir, "condition");
        cJSON* value = cJSON_GetObjectItem(dir, "value");

        if (!type || !type->valuestring) continue;

        if (strcmp(type->valuestring, "define") == 0) {
            fprintf(ctx->output, "#define ");
            if (condition && condition->valuestring) {
                fprintf(ctx->output, "%s ", condition->valuestring);
            }
            if (value && value->valuestring) {
                fprintf(ctx->output, "%s", value->valuestring);
            }
            fprintf(ctx->output, "\n");
        } else if (strcmp(type->valuestring, "ifdef") == 0 && condition && condition->valuestring) {
            fprintf(ctx->output, "#ifdef %s\n", condition->valuestring);
        } else if (strcmp(type->valuestring, "ifndef") == 0 && condition && condition->valuestring) {
            fprintf(ctx->output, "#ifndef %s\n", condition->valuestring);
        } else if (strcmp(type->valuestring, "if") == 0 && condition && condition->valuestring) {
            fprintf(ctx->output, "#if %s\n", condition->valuestring);
        } else if (strcmp(type->valuestring, "elif") == 0 && condition && condition->valuestring) {
            fprintf(ctx->output, "#elif %s\n", condition->valuestring);
        } else if (strcmp(type->valuestring, "else") == 0) {
            fprintf(ctx->output, "#else\n");
        } else if (strcmp(type->valuestring, "endif") == 0) {
            fprintf(ctx->output, "#endif\n");
        }
    }
    fprintf(ctx->output, "\n");
}

// ============================================================================
// Variable & Function Generation
// ============================================================================

static void generate_variable_declarations(CCodegenContext* ctx) {
    if (!ctx->variables || !cJSON_IsArray(ctx->variables)) {
        return;
    }

    int count = cJSON_GetArraySize(ctx->variables);
    if (count == 0) return;

    fprintf(ctx->output, "// Component variables\n");
    for (int i = 0; i < count; i++) {
        cJSON* var = cJSON_GetArrayItem(ctx->variables, i);
        cJSON* storage = cJSON_GetObjectItem(var, "storage");
        cJSON* type = cJSON_GetObjectItem(var, "type");
        cJSON* name = cJSON_GetObjectItem(var, "name");
        cJSON* initial = cJSON_GetObjectItem(var, "initial_value");

        if (!name || !name->valuestring || !type || !type->valuestring) continue;

        if (storage && storage->valuestring) {
            fprintf(ctx->output, "%s ", storage->valuestring);
        }
        fprintf(ctx->output, "%s %s", type->valuestring, name->valuestring);

        if (initial && initial->valuestring) {
            fprintf(ctx->output, " = %s", initial->valuestring);
        }
        fprintf(ctx->output, ";\n");
    }
    fprintf(ctx->output, "\n");
}

static void generate_helper_functions(CCodegenContext* ctx) {
    if (!ctx->helper_functions || !cJSON_IsArray(ctx->helper_functions)) {
        return;
    }

    int count = cJSON_GetArraySize(ctx->helper_functions);
    if (count == 0) return;

    fprintf(ctx->output, "// Helper functions\n");
    for (int i = 0; i < count; i++) {
        cJSON* func = cJSON_GetArrayItem(ctx->helper_functions, i);
        cJSON* return_type = cJSON_GetObjectItem(func, "return_type");
        cJSON* name = cJSON_GetObjectItem(func, "name");
        cJSON* params = cJSON_GetObjectItem(func, "parameters");
        cJSON* body = cJSON_GetObjectItem(func, "body");

        if (!name || !name->valuestring || !return_type || !return_type->valuestring) continue;

        fprintf(ctx->output, "%s %s(%s) {\n",
                return_type->valuestring,
                name->valuestring,
                (params && params->valuestring) ? params->valuestring : "void");

        if (body && body->valuestring) {
            fprintf(ctx->output, "%s\n", body->valuestring);
        }

        fprintf(ctx->output, "}\n\n");
    }
}

static void generate_event_handlers(CCodegenContext* ctx) {
    if (!ctx->event_handlers || !cJSON_IsArray(ctx->event_handlers)) {
        return;
    }

    int count = cJSON_GetArraySize(ctx->event_handlers);
    if (count == 0) return;

    fprintf(ctx->output, "// Event handlers\n");
    for (int i = 0; i < count; i++) {
        cJSON* handler = cJSON_GetArrayItem(ctx->event_handlers, i);
        cJSON* return_type = cJSON_GetObjectItem(handler, "return_type");
        cJSON* name = cJSON_GetObjectItem(handler, "function_name");
        cJSON* params = cJSON_GetObjectItem(handler, "parameters");
        cJSON* body = cJSON_GetObjectItem(handler, "body");

        if (!name || !name->valuestring || !return_type || !return_type->valuestring) continue;

        fprintf(ctx->output, "%s %s(%s) {\n",
                return_type->valuestring,
                name->valuestring,
                (params && params->valuestring) ? params->valuestring : "void");

        if (body && body->valuestring) {
            fprintf(ctx->output, "%s\n", body->valuestring);
        }

        fprintf(ctx->output, "}\n\n");
    }
}

// ============================================================================
// Component Tree Generation
// ============================================================================

static bool generate_property_macro(CCodegenContext* ctx, const char* key, cJSON* value);

static void generate_component_recursive(CCodegenContext* ctx, cJSON* component, bool is_root) {
    cJSON* type_obj = cJSON_GetObjectItem(component, "type");
    cJSON* id_obj = cJSON_GetObjectItem(component, "id");
    cJSON* children_obj = cJSON_GetObjectItem(component, "children");
    cJSON* text_obj = cJSON_GetObjectItem(component, "text");

    if (!type_obj || !type_obj->valuestring) return;

    const char* type = type_obj->valuestring;
    const char* macro = get_component_macro(type);

    // Check if this component has a variable assignment
    const char* var_name = NULL;
    if (id_obj) {
        var_name = get_variable_for_component_id(ctx, id_obj->valueint);
    }

    // Write indentation
    write_indent(ctx);

    // Variable assignment if needed
    if (var_name && !is_root) {
        fprintf(ctx->output, "%s = ", var_name);
    }

    // Component macro
    fprintf(ctx->output, "%s(", macro);

    // Text/label parameter for components that need it
    bool has_text = (text_obj && text_obj->valuestring);
    if (has_text) {
        fprintf(ctx->output, "\"%s\"", text_obj->valuestring);
    }

    // Check for FULL_SIZE pattern (width=100.0px AND height=100.0px)
    cJSON* width_prop = cJSON_GetObjectItem(component, "width");
    cJSON* height_prop = cJSON_GetObjectItem(component, "height");
    bool is_full_size = (width_prop && width_prop->valuestring &&
                         height_prop && height_prop->valuestring &&
                         (strcmp(width_prop->valuestring, "100.0px") == 0 ||
                          strcmp(width_prop->valuestring, "100.0%") == 0) &&
                         (strcmp(height_prop->valuestring, "100.0px") == 0 ||
                          strcmp(height_prop->valuestring, "100.0%") == 0));

    // Check if we have properties or children
    bool has_properties = false;
    cJSON* prop = NULL;
    cJSON_ArrayForEach(prop, component) {
        const char* key = prop->string;
        if (!key) continue;
        if (strcmp(key, "id") != 0 && strcmp(key, "type") != 0 &&
            strcmp(key, "text") != 0 && strcmp(key, "children") != 0 &&
            strcmp(key, "TEST_MARKER") != 0 && strcmp(key, "direction") != 0 &&
            strcmp(key, "background") != 0 && strcmp(key, "color") != 0) {
            has_properties = true;
            break;
        }
        // Check if background/color are non-default
        if (strcmp(key, "background") == 0 && prop->valuestring && strcmp(prop->valuestring, "#00000000") != 0) {
            has_properties = true;
            break;
        }
        if (strcmp(key, "color") == 0 && prop->valuestring && strcmp(prop->valuestring, "#00000000") != 0) {
            has_properties = true;
            break;
        }
    }

    bool has_children = (children_obj && cJSON_GetArraySize(children_obj) > 0);

    // Add comma after text if there are properties or children
    if (has_text && (has_properties || has_children)) {
        fprintf(ctx->output, ",\n");
    } else if (!has_text || !has_properties) {
        fprintf(ctx->output, "\n");
    }

    ctx->indent_level++;

    // Generate FULL_SIZE if applicable
    bool first_prop = true;
    if (is_full_size) {
        if (!first_prop) {
            fprintf(ctx->output, ",\n");
        }
        write_indent(ctx);
        fprintf(ctx->output, "FULL_SIZE");
        first_prop = false;
    }

    // Generate properties
    cJSON* prop2 = NULL;
    cJSON_ArrayForEach(prop2, component) {
        const char* key = prop2->string;
        if (!key) continue;

        // Skip internal fields
        if (strcmp(key, "id") == 0 || strcmp(key, "type") == 0 ||
            strcmp(key, "text") == 0 || strcmp(key, "children") == 0 ||
            strcmp(key, "TEST_MARKER") == 0 || strcmp(key, "direction") == 0) {
            continue;
        }

        // Skip width/height if we already generated FULL_SIZE
        if (is_full_size && (strcmp(key, "width") == 0 || strcmp(key, "height") == 0)) {
            continue;
        }

        // Skip transparent/default colors
        if ((strcmp(key, "background") == 0 || strcmp(key, "color") == 0) &&
            prop2->valuestring && strcmp(prop2->valuestring, "#00000000") == 0) {
            continue;
        }

        // Skip events property if there are no event handlers in metadata
        if (strcmp(key, "events") == 0 && (!ctx->event_handlers || cJSON_GetArraySize(ctx->event_handlers) == 0)) {
            continue;
        }

        // Print comma before property (except first)
        if (!first_prop) {
            fprintf(ctx->output, ",\n");
        }

        // Generate the property
        if (generate_property_macro(ctx, key, prop2)) {
            first_prop = false;
        }
    }

    // Generate children
    if (children_obj && cJSON_IsArray(children_obj)) {
        int child_count = cJSON_GetArraySize(children_obj);
        if (child_count > 0) {
            // Print comma before children if we had properties
            if (!first_prop) {
                fprintf(ctx->output, ",\n");
                fprintf(ctx->output, "\n");  // Blank line for readability
            }

            for (int i = 0; i < child_count; i++) {
                cJSON* child = cJSON_GetArrayItem(children_obj, i);
                generate_component_recursive(ctx, child, false);
                if (i < child_count - 1) {
                    fprintf(ctx->output, ",\n");
                } else {
                    fprintf(ctx->output, "\n");
                }
            }
        }
    }

    ctx->indent_level--;
    write_indent(ctx);
    fprintf(ctx->output, ")");
}

static bool generate_property_macro(CCodegenContext* ctx, const char* key, cJSON* value) {
    // NOTE: write_indent() is called by each case that generates output
    // Don't call it here, as we might not generate anything

    // Width/Height
    if (strcmp(key, "width") == 0 && value->valuestring) {
        write_indent(ctx);
        if (strcmp(value->valuestring, "100.0px") == 0 || strcmp(value->valuestring, "100.0%") == 0) {
            fprintf(ctx->output, "FULL_WIDTH");
        } else {
            // Parse numeric value (e.g., "200.0px" → 200)
            int width_val = 0;
            if (sscanf(value->valuestring, "%d", &width_val) == 1 && width_val > 0) {
                fprintf(ctx->output, "WIDTH(%d)", width_val);
            } else {
                fprintf(ctx->output, "WIDTH(\"%s\")", value->valuestring);
            }
        }
        return true;
    }
    if (strcmp(key, "height") == 0 && value->valuestring) {
        write_indent(ctx);
        if (strcmp(value->valuestring, "100.0px") == 0 || strcmp(value->valuestring, "100.0%") == 0) {
            fprintf(ctx->output, "FULL_HEIGHT");
        } else {
            // Parse numeric value (e.g., "60.0px" → 60)
            int height_val = 0;
            if (sscanf(value->valuestring, "%d", &height_val) == 1 && height_val > 0) {
                fprintf(ctx->output, "HEIGHT(%d)", height_val);
            } else {
                fprintf(ctx->output, "HEIGHT(\"%s\")", value->valuestring);
            }
        }
        return true;
    }

    // Colors
    if (strcmp(key, "background") == 0 && value->valuestring) {
        write_indent(ctx);
        fprintf(ctx->output, "BG_COLOR(\"%s\")", value->valuestring);
        return true;
    }
    if (strcmp(key, "color") == 0 && value->valuestring) {
        write_indent(ctx);
        // Check for named colors
        if (strcmp(value->valuestring, "#ffffff") == 0) {
            fprintf(ctx->output, "COLOR_WHITE");
        } else if (strcmp(value->valuestring, "#000000") == 0) {
            fprintf(ctx->output, "COLOR_BLACK");
        } else if (strcmp(value->valuestring, "#ff0000") == 0) {
            fprintf(ctx->output, "COLOR_RED");
        } else if (strcmp(value->valuestring, "#00ff00") == 0) {
            fprintf(ctx->output, "COLOR_GREEN");
        } else if (strcmp(value->valuestring, "#0000ff") == 0) {
            fprintf(ctx->output, "COLOR_BLUE");
        } else if (strcmp(value->valuestring, "#ffff00") == 0) {
            fprintf(ctx->output, "COLOR_YELLOW");
        } else if (strcmp(value->valuestring, "#00ffff") == 0) {
            fprintf(ctx->output, "COLOR_CYAN");
        } else if (strcmp(value->valuestring, "#ff00ff") == 0) {
            fprintf(ctx->output, "COLOR_MAGENTA");
        } else if (strcmp(value->valuestring, "#808080") == 0) {
            fprintf(ctx->output, "COLOR_GRAY");
        } else if (strcmp(value->valuestring, "#ffa500") == 0) {
            fprintf(ctx->output, "COLOR_ORANGE");
        } else if (strcmp(value->valuestring, "#800080") == 0) {
            fprintf(ctx->output, "COLOR_PURPLE");
        } else {
            fprintf(ctx->output, "COLOR(\"%s\")", value->valuestring);
        }
        return true;
    }

    // Padding/Margin
    if (strcmp(key, "padding") == 0) {
        write_indent(ctx);
        if (cJSON_IsNumber(value)) {
            fprintf(ctx->output, "PADDING(%.0f)", value->valuedouble);
        } else if (cJSON_IsArray(value)) {
            int size = cJSON_GetArraySize(value);
            if (size == 4) {
                fprintf(ctx->output, "PADDING_SIDES(%.0f, %.0f, %.0f, %.0f)",
                        cJSON_GetArrayItem(value, 0)->valuedouble,
                        cJSON_GetArrayItem(value, 1)->valuedouble,
                        cJSON_GetArrayItem(value, 2)->valuedouble,
                        cJSON_GetArrayItem(value, 3)->valuedouble);
            }
        }
        return true;
    }
    if (strcmp(key, "gap") == 0 && cJSON_IsNumber(value)) {
        write_indent(ctx);
        fprintf(ctx->output, "GAP(%.0f)", value->valuedouble);
        return true;
    }

    // Typography
    if (strcmp(key, "fontSize") == 0 && cJSON_IsNumber(value)) {
        write_indent(ctx);
        fprintf(ctx->output, "FONT_SIZE(%.0f)", value->valuedouble);
        return true;
    }
    if (strcmp(key, "fontBold") == 0 && cJSON_IsBool(value)) {
        if (cJSON_IsTrue(value)) {
            write_indent(ctx);
            fprintf(ctx->output, "FONT_BOLD");
            return true;
        }
        return false;
    }

    // Layout
    if (strcmp(key, "justifyContent") == 0 && value->valuestring) {
        write_indent(ctx);
        if (strcmp(value->valuestring, "center") == 0) {
            fprintf(ctx->output, "JUSTIFY_CENTER");
        } else if (strcmp(value->valuestring, "flex-start") == 0 || strcmp(value->valuestring, "start") == 0) {
            fprintf(ctx->output, "JUSTIFY_START");
        } else if (strcmp(value->valuestring, "flex-end") == 0 || strcmp(value->valuestring, "end") == 0) {
            fprintf(ctx->output, "JUSTIFY_END");
        } else if (strcmp(value->valuestring, "space-between") == 0) {
            fprintf(ctx->output, "JUSTIFY_SPACE_BETWEEN");
        } else if (strcmp(value->valuestring, "space-around") == 0) {
            fprintf(ctx->output, "JUSTIFY_SPACE_AROUND");
        } else {
            fprintf(ctx->output, "JUSTIFY_CENTER");
        }
        return true;
    }
    if (strcmp(key, "alignItems") == 0 && value->valuestring) {
        write_indent(ctx);
        if (strcmp(value->valuestring, "center") == 0) {
            fprintf(ctx->output, "ALIGN_CENTER");
        } else if (strcmp(value->valuestring, "flex-start") == 0 || strcmp(value->valuestring, "start") == 0) {
            fprintf(ctx->output, "ALIGN_START");
        } else if (strcmp(value->valuestring, "flex-end") == 0 || strcmp(value->valuestring, "end") == 0) {
            fprintf(ctx->output, "ALIGN_END");
        } else if (strcmp(value->valuestring, "stretch") == 0) {
            fprintf(ctx->output, "ALIGN_STRETCH");
        } else {
            fprintf(ctx->output, "ALIGN_CENTER");
        }
        return true;
    }
    if (strcmp(key, "flexShrink") == 0 && cJSON_IsNumber(value)) {
        write_indent(ctx);
        fprintf(ctx->output, "FLEX_SHRINK(%.0f)", value->valuedouble);
        return true;
    }

    // Visibility
    if (strcmp(key, "visible") == 0 && cJSON_IsBool(value)) {
        write_indent(ctx);
        fprintf(ctx->output, "VISIBLE(%s)", cJSON_IsTrue(value) ? "true" : "false");
        return true;
    }

    // Events
    if (strcmp(key, "events") == 0 && cJSON_IsArray(value)) {
        int event_count = cJSON_GetArraySize(value);
        bool printed = false;
        for (int i = 0; i < event_count; i++) {
            cJSON* event = cJSON_GetArrayItem(value, i);
            cJSON* event_type = cJSON_GetObjectItem(event, "type");
            cJSON* logic_id = cJSON_GetObjectItem(event, "logic_id");

            if (event_type && event_type->valuestring && logic_id && logic_id->valuestring) {
                // Find the function name for this logic_id
                if (ctx->event_handlers) {
                    int handler_count = cJSON_GetArraySize(ctx->event_handlers);
                    for (int j = 0; j < handler_count; j++) {
                        cJSON* handler = cJSON_GetArrayItem(ctx->event_handlers, j);
                        cJSON* h_logic_id = cJSON_GetObjectItem(handler, "logic_id");
                        cJSON* h_func_name = cJSON_GetObjectItem(handler, "function_name");

                        if (h_logic_id && h_logic_id->valuestring &&
                            h_func_name && h_func_name->valuestring &&
                            strcmp(h_logic_id->valuestring, logic_id->valuestring) == 0) {

                            if (strcmp(event_type->valuestring, "click") == 0) {
                                write_indent(ctx);
                                fprintf(ctx->output, "ON_CLICK(%s)", h_func_name->valuestring);
                                printed = true;
                            }
                            break;
                        }
                    }
                }
            }
        }
        return printed;
    }

    // Fallback: skip unknown properties
    return false;
}

// ============================================================================
// Main Function Generation
// ============================================================================

static void generate_main_function(CCodegenContext* ctx) {
    fprintf(ctx->output, "int main(void) {\n");
    ctx->indent_level++;

    // kryon_init() call
    writeln(ctx, "kryon_init(\"Kryon App\", 800, 600);");
    fprintf(ctx->output, "\n");

    // KRYON_APP macro
    writeln(ctx, "KRYON_APP(");
    ctx->indent_level++;

    if (ctx->component_tree) {
        generate_component_recursive(ctx, ctx->component_tree, true);
        fprintf(ctx->output, "\n");
    }

    ctx->indent_level--;
    writeln(ctx, ");");
    fprintf(ctx->output, "\n");

    // KRYON_RUN macro
    writeln(ctx, "KRYON_RUN();");

    ctx->indent_level--;
    fprintf(ctx->output, "}\n");
}

// ============================================================================
// Main Code Generation Entry Points
// ============================================================================

bool ir_generate_c_code_from_string(const char* kir_json, const char* output_path) {
    if (!kir_json || !output_path) return false;

    // Parse KIR JSON
    cJSON* root = cJSON_Parse(kir_json);
    if (!root) {
        fprintf(stderr, "Error: Failed to parse KIR JSON\n");
        return false;
    }

    // Open output file
    FILE* output = fopen(output_path, "w");
    if (!output) {
        fprintf(stderr, "Error: Failed to open output file: %s\n", output_path);
        cJSON_Delete(root);
        return false;
    }

    // Setup context
    CCodegenContext ctx = {0};
    ctx.output = output;
    ctx.indent_level = 0;
    ctx.root_json = root;
    ctx.component_tree = cJSON_GetObjectItem(root, "root");
    ctx.c_metadata = cJSON_GetObjectItem(root, "c_metadata");

    if (ctx.c_metadata) {
        ctx.variables = cJSON_GetObjectItem(ctx.c_metadata, "variables");
        ctx.event_handlers = cJSON_GetObjectItem(ctx.c_metadata, "event_handlers");
        ctx.helper_functions = cJSON_GetObjectItem(ctx.c_metadata, "helper_functions");
        ctx.includes = cJSON_GetObjectItem(ctx.c_metadata, "includes");
        ctx.preprocessor_dirs = cJSON_GetObjectItem(ctx.c_metadata, "preprocessor_directives");
    }

    // Generate code sections
    generate_includes(&ctx);
    generate_preprocessor_directives(&ctx);
    generate_variable_declarations(&ctx);
    generate_helper_functions(&ctx);
    generate_event_handlers(&ctx);
    generate_main_function(&ctx);

    // Cleanup
    fclose(output);
    cJSON_Delete(root);

    return true;
}

bool ir_generate_c_code(const char* kir_path, const char* output_path) {
    if (!kir_path || !output_path) return false;

    // Set error prefix for this codegen
    codegen_set_error_prefix("C");

    // Read KIR file using shared utility
    char* content = codegen_read_kir_file(kir_path, NULL);
    if (!content) {
        return false;
    }

    // Generate code
    bool result = ir_generate_c_code_from_string(content, output_path);
    free(content);

    return result;
}

/**
 * Convert module_id to include guard name (uppercase with underscores)
 */
static char* c_module_to_guard_name(const char* module_id) {
    if (!module_id) return strdup("COMPONENT_H");

    size_t len = strlen(module_id);
    char* result = malloc(len + 3);  // _H\0
    if (!result) return strdup("COMPONENT_H");

    for (size_t i = 0; i < len; i++) {
        if (module_id[i] == '/') {
            result[i] = '_';
        } else if (module_id[i] >= 'a' && module_id[i] <= 'z') {
            result[i] = module_id[i] - 'a' + 'A';  // To uppercase
        } else {
            result[i] = module_id[i];
        }
    }
    result[len] = '_';
    result[len + 1] = 'H';
    result[len + 2] = '\0';

    return result;
}

/**
 * Generate a header file (.h) for a C component
 */
static bool c_generate_header_file(const char* module_id, const char* output_dir) {
    char* guard_name = c_module_to_guard_name(module_id);

    char header_path[2048];
    snprintf(header_path, sizeof(header_path), "%s/%s.h", output_dir, module_id);

    // Generate header content
    char header_content[4096];
    snprintf(header_content, sizeof(header_content),
             "/**\n"
             " * %s - Auto-generated header\n"
             " * Generated by Kryon C Code Generator\n"
             " */\n\n"
             "#ifndef %s\n"
             "#define %s\n\n"
             "#include <kryon.h>\n"
             "#include <kryon_dsl.h>\n\n"
             "// Component declaration\n"
             "IRComponent* %s_create(void);\n\n"
             "#endif // %s\n",
             module_id, guard_name, guard_name,
             strrchr(module_id, '/') ? strrchr(module_id, '/') + 1 : module_id,
             guard_name);

    bool result = codegen_write_file_with_mkdir(header_path, header_content);

    free(guard_name);
    return result;
}

/**
 * Recursively process a module and its transitive imports for C
 */
static int c_process_module_recursive(const char* module_id, const char* kir_dir,
                                      const char* output_dir, CodegenProcessedModules* processed) {
    // Skip if already processed
    if (codegen_processed_modules_contains(processed, module_id)) return 0;
    codegen_processed_modules_add(processed, module_id);

    // Skip internal modules
    if (codegen_is_internal_module(module_id)) return 0;

    // Skip external plugins (they're runtime dependencies, not source)
    if (codegen_is_external_plugin(module_id)) return 0;

    // Build path to component's KIR file
    char component_kir_path[2048];
    snprintf(component_kir_path, sizeof(component_kir_path),
             "%s/%s.kir", kir_dir, module_id);

    // Read component's KIR
    char* component_kir_json = codegen_read_kir_file(component_kir_path, NULL);
    if (!component_kir_json) {
        fprintf(stderr, "Warning: Cannot find KIR for '%s' at %s\n",
                module_id, component_kir_path);
        return 0;
    }

    // Parse to get transitive imports before generating
    cJSON* component_root = cJSON_Parse(component_kir_json);
    int files_written = 0;

    // Generate C source file
    char c_output_path[2048];
    snprintf(c_output_path, sizeof(c_output_path), "%s/%s.c", output_dir, module_id);

    if (ir_generate_c_code_from_string(component_kir_json, c_output_path)) {
        printf("✓ Generated: %s.c\n", module_id);
        files_written++;

        // Also generate header file
        if (c_generate_header_file(module_id, output_dir)) {
            printf("✓ Generated: %s.h\n", module_id);
            files_written++;
        }
    } else {
        fprintf(stderr, "Warning: Failed to generate C code for '%s'\n", module_id);
    }

    free(component_kir_json);

    // Process transitive imports from this component
    if (component_root) {
        cJSON* imports = cJSON_GetObjectItem(component_root, "imports");
        if (imports && cJSON_IsArray(imports)) {
            cJSON* import_item = NULL;
            cJSON_ArrayForEach(import_item, imports) {
                if (!cJSON_IsString(import_item)) continue;
                const char* sub_module_id = cJSON_GetStringValue(import_item);
                if (sub_module_id) {
                    files_written += c_process_module_recursive(sub_module_id, kir_dir,
                                                                output_dir, processed);
                }
            }
        }
        cJSON_Delete(component_root);
    }

    return files_written;
}

bool ir_generate_c_code_multi(const char* kir_path, const char* output_dir) {
    if (!kir_path || !output_dir) {
        fprintf(stderr, "Error: Invalid arguments to ir_generate_c_code_multi\n");
        return false;
    }

    // Set error prefix for this codegen
    codegen_set_error_prefix("C");

    // Read main KIR file
    char* main_kir_json = codegen_read_kir_file(kir_path, NULL);
    if (!main_kir_json) {
        return false;
    }

    // Parse main KIR JSON
    cJSON* main_root = cJSON_Parse(main_kir_json);
    if (!main_root) {
        fprintf(stderr, "Error: Failed to parse main KIR JSON\n");
        free(main_kir_json);
        return false;
    }

    // Create output directory if it doesn't exist
    if (!codegen_mkdir_p(output_dir)) {
        fprintf(stderr, "Error: Could not create output directory: %s\n", output_dir);
        cJSON_Delete(main_root);
        free(main_kir_json);
        return false;
    }

    int files_written = 0;

    // 1. Generate main.c from main.kir
    char main_output_path[2048];
    snprintf(main_output_path, sizeof(main_output_path), "%s/main.c", output_dir);

    if (ir_generate_c_code_from_string(main_kir_json, main_output_path)) {
        printf("✓ Generated: main.c\n");
        files_written++;
    } else {
        fprintf(stderr, "Warning: Failed to generate main.c from KIR\n");
    }

    free(main_kir_json);

    // 2. Get the KIR directory (parent of kir_path)
    char kir_dir[2048];
    codegen_get_parent_dir(kir_path, kir_dir, sizeof(kir_dir));

    // 3. Track processed modules to avoid duplicates
    CodegenProcessedModules processed = {0};
    codegen_processed_modules_add(&processed, "main");  // Mark main as processed

    // 4. Process each import recursively (including transitive imports)
    cJSON* imports = cJSON_GetObjectItem(main_root, "imports");
    if (imports && cJSON_IsArray(imports)) {
        cJSON* import_item = NULL;
        cJSON_ArrayForEach(import_item, imports) {
            if (!cJSON_IsString(import_item)) continue;

            const char* module_id = cJSON_GetStringValue(import_item);
            if (module_id) {
                files_written += c_process_module_recursive(module_id, kir_dir,
                                                            output_dir, &processed);
            }
        }
    }

    codegen_processed_modules_free(&processed);
    cJSON_Delete(main_root);

    if (files_written == 0) {
        fprintf(stderr, "Warning: No C files were generated\n");
        return false;
    }

    printf("✓ Generated %d C files in %s\n", files_written, output_dir);
    return true;
}
