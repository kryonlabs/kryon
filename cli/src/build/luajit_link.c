/**
 * LuaJIT Binary Linker
 *
 * Orchestrates the complete build pipeline for Lua desktop applications:
 * 1. Compile Lua source to bytecode (.bc files)
 * 2. Embed bytecode as C arrays (.c files)
 * 3. Compile runtime loader with embedded bytecode
 * 4. Link with LuaJIT and Kryon runtime
 *
 * Plugin System:
 * - Plugins are discovered from kryon.toml [plugins] section
 * - NO auto-discovery, NO fallbacks - explicit config required
 * - Each plugin must have path, .lua binding, and .a library
 */

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wformat-truncation"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <dirent.h>
#include <libgen.h>
#include <limits.h>

#include "plugin_discovery.h"
#include "../../include/kryon_cli.h"

/* Path buffer size - larger than PATH_MAX to handle path concatenation */
#define BUILD_PATH_MAX (PATH_MAX * 2)

/* Maximum number of plugins supported */
#define MAX_PLUGINS 20

/* Function declarations for our build modules */
extern int luajit_compile(const char* input_lua, const char* output_bc);
extern int embed_bytecode(const char* bytecode_file, const char* output_c, const char* array_name);
extern int embed_multiple_bytecode(const char** bytecode_files, int count,
                                  const char* output_c, const char* project_name);

/**
 * Get home directory
 * Returns NULL if HOME not set, caller should free the result
 */
static char* get_home_dir(void) {
    const char* home = getenv("HOME");
    if (home) return strdup(home);
    return NULL;
}

/**
 * Get Kryon source root from environment or reasonable defaults
 * Returns NULL if not found, caller should free the result
 */
static char* get_kryon_src_root(void) {
    /* Check environment variable first */
    const char* env_root = getenv("KRYON_SRC_ROOT");
    if (env_root && file_exists(env_root)) {
        return strdup(env_root);
    }

    /* Try current directory */
    if (file_exists("./bindings/lua/kryon")) {
        return strdup(".");
    }

    /* Try user-local install */
    char* home = get_home_dir();
    if (home) {
        char user_share[BUILD_PATH_MAX];
        snprintf(user_share, sizeof(user_share), "%s/.local/share/kryon", home);
        free(home);
        if (file_exists(user_share)) {
            return strdup(user_share);
        }
    }

    /* Try system install */
    if (file_exists("/usr/local/share/kryon")) {
        return strdup("/usr/local/share/kryon");
    }

    return NULL;
}

/**
 * Run a command and capture output
 * Returns NULL on failure, caller must free the result
 */
static char* run_command(const char* cmd) {
    FILE* fp = popen(cmd, "r");
    if (!fp) return NULL;

    char buffer[BUILD_PATH_MAX];
    if (fgets(buffer, sizeof(buffer), fp) == NULL) {
        pclose(fp);
        return NULL;
    }
    pclose(fp);

    /* Remove trailing newline */
    size_t len = strlen(buffer);
    while (len > 0 && (buffer[len-1] == '\n' || buffer[len-1] == '\r')) {
        buffer[--len] = '\0';
    }

    return strdup(buffer);
}

/**
 * Generate component registration C file
 * Creates a file that declares all component arrays and registers them in package.preload
 *
 * component_names: array of module names (e.g., "components.tabs", "components.color_palette")
 * component_c_names: array of C array names (e.g., "components_tabs", "components_color_palette")
 * count: number of components
 * output_path: path to write the registration file
 */
static int generate_component_registration(const char** component_names,
                                           const char** component_c_names,
                                           int count,
                                           const char* output_path) {
    FILE* out = fopen(output_path, "w");
    if (!out) {
        fprintf(stderr, "Error: Cannot create component registration file: %s\n", output_path);
        return -1;
    }

    fprintf(out, "/* Auto-generated by Kryon build system */\n");
    fprintf(out, "/* Registers embedded components in package.preload */\n\n");
    fprintf(out, "#include <stddef.h>\n");
    fprintf(out, "#include <lua.h>\n");
    fprintf(out, "#include <lauxlib.h>\n\n");

    /* Declare extern references to all component arrays */
    fprintf(out, "/* Component bytecode arrays */\n");
    for (int i = 0; i < count; i++) {
        fprintf(out, "extern const unsigned char %s[];\n", component_c_names[i]);
        fprintf(out, "extern const size_t %s_size;\n", component_c_names[i]);
    }
    fprintf(out, "\n");

    /* Loader function generator - lua_CFunction must return int */
    fprintf(out, "/* Generate a loader function for each component */\n");
    fprintf(out, "/* Load the bytecode and execute it to get module exports */\n");
    for (int i = 0; i < count; i++) {
        fprintf(out, "static int load_%s(lua_State *L) {\n", component_c_names[i]);
        fprintf(out, "    /* Load the bytecode as a function */\n");
        fprintf(out, "    int load_result = luaL_loadbuffer(L, (const char*)%s, %s_size, \"%s\");\n",
                component_c_names[i], component_c_names[i], component_names[i]);
        fprintf(out, "    if (load_result != LUA_OK) {\n");
        fprintf(out, "        /* If loading failed, return the error message */\n");
        fprintf(out, "        return lua_error(L);\n");
        fprintf(out, "    }\n");
        fprintf(out, "    /* Execute the loaded function to get module exports */\n");
        fprintf(out, "    int call_result = lua_pcall(L, 0, 1, 0);\n");
        fprintf(out, "    if (call_result != LUA_OK) {\n");
        fprintf(out, "        /* If execution failed, return the error */\n");
        fprintf(out, "        return lua_error(L);\n");
        fprintf(out, "    }\n");
        fprintf(out, "    /* Return the module exports (1 value on stack) */\n");
        fprintf(out, "    return 1;\n");
        fprintf(out, "}\n\n");
    }

    /* Registration function */
    fprintf(out, "/* Register all embedded components in package.preload */\n");
    fprintf(out, "void register_embedded_components(lua_State *L) {\n");
    fprintf(out, "    lua_getglobal(L, \"package\");\n");
    fprintf(out, "    lua_getfield(L, -1, \"preload\");\n\n");
    for (int i = 0; i < count; i++) {
        fprintf(out, "    lua_pushstring(L, \"%s\");\n", component_names[i]);
        fprintf(out, "    lua_pushcclosure(L, load_%s, 0);\n", component_c_names[i]);
        fprintf(out, "    lua_settable(L, -3);  /* package.preload[name] = loader */\n");
    }
    fprintf(out, "\n");
    fprintf(out, "    lua_pop(L, 2);  /* Remove package and preload tables */\n");
    fprintf(out, "}\n");

    fclose(out);
    printf("  Generated component registration: %s\n", output_path);
    return 0;
}

/**
 * Find LuaJIT installation directory using luajit -v
 * Returns the base path of the LuaJIT installation or NULL
 */
static char* find_luajit_base(void) {
    /* Get luajit path from 'which' command */
    char* luajit_path = run_command("which luajit");
    if (!luajit_path) return NULL;

    /* In Nix, path is like: /nix/store/...-luajit-2.1-.../bin/luajit
     * We need to extract: /nix/store/...-luajit-2.1-...
     */

    /* Find /bin/luajit suffix and remove it */
    char* bin_pos = strstr(luajit_path, "/bin/luajit");
    if (bin_pos) {
        *bin_pos = '\0';
        return luajit_path;
    }

    free(luajit_path);
    return NULL;
}

/**
 * Find LuaJIT include path
 */
static int find_luajit_include(char* path, size_t size) {
    /* First check environment variable */
    const char* env_path = getenv("LUAJIT_INCLUDE");
    if (env_path && file_exists(env_path)) {
        snprintf(path, size, "%s", env_path);
        return 1;
    }

    /* Try to find from 'luajit -v' output */
    char* base = find_luajit_base();
    if (base) {
        /* Check for include/luajit-2.1 */
        snprintf(path, size, "%s/include/luajit-2.1", base);
        if (file_exists(path)) {
            free(base);
            return 1;
        }

        /* Check for include (some systems use symlinks) */
        snprintf(path, size, "%s/include", base);
        if (file_exists(path)) {
            free(base);
            return 1;
        }

        free(base);
    }

    /* Common LuaJIT include paths */
    const char* candidates[] = {
        "/usr/include/luajit-2.1",
        "/usr/include/luajit-2.0",
        "/usr/local/include/luajit-2.1",
        "/usr/local/include/luajit-2.0",
        "/usr/include/luajit",
        "/usr/local/include/luajit",
        NULL
    };

    for (int i = 0; candidates[i]; i++) {
        if (file_exists(candidates[i])) {
            snprintf(path, size, "%s", candidates[i]);
            return 1;
        }
    }

    return 0;
}

/**
 * Find LuaJIT library path
 */
static int find_luajit_lib(char* path, size_t size) {
    /* First check environment variable */
    const char* env_path = getenv("LUAJIT_LIB");
    if (env_path && file_exists(env_path)) {
        snprintf(path, size, "%s", env_path);
        return 1;
    }

    /* Try to find from 'luajit -v' output */
    char* base = find_luajit_base();
    if (base) {
        /* Check for lib directory */
        snprintf(path, size, "%s/lib", base);
        if (file_exists(path)) {
            free(base);
            return 1;
        }
        free(base);
    }

    /* Standard paths */
    const char* candidates[] = {
        "/usr/lib",
        "/usr/local/lib",
        "/lib64",
        "/usr/lib64",
        NULL
    };

    for (int i = 0; candidates[i]; i++) {
        if (file_exists(candidates[i])) {
            snprintf(path, size, "%s", candidates[i]);
            return 1;
        }
    }

    return 0;
}

/**
 * Generate plugin registration C file
 * Creates a file that registers all embedded plugins in package.preload
 *
 * plugins: array of plugin info
 * plugin_count: number of plugins
 * output_path: path to write the registration file
 */
static int generate_plugin_registration(BuildPluginInfo* plugins, int plugin_count,
                                       const char* output_path) {
    FILE* out = fopen(output_path, "w");
    if (!out) {
        fprintf(stderr, "Error: Cannot create plugin registration file: %s\n", output_path);
        return -1;
    }

    fprintf(out, "/* Auto-generated by Kryon build system */\n");
    fprintf(out, "/* Registers embedded plugins in package.preload */\n\n");
    fprintf(out, "#include <stddef.h>\n");
    fprintf(out, "#include <lua.h>\n");
    fprintf(out, "#include <lauxlib.h>\n\n");

    /* Declare extern references to all plugin arrays */
    fprintf(out, "/* Plugin bytecode arrays */\n");
    for (int i = 0; i < plugin_count; i++) {
        fprintf(out, "extern const unsigned char plugin_%s[];\n", plugins[i].name);
        fprintf(out, "extern const size_t plugin_%s_size;\n", plugins[i].name);
    }
    fprintf(out, "\n");

    /* Loader function for each plugin - MUST be defined before register_embedded_plugins */
    fprintf(out, "/* Loader function for each plugin */\n");
    for (int i = 0; i < plugin_count; i++) {
        fprintf(out, "static int load_plugin_%s(lua_State *L) {\n", plugins[i].name);
        fprintf(out, "    int load_result = luaL_loadbuffer(L, (const char*)plugin_%s, plugin_%s_size, \"%s\");\n",
                plugins[i].name, plugins[i].name, plugins[i].name);
        fprintf(out, "    if (load_result != LUA_OK) {\n");
        fprintf(out, "        return lua_error(L);\n");
        fprintf(out, "    }\n");
        fprintf(out, "    int call_result = lua_pcall(L, 0, 1, 0);\n");
        fprintf(out, "    if (call_result != LUA_OK) {\n");
        fprintf(out, "        return lua_error(L);\n");
        fprintf(out, "    }\n");
        fprintf(out, "    return 1;\n");
        fprintf(out, "}\n\n");
    }

    /* Registration function - defined AFTER loader functions */
    fprintf(out, "/* Register all embedded plugins in package.preload */\n");
    fprintf(out, "void register_embedded_plugins(lua_State *L) {\n");
    fprintf(out, "    lua_getglobal(L, \"package\");\n");
    fprintf(out, "    lua_getfield(L, -1, \"preload\");\n\n");

    for (int i = 0; i < plugin_count; i++) {
        fprintf(out, "    lua_pushstring(L, \"%s\");\n", plugins[i].name);
        fprintf(out, "    lua_pushcclosure(L, load_plugin_%s, 0);\n", plugins[i].name);
        fprintf(out, "    lua_settable(L, -3);  /* package.preload[name] = loader */\n");
    }
    fprintf(out, "\n");
    fprintf(out, "    lua_pop(L, 2);  /* Remove package and preload tables */\n");
    fprintf(out, "}\n");

    fclose(out);
    printf("  Generated plugin registration: %s\n", output_path);
    return 0;
}

/**
 * Build Lua application to standalone binary
 *
 * @param project_name    Name of the project (used for binary name)
 * @param entry_lua       Path to main Lua entry file
 * @param output_binary   Path for output binary
 * @param runtime_dir     Path to Kryon runtime files (optional, for KRYON_RUNTIME)
 * @param verbose         Enable verbose output
 *
 * @return 0 on success, -1 on error
 */
int build_lua_binary(const char* project_name,
                     const char* entry_lua,
                     const char* output_binary,
                     const char* runtime_dir,
                     int verbose) {
    if (!project_name || !entry_lua || !output_binary) {
        fprintf(stderr, "Error: NULL parameters\n");
        return -1;
    }

    if (!file_exists(entry_lua)) {
        fprintf(stderr, "Error: Entry file not found: %s\n", entry_lua);
        return -1;
    }

    /* Create temporary directory for intermediate files */
    char temp_dir[BUILD_PATH_MAX];
    snprintf(temp_dir, sizeof(temp_dir), "/tmp/kryon_build_%s_XXXXXX", project_name);
    if (!mkdtemp(temp_dir)) {
        fprintf(stderr, "Error: Cannot create temp directory\n");
        return -1;
    }

    /* Path to embedded Kryon modules (will be set if modules are embedded) */
    char modules_c_path[BUILD_PATH_MAX] = "";
    int has_embedded_modules = 0;

    /* Track plugin C files for linking */
    char plugin_c_paths[MAX_PLUGINS][BUILD_PATH_MAX];
    char plugin_lib_paths[MAX_PLUGINS][BUILD_PATH_MAX];  /* Static library paths */
    char plugin_names[MAX_PLUGINS][64];              /* Plugin module names */
    char plugin_array_names[MAX_PLUGINS][64];         /* C array names (plugin_<name>) */
    char plugin_registration_path[BUILD_PATH_MAX] = "";  /* Generated registration file */
    int plugin_count = 0;

    /* Keep plugin info for later use during linking */
    BuildPluginInfo* plugins = NULL;
    int discovered_plugin_count = 0;

    /* Track component C files for linking */
    char component_c_paths[50][BUILD_PATH_MAX];
    char component_module_names[50][BUILD_PATH_MAX];  /* Module names like "components.tabs" */
    char component_c_names[50][BUILD_PATH_MAX];       /* C array names like "components_tabs" */
    int component_c_count = 0;

    if (verbose) {
        printf("Build directory: %s\n", temp_dir);
    }

    /* Step 1: Compile main Lua to bytecode */
    char bytecode_path[BUILD_PATH_MAX];
    snprintf(bytecode_path, sizeof(bytecode_path), "%s/%s.bc", temp_dir, project_name);

    printf("[1/4] Compiling main Lua to bytecode...\n");
    if (luajit_compile(entry_lua, bytecode_path) != 0) {
        fprintf(stderr, "Error: Failed to compile bytecode\n");
        return -1;
    }

    /* Step 2: Compile and embed Kryon runtime modules */
    char kryon_bindings_dir[BUILD_PATH_MAX];
    char* src_root = get_kryon_src_root();

    if (src_root) {
        snprintf(kryon_bindings_dir, sizeof(kryon_bindings_dir),
                 "%s/bindings/lua/kryon", src_root);
        free(src_root);
    } else {
        fprintf(stderr, "Warning: Kryon bindings not found, binary may not work\n");
        kryon_bindings_dir[0] = '\0';
    }

    if (kryon_bindings_dir[0] != '\0') {
        printf("[2/4] Embedding Kryon runtime modules...\n");

        /* List of Kryon modules to embed */
        const char* module_files[] = {
            "init.lua",
            "dsl.lua",
            "dsl_web.lua",
            "runtime.lua",
            "runtime_web.lua",
            "reactive.lua",
            "reactive_web.lua",
            "reactive_bindings.lua",
            "ffi.lua",
            "utils.lua",
            NULL
        };

        /* Count modules and prepare paths for embedding */
        int module_count = 0;
        char module_bc_paths[20][BUILD_PATH_MAX];
        const char* module_bc_ptrs[21];

        for (int i = 0; module_files[i] && module_count < 20; i++) {
            char module_path[BUILD_PATH_MAX];
            snprintf(module_path, sizeof(module_path), "%s/%s",
                     kryon_bindings_dir, module_files[i]);

            if (!file_exists(module_path)) {
                if (verbose) printf("  Skipping (not found): %s\n", module_files[i]);
                continue;
            }

            /* Compile to bytecode with proper naming for embedding */
            /* Name the bytecode file as "kryon_<module_name>.bc" so embed_multiple_bytecode
             * creates arrays named "kryon_<module_name>" */
            char module_bc_name[BUILD_PATH_MAX];
            snprintf(module_bc_name, sizeof(module_bc_name), "kryon_%.*s",
                     (int)(strcspn(module_files[i], ".")), module_files[i]);

            snprintf(module_bc_paths[module_count], sizeof(module_bc_paths[module_count]),
                     "%s/%s.bc", temp_dir, module_bc_name);

            if (luajit_compile(module_path, module_bc_paths[module_count]) != 0) {
                fprintf(stderr, "Warning: Failed to compile %s\n", module_files[i]);
                continue;
            }

            module_bc_ptrs[module_count] = module_bc_paths[module_count];
            module_count++;
            printf("  Embedded: kryon/%s\n", module_files[i]);
        }
        module_bc_ptrs[module_count] = NULL;

        if (module_count > 0) {
            /* Embed all modules as a single C file with preload setup */
            snprintf(modules_c_path, sizeof(modules_c_path), "%s/kryon_modules.c", temp_dir);

            if (embed_multiple_bytecode(module_bc_ptrs, module_count,
                                         modules_c_path, "kryon") == 0) {
                printf("  Created %s with %d modules\n", modules_c_path, module_count);
                has_embedded_modules = 1;
            }
        }

        /* Discover and embed plugins from configuration */
        /* Plugins are ONLY from kryon.toml [plugins] section - NO auto-discovery */
        char project_dir_copy[BUILD_PATH_MAX];

        /* Get project directory for plugin path resolution */
        size_t copy_len = strlen(entry_lua);
        if (copy_len >= BUILD_PATH_MAX) copy_len = BUILD_PATH_MAX - 1;
        memcpy(project_dir_copy, entry_lua, copy_len);
        project_dir_copy[copy_len] = '\0';
        char* project_dir = dirname(project_dir_copy);

        /* Load config and discover plugins */
        KryonConfig* config = config_find_and_load();
        if (config) {
            plugins = discover_build_plugins(project_dir, config, &discovered_plugin_count);
            config_free(config);  /* Free config, we keep plugins info */
        }

        /* Embed each plugin */
        if (plugins && discovered_plugin_count > 0) {
            printf("[2/4] Embedding plugins...\n");

            for (int i = 0; i < discovered_plugin_count; i++) {
                if (plugin_count >= MAX_PLUGINS) {
                    fprintf(stderr, "Warning: Too many plugins (max %d), skipping rest\n", MAX_PLUGINS);
                    break;
                }

                printf("  Embedding plugin: %s\n", plugins[i].name);

                /* Compile plugin Lua to bytecode */
                char plugin_bc_path[BUILD_PATH_MAX];
                snprintf(plugin_bc_path, sizeof(plugin_bc_path), "%s/plugin_%s.bc",
                         temp_dir, plugins[i].name);

                if (luajit_compile(plugins[i].lua_binding, plugin_bc_path) != 0) {
                    fprintf(stderr, "Error: Failed to compile plugin %s\n", plugins[i].name);
                    free_build_plugins(plugins, discovered_plugin_count);
                    return -1;
                }

                /* Embed bytecode as C array */
                int written = snprintf(plugin_c_paths[plugin_count], sizeof(plugin_c_paths[plugin_count]),
                         "%s/plugin_%s_data.c", temp_dir, plugins[i].name);
                if (written < 0 || (size_t)written >= sizeof(plugin_c_paths[plugin_count])) {
                    fprintf(stderr, "Error: Plugin C path too long for %s\n", plugins[i].name);
                    free_build_plugins(plugins, discovered_plugin_count);
                    return -1;
                }

                /* Store static library path for linking */
                written = snprintf(plugin_lib_paths[plugin_count], sizeof(plugin_lib_paths[plugin_count]),
                         "%s", plugins[i].static_lib);
                if (written < 0 || (size_t)written >= sizeof(plugin_lib_paths[plugin_count])) {
                    fprintf(stderr, "Error: Plugin lib path too long for %s\n", plugins[i].name);
                    free_build_plugins(plugins, discovered_plugin_count);
                    return -1;
                }

                /* Array name is plugin_<name> */
                written = snprintf(plugin_array_names[plugin_count], sizeof(plugin_array_names[plugin_count]),
                         "plugin_%s", plugins[i].name);
                if (written < 0 || (size_t)written >= sizeof(plugin_array_names[plugin_count])) {
                    fprintf(stderr, "Error: Plugin array name too long for %s\n", plugins[i].name);
                    free_build_plugins(plugins, discovered_plugin_count);
                    return -1;
                }
                written = snprintf(plugin_names[plugin_count], sizeof(plugin_names[plugin_count]),
                         "%s", plugins[i].name);
                if (written < 0 || (size_t)written >= sizeof(plugin_names[plugin_count])) {
                    fprintf(stderr, "Error: Plugin name too long for %s\n", plugins[i].name);
                    free_build_plugins(plugins, discovered_plugin_count);
                    return -1;
                }

                if (embed_bytecode(plugin_bc_path, plugin_c_paths[plugin_count],
                                   plugin_array_names[plugin_count]) != 0) {
                    fprintf(stderr, "Error: Failed to embed plugin %s\n", plugins[i].name);
                    free_build_plugins(plugins, discovered_plugin_count);
                    return -1;
                }

                printf("    Embedded: %s\n", plugins[i].lua_binding);
                plugin_count++;
            }

            /* Generate plugin registration file */
            if (plugin_count > 0) {
                snprintf(plugin_registration_path, sizeof(plugin_registration_path),
                         "%s/plugin_registration.c", temp_dir);
                if (generate_plugin_registration(plugins, plugin_count,
                                                 plugin_registration_path) != 0) {
                    fprintf(stderr, "Warning: Failed to generate plugin registration\n");
                    plugin_registration_path[0] = '\0';
                }
            }
        }

        /* Also embed project components for truly static builds */
        /* Scan components/ directory and embed all .lua files */

        /* Reuse project_dir from plugin discovery */
        char components_dir[BUILD_PATH_MAX];
        snprintf(components_dir, sizeof(components_dir), "%s/components", project_dir);

        if (file_exists(components_dir)) {
            printf("  Embedding project components...\n");

            /* Count component files */
            int component_count = 0;
            char component_files[50][BUILD_PATH_MAX];  // Max 50 components

            /* Use opendir/readdir to scan for .lua files */
            DIR* dir = opendir(components_dir);
            if (dir) {
                struct dirent* entry;
                while ((entry = readdir(dir)) != NULL && component_count < 50) {
                    size_t len = strlen(entry->d_name);
                    if (len > 4 && strcmp(entry->d_name + len - 4, ".lua") == 0) {
                        /* Found a .lua file */
                        char component_path[BUILD_PATH_MAX];
                        snprintf(component_path, sizeof(component_path), "%s/%s",
                                 components_dir, entry->d_name);

                        if (file_exists(component_path)) {
                            size_t copy_len = len;
                            if (copy_len >= (BUILD_PATH_MAX)) copy_len = (BUILD_PATH_MAX) - 1;
                            memcpy(component_files[component_count], entry->d_name, copy_len);
                            component_files[component_count][copy_len] = '\0';
                            component_count++;
                        }
                    }
                }
                closedir(dir);
            }

            /* Compile and embed each component */
            for (int i = 0; i < component_count; i++) {
                char component_path[BUILD_PATH_MAX];
                snprintf(component_path, sizeof(component_path), "%s/%s",
                         components_dir, component_files[i]);

                /* Create module name: components.filename (without .lua) */
                char module_name[BUILD_PATH_MAX];
                snprintf(module_name, sizeof(module_name), "components.%.*s",
                         (int)(strlen(component_files[i]) - 4), component_files[i]);

                /* Create C array name: components_filename (dots replaced with underscores) */
                char component_c_array_name[BUILD_PATH_MAX];
                snprintf(component_c_array_name, sizeof(component_c_array_name), "components_%.*s",
                         (int)(strlen(component_files[i]) - 4), component_files[i]);

                /* Create bytecode file name */
                char component_bc_name[BUILD_PATH_MAX];
                snprintf(component_bc_name, sizeof(component_bc_name), "components_%.*s",
                         (int)(strlen(component_files[i]) - 4), component_files[i]);

                char component_bc_path[BUILD_PATH_MAX];
                snprintf(component_bc_path, sizeof(component_bc_path), "%s/%s.bc",
                         temp_dir, component_bc_name);

                /* Compile to bytecode */
                if (luajit_compile(component_path, component_bc_path) == 0) {
                    /* Create separate C file for this component */
                    snprintf(component_c_paths[component_c_count], sizeof(component_c_paths[component_c_count]),
                             "%s/component_%d.c", temp_dir, i);

                    /* Embed bytecode with C array name (not module name, as C identifiers can't have dots) */
                    if (embed_bytecode(component_bc_path, component_c_paths[component_c_count], component_c_array_name) == 0) {
                        /* Store module name and C array name for registration */
                        size_t copy_len = strlen(module_name);
                        if (copy_len >= (BUILD_PATH_MAX)) copy_len = (BUILD_PATH_MAX) - 1;
                        memcpy(component_module_names[component_c_count], module_name, copy_len);
                        component_module_names[component_c_count][copy_len] = '\0';

                        copy_len = strlen(component_c_array_name);
                        if (copy_len >= (BUILD_PATH_MAX)) copy_len = (BUILD_PATH_MAX) - 1;
                        memcpy(component_c_names[component_c_count], component_c_array_name, copy_len);
                        component_c_names[component_c_count][copy_len] = '\0';

                        printf("  Embedded: %s\n", module_name);
                        component_c_count++;
                    }
                } else {
                    fprintf(stderr, "  Warning: Failed to compile %s\n", component_files[i]);
                }
            }

            if (component_count > 0) {
                printf("  Embedded %d component(s)\n", component_count);
            }
        }
    }

    /* Step 3: Embed main bytecode as C array */
    char bytecode_c_path[BUILD_PATH_MAX];
    snprintf(bytecode_c_path, sizeof(bytecode_c_path), "%s/bytecode_data.c", temp_dir);

    printf("[3/4] Embedding main bytecode...\n");
    if (embed_bytecode(bytecode_path, bytecode_c_path, "lua_bytecode") != 0) {
        fprintf(stderr, "Error: Failed to embed bytecode\n");
        return -1;
    }

    /* Step 3.5: Generate component registration file if we have components */
    char component_registration_path[BUILD_PATH_MAX] = "";
    if (component_c_count > 0) {
        snprintf(component_registration_path, sizeof(component_registration_path),
                 "%s/component_registration.c", temp_dir);

        /* Prepare arrays of strings for registration generation */
        const char* module_name_ptrs[50];
        const char* c_name_ptrs[50];
        for (int i = 0; i < component_c_count && i < 50; i++) {
            module_name_ptrs[i] = component_module_names[i];
            c_name_ptrs[i] = component_c_names[i];
        }

        if (generate_component_registration(module_name_ptrs, c_name_ptrs, component_c_count,
                                           component_registration_path) != 0) {
            fprintf(stderr, "Warning: Failed to generate component registration\n");
            component_registration_path[0] = '\0';
        }
    }

    /* Step 4: Compile and link binary */
    printf("[4/4] Linking binary...\n");

    /* Get the path to luajit_runtime.c */
    char runtime_src[BUILD_PATH_MAX];
    int found_rt = 0;

    /* Get Kryon source root again (we freed it earlier) */
    char* rt_root = get_kryon_src_root();
    if (rt_root) {
        snprintf(runtime_src, sizeof(runtime_src), "%s/cli/src/build/luajit_runtime.c", rt_root);
        free(rt_root);
        if (file_exists(runtime_src)) found_rt = 1;
    }

    /* Try relative to current directory */
    if (!found_rt) {
        snprintf(runtime_src, sizeof(runtime_src), "cli/src/build/luajit_runtime.c");
        if (file_exists(runtime_src)) found_rt = 1;
    }

    /* Try ./cli/src/build/luajit_runtime.c */
    if (!found_rt) {
        snprintf(runtime_src, sizeof(runtime_src), "./cli/src/build/luajit_runtime.c");
        if (file_exists(runtime_src)) found_rt = 1;
    }

    /* Try user-local install */
    if (!found_rt) {
        char* home = get_home_dir();
        if (home) {
            snprintf(runtime_src, sizeof(runtime_src), "%s/.local/share/kryon/cli/src/build/luajit_runtime.c", home);
            free(home);
            if (file_exists(runtime_src)) found_rt = 1;
        }
    }

    /* Try system install */
    if (!found_rt) {
        if (file_exists("/usr/local/share/kryon/cli/src/build/luajit_runtime.c")) {
            snprintf(runtime_src, sizeof(runtime_src), "/usr/local/share/kryon/cli/src/build/luajit_runtime.c");
            found_rt = 1;
        }
    }

    if (!found_rt) {
        fprintf(stderr, "Error: Cannot find luajit_runtime.c\n");
        fprintf(stderr, "Set KRYON_SRC_ROOT to point to the Kryon source directory\n");
        return -1;
    }

    if (verbose) {
        printf("Runtime source: %s\n", runtime_src);
    }

    /* Build gcc command - larger buffer for component files */
    char gcc_cmd[PATH_MAX * 64];  /* Increased to support component files */
    char include_flags[BUILD_PATH_MAX] = "";
    char lib_flags[BUILD_PATH_MAX] = "";

    /* Find LuaJIT paths */
    char include_path[BUILD_PATH_MAX];
    char lib_path[BUILD_PATH_MAX];

    if (find_luajit_include(include_path, sizeof(include_path))) {
        snprintf(include_flags, sizeof(include_flags), "-I%s", include_path);
    }

    if (find_luajit_lib(lib_path, sizeof(lib_path))) {
        snprintf(lib_flags, sizeof(lib_flags), "-L%s", lib_path);
    }

    /* Add Kryon runtime flags if provided */
    char runtime_flags[BUILD_PATH_MAX] = "";
    if (runtime_dir && file_exists(runtime_dir)) {
        snprintf(runtime_flags, sizeof(runtime_flags),
                 "-I%s/include -L%s/lib -DKRYON_RUNTIME",
                 runtime_dir, runtime_dir);
    }

    /* Build plugin C files string and library link flags for gcc command */
    char plugin_files_str[PATH_MAX * 20] = "";  /* Up to 20 plugin files */
    char plugin_lib_flags[PATH_MAX * 20] = "";   /* Plugin .a library paths */
    if (plugin_count > 0) {
        /* Add plugin registration file first */
        if (plugin_registration_path[0] != '\0') {
            int written = snprintf(plugin_files_str, sizeof(plugin_files_str), "\"%s\" ", plugin_registration_path);
            if (written < 0 || (size_t)written >= sizeof(plugin_files_str)) {
                fprintf(stderr, "Error: Plugin files string too long\n");
                return -1;
            }
        }

        /* Add all plugin C files and build library link flags */
        for (int i = 0; i < plugin_count; i++) {
            size_t current_len = strlen(plugin_files_str);
            size_t remaining = sizeof(plugin_files_str) - current_len;
            if (remaining > PATH_MAX + 5) {
                int written = snprintf(plugin_files_str + current_len, remaining,
                         "\"%s\" ", plugin_c_paths[i]);
                if (written < 0 || (size_t)written >= remaining) {
                    fprintf(stderr, "Error: Plugin files string overflow\n");
                    return -1;
                }
            }

            /* Add static library path to link flags */
            current_len = strlen(plugin_lib_flags);
            remaining = sizeof(plugin_lib_flags) - current_len;
            if (remaining > PATH_MAX + 5) {
                int written = snprintf(plugin_lib_flags + current_len, remaining,
                         "\"%s\" ", plugin_lib_paths[i]);
                if (written < 0 || (size_t)written >= remaining) {
                    fprintf(stderr, "Error: Plugin lib flags overflow\n");
                    return -1;
                }
            }
        }
        printf("  Linking %d plugin(s)\n", plugin_count);
    }

    /* Build component C files string for gcc command */
    char component_files_str[PATH_MAX * 50] = "";  /* Up to 50 component files */
    if (component_c_count > 0) {
        /* Add component registration file first */
        if (component_registration_path[0] != '\0') {
            int written = snprintf(component_files_str, sizeof(component_files_str), "\"%s\" ", component_registration_path);
            if (written < 0 || (size_t)written >= sizeof(component_files_str)) {
                fprintf(stderr, "Error: Component files string too long\n");
                return -1;
            }
        }

        /* Add all component C files */
        for (int i = 0; i < component_c_count; i++) {
            size_t current_len = strlen(component_files_str);
            size_t remaining = sizeof(component_files_str) - current_len;
            if (remaining > PATH_MAX + 5) {
                int written = snprintf(component_files_str + current_len, remaining,
                         "\"%s\" ", component_c_paths[i]);
                if (written < 0 || (size_t)written >= remaining) {
                    fprintf(stderr, "Error: Component files string overflow\n");
                    return -1;
                }
            }
        }
        printf("  Linking %d embedded component(s)\n", component_c_count);
    }

    /* Construct compilation command */
    /* Add KRYON_HAS_COMPONENTS if we have embedded components */
    /* Add KRYON_HAS_PLUGINS if we have embedded plugins */
    char components_flag[64] = "";
    char plugins_flag[64] = "";
    int written;
    if (component_c_count > 0) {
        written = snprintf(components_flag, sizeof(components_flag), "-DKRYON_HAS_COMPONENTS ");
        (void)written; /* Fixed string, checked */
    }
    if (plugin_count > 0) {
        written = snprintf(plugins_flag, sizeof(plugins_flag), "-DKRYON_HAS_PLUGINS ");
        (void)written; /* Fixed string, checked */
    }

    /* Build the gcc command with all embedded modules and plugins */
    written = snprintf(gcc_cmd, sizeof(gcc_cmd),
             "gcc -o \"%s\" "
             "-DAPP_NAME=\\\"%s\\\" "
             "%s "              /* embedded modules flag or empty */
             "%s "              /* components flag */
             "%s "              /* plugins flag */
             "%s "              /* include flags */
             "%s "              /* runtime flags */
             "-O2 "
             "\"%s\" "          /* runtime.c */
             "\"%s\" "          /* bytecode_data.c */
             "%s "              /* kryon_modules.c or empty */
             "%s "              /* plugin files */
             "%s "              /* component files */
             "%s "              /* lib flags */
             "%s "              /* plugin lib flags */
             "-lluajit-5.1 "
             "-lm -ldl",
             output_binary,
             project_name,
             has_embedded_modules ? "-DKRYON_EMBEDDED_MODULES " : "",
             components_flag,
             plugins_flag,
             include_flags,
             runtime_flags,
             runtime_src,
             bytecode_c_path,
             modules_c_path[0] ? modules_c_path : "",
             plugin_files_str,
             component_files_str,
             lib_flags,
             plugin_lib_flags);

    /* Check for truncation */
    if (written < 0 || (size_t)written >= sizeof(gcc_cmd)) {
        fprintf(stderr, "Error: GCC command too long, buffer truncated\n");
        return -1;
    }

    if (verbose) {
        printf("Compilation command: %s\n", gcc_cmd);
    }

    int result = system(gcc_cmd);
    if (result != 0) {
        fprintf(stderr, "Error: Failed to compile binary\n");
        return -1;
    }

    /* Verify output was created */
    if (!file_exists(output_binary)) {
        fprintf(stderr, "Error: Binary not created: %s\n", output_binary);
        return -1;
    }

    /* Make binary executable */
    chmod(output_binary, 0755);

    /* Get binary size */
    struct stat st;
    stat(output_binary, &st);

    printf("Binary created: %s (%zu bytes)\n", output_binary, (size_t)st.st_size);

    /* Cleanup plugin info */
    if (plugins) {
        free_build_plugins(plugins, discovered_plugin_count);
    }

    /* Cleanup temp directory (keep it if verbose for debugging) */
    if (!verbose) {
        char cleanup_cmd[BUILD_PATH_MAX];
        snprintf(cleanup_cmd, sizeof(cleanup_cmd), "rm -rf \"%s\"", temp_dir);
        int cleanup_result = system(cleanup_cmd);
        if (cleanup_result != 0) {
            fprintf(stderr, "Warning: Failed to cleanup temp directory (code %d)\n", cleanup_result);
        }
    } else {
        printf("Temp files kept at: %s\n", temp_dir);
    }

    return 0;
}

/**
 * Simple test function to check LuaJIT availability
 */
int check_luajit_available(void) {
    char path[BUILD_PATH_MAX];
    return find_luajit_include(path, sizeof(path)) &&
           find_luajit_lib(path, sizeof(path));
}

#pragma GCC diagnostic pop
