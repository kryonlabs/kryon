#!/usr/bin/env python3
"""
generate_serialization.py (JSON version)

Generates C code for JSON serialization/deserialization from IR node spec.
Reads ir_nodes.json and generates:
  - ir_json_serialize.gen.c
  - ir_json_deserialize.gen.c
  - ir_json_serialization.gen.h

This eliminates ~2,000-2,500 lines of duplicated code.
"""

import json
import os
import sys
from pathlib import Path

# ============================================================================
# Templates
# ============================================================================

HEADER_TEMPLATE = """/**
 * @file {filename}
 * @brief Generated JSON {direction} functions
 *
 * AUTO-GENERATED by generate_serialization.py
 * DO NOT EDIT MANUALLY - Changes will be overwritten!
 *
 * Generated from: ir/spec/ir_nodes.json
 */

#ifndef {include_guard}
#define {include_guard}

#include "../include/ir_core.h"
#include "../include/ir_builder.h"
#include "../../../third_party/cJSON/cJSON.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef __cplusplus
extern "C" {{
#endif

{declarations}

#ifdef __cplusplus
}}
#endif

#endif // {include_guard}
"""

# ============================================================================
# Generator Class
# ============================================================================

class SerializationGenerator:
    def __init__(self, spec_path, output_dir):
        self.spec_path = Path(spec_path)
        self.output_dir = Path(output_dir)
        self.spec = self.load_spec()

    def load_spec(self):
        """Load JSON specification"""
        with open(self.spec_path) as f:
            return json.load(f)

    def generate_serialize_property(self, prop, component_name):
        """Generate serialization code for a single property"""
        name = prop['name']
        prop_type = prop['type']
        json_key = prop['json_key']
        accessor = prop.get('accessor', f'comp->{name}')
        nullable = prop.get('nullable', False)
        default = prop.get('default', '')

        if prop_type == 'string':
            if nullable:
                return f"""    // Serialize {name}
    if ({accessor}) {{
        cJSON_AddStringToObject(json, "{json_key}", {accessor});
    }}"""

        elif prop_type == 'dimension':
            return f"""    // Serialize {name}
    if ({accessor}.type != IR_DIMENSION_AUTO || {accessor}.value != 0) {{
        char* {name}_str = ir_json_serialize_dimension_to_string({accessor});
        cJSON_AddStringToObject(json, "{json_key}", {name}_str);
        free({name}_str);
    }}"""

        elif prop_type == 'color':
            return f"""    // Serialize {name}
    char* {name}_str = ir_json_serialize_color_to_string({accessor});
    if ({name}_str) {{
        cJSON_AddStringToObject(json, "{json_key}", {name}_str);
        free({name}_str);
    }}"""

        elif prop_type == 'enum':
            return f"""    // Serialize {name}
    if ({accessor}) {{
        cJSON_AddStringToObject(json, "{json_key}", {accessor});
    }}"""

        elif prop_type == 'boolean':
            return f"""    // Serialize {name}
    cJSON_AddBoolToObject(json, "{json_key}", {accessor});"""

        elif prop_type in ['integer', 'float']:
            return f"""    // Serialize {name}
    cJSON_AddNumberToObject(json, "{json_key}", {accessor});"""

        else:
            return f"""    // Serialize {name} ({prop_type})
    // TODO: Implement {name} serialization"""

    def generate_deserialize_property(self, prop, component_name):
        """Generate deserialization code for a single property"""
        name = prop['name']
        prop_type = prop['type']
        json_key = prop['json_key']
        accessor = prop.get('accessor', f'comp->{name}')
        default = prop.get('default', '')
        nullable = prop.get('nullable', False)

        if prop_type == 'string':
            return f"""    // Deserialize {name}
    cJSON* {name}_item = cJSON_GetObjectItem(json, "{json_key}");
    if ({name}_item && cJSON_IsString({name}_item)) {{
        const char* {name}_str = cJSON_GetStringValue({name}_item);
        if ({name}_str) {{
            {accessor} = strdup({name}_str);
        }}
    }}"""

        elif prop_type == 'dimension':
            return f"""    // Deserialize {name}
    cJSON* {name}_item = cJSON_GetObjectItem(json, "{json_key}");
    if ({name}_item && cJSON_IsString({name}_item)) {{
        const char* {name}_str = cJSON_GetStringValue({name}_item);
        if ({name}_str) {{
            if (strstr({name}_str, "px")) {{
                {accessor}.type = IR_DIMENSION_PX;
                {accessor}.value = atof({name}_str);
            }} else if (strstr({name}_str, "%")) {{
                {accessor}.type = IR_DIMENSION_PERCENT;
                {accessor}.value = atof({name}_str);
            }} else if (strcmp({name}_str, "auto") == 0) {{
                {accessor}.type = IR_DIMENSION_AUTO;
                {accessor}.value = 0;
            }}
        }}
    }}"""

        elif prop_type == 'color':
            return f"""    // Deserialize {name}
    cJSON* {name}_item = cJSON_GetObjectItem(json, "{json_key}");
    if ({name}_item && cJSON_IsString({name}_item)) {{
        const char* {name}_str = cJSON_GetStringValue({name}_item);
        if ({name}_str && {name}_str[0] == '#') {{
            unsigned int r, g, b, a;
            if (strlen({name}_str) == 7) {{
                sscanf({name}_str, "#%2x%2x%2x", &r, &g, &b);
                {accessor}.type = IR_COLOR_SOLID;
                {accessor}.data.r = (uint8_t)r;
                {accessor}.data.g = (uint8_t)g;
                {accessor}.data.b = (uint8_t)b;
                {accessor}.data.a = 255;
            }} else if (strlen({name}_str) == 9) {{
                sscanf({name}_str, "#%2x%2x%2x%2x", &r, &g, &b, &a);
                {accessor}.type = IR_COLOR_SOLID;
                {accessor}.data.r = (uint8_t)r;
                {accessor}.data.g = (uint8_t)g;
                {accessor}.data.b = (uint8_t)b;
                {accessor}.data.a = (uint8_t)a;
            }}
        }}
    }}"""

        elif prop_type == 'boolean':
            return f"""    // Deserialize {name}
    cJSON* {name}_item = cJSON_GetObjectItem(json, "{json_key}");
    if ({name}_item) {{
        {accessor} = cJSON_IsTrue({name}_item);
    }}"""

        elif prop_type in ['integer', 'float']:
            return f"""    // Deserialize {name}
    cJSON* {name}_item = cJSON_GetObjectItem(json, "{json_key}");
    if ({name}_item && cJSON_IsNumber({name}_item)) {{
        {accessor} = cJSON_GetNumberValue({name}_item);
    }}"""

        else:
            return f"""    // Deserialize {name} ({prop_type})
    // TODO: Implement {name} deserialization"""

    def generate_serialize_function(self, component_name, component_type, properties):
        """Generate complete serialize function"""
        # Add component type first
        body = [
            '    // Add component type',
            f'    cJSON_AddStringToObject(json, "type", "{component_name}");',
            ''
        ]

        # Add all properties
        for prop in properties:
            prop_code = self.generate_serialize_property(prop, component_name)
            if prop_code.strip():
                body.append(prop_code)
                body.append('')

        body_str = '\n'.join(body).rstrip()

        return f"""cJSON* ir_serialize_{component_name.lower()}(IRComponent* comp) {{
    if (!comp) return NULL;

    cJSON* json = cJSON_CreateObject();
    if (!json) return NULL;

{body_str}

    return json;
}}
"""

    def generate_deserialize_function(self, component_name, component_type, properties):
        """Generate complete deserialize function"""
        body = []

        # Add all properties
        for prop in properties:
            prop_code = self.generate_deserialize_property(prop, component_name)
            if prop_code.strip():
                body.append(prop_code)
                body.append('')

        body_str = '\n'.join(body).rstrip()

        return f"""IRComponent* ir_deserialize_{component_name.lower()}(cJSON* json) {{
    if (!json) return NULL;

    // Create component
    IRComponent* comp = ir_component_create({component_type});
    if (!comp) {{
        fprintf(stderr, "Error: Failed to create {component_name} component\\n");
        return NULL;
    }}

    IRStyle* style = comp->style;
    if (!style) {{
        fprintf(stderr, "Error: Component has no style\\n");
        ir_component_destroy(comp);
        return NULL;
    }}

{body_str}

    return comp;
}}
"""

    def generate_all(self):
        """Generate all serialization files"""
        print(f"Generating serialization code from {self.spec_path}")

        # Create output directory
        self.output_dir.mkdir(parents=True, exist_ok=True)

        # Collect all component types
        component_types = self.spec.get('component_types', {})

        # Generate declarations and functions
        serialize_decls = []
        deserialize_decls = []
        serialize_funcs = []
        deserialize_funcs = []

        for component_name, spec in component_types.items():
            component_type = spec.get('type', f'IR_COMPONENT_{component_name.upper()}')
            properties = spec.get('properties', [])

            # Generate functions
            serialize_funcs.append(f"// {component_name}")
            serialize_funcs.append(self.generate_serialize_function(
                component_name, component_type, properties
            ))
            serialize_funcs.append('')

            deserialize_funcs.append(f"// {component_name}")
            deserialize_funcs.append(self.generate_deserialize_function(
                component_name, component_type, properties
            ))
            deserialize_funcs.append('')

            # Generate declarations
            serialize_decls.append(f"/** {component_name} **/")
            serialize_decls.append(f"cJSON* ir_serialize_{component_name.lower()}(IRComponent* comp);")
            serialize_decls.append('')

            deserialize_decls.append(f"/** {component_name} **/")
            deserialize_decls.append(f"IRComponent* ir_deserialize_{component_name.lower()}(cJSON* json);")
            deserialize_decls.append('')

        # Write serialize header
        serialize_header = HEADER_TEMPLATE.format(
            filename="ir_json_serialize.gen.h",
            direction="serialization",
            include_guard="IR_JSON_SERIALIZE_GEN_H",
            declarations='\n'.join(serialize_decls)
        )

        serialize_header_path = self.output_dir / "ir_json_serialize.gen.h"
        with open(serialize_header_path, 'w') as f:
            f.write(serialize_header)

        print(f"✓ Generated: {serialize_header_path}")

        # Write deserialize header
        deserialize_header = HEADER_TEMPLATE.format(
            filename="ir_json_deserialize.gen.h",
            direction="deserialization",
            include_guard="IR_JSON_DESERIALIZE_GEN_H",
            declarations='\n'.join(deserialize_decls)
        )

        deserialize_header_path = self.output_dir / "ir_json_deserialize.gen.h"
        with open(deserialize_header_path, 'w') as f:
            f.write(deserialize_header)

        print(f"✓ Generated: {deserialize_header_path}")

        # Write serialize implementation
        serialize_impl_path = self.output_dir / "ir_json_serialize.gen.c"
        with open(serialize_impl_path, 'w') as f:
            f.write("""/**
 * @file ir_json_serialize.gen.c
 * @brief Generated JSON serialization implementation
 *
 * AUTO-GENERATED - DO NOT EDIT
 */
#include "ir_json_serialize.gen.h"
#include "ir_json_serialize.h"

""")
            f.write('\n'.join(serialize_funcs))

        print(f"✓ Generated: {serialize_impl_path} ({len(serialize_funcs)} lines)")

        # Write deserialize implementation
        deserialize_impl_path = self.output_dir / "ir_json_deserialize.gen.c"
        with open(deserialize_impl_path, 'w') as f:
            f.write("""/**
 * @file ir_json_deserialize.gen.c
 * @brief Generated JSON deserialization implementation
 *
 * AUTO-GENERATED - DO NOT EDIT
 */
#include "ir_json_deserialize.gen.h"
#include "ir_json_deserialize.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

""")
            f.write('\n'.join(deserialize_funcs))

        print(f"✓ Generated: {deserialize_impl_path} ({len(deserialize_funcs)} lines)")

        print(f"\n✅ Generation complete!")
        print(f"  Generated {len(component_types)} component types")
        print(f"  Output directory: {self.output_dir}")
        print(f"  Total lines: {len(serialize_funcs) + len(deserialize_funcs)}")

# ============================================================================
# Main
# ============================================================================

if __name__ == '__main__':
    if len(sys.argv) < 2:
        print("Usage: generate_serialization.py <spec_path> [output_dir]")
        print("  spec_path: Path to ir_nodes.json")
        print("  output_dir: Output directory (default: src/serialization/)")
        sys.exit(1)

    spec_path = sys.argv[1]
    output_dir = sys.argv[2] if len(sys.argv) > 2 else "src/serialization"

    generator = SerializationGenerator(spec_path, output_dir)
    generator.generate_all()
