/**
 * LuaJIT Runtime Loader Template
 *
 * This file is used as a template for generating standalone executables
 * with embedded Lua bytecode. The build system will:
 * 1. Compile Lua source to bytecode using luajit -b
 * 2. Convert bytecode to C array (bytecode_data.c)
 * 3. Compile this template together with bytecode data and LuaJIT runtime
 *
 * Usage:
 *   gcc -o app luajit_runtime.c bytecode_data.c -lluajit-5.1
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>

/**
 * Embedded bytecode and size
 * These are defined in the generated bytecode_data.c
 */
extern const unsigned char lua_bytecode[];
extern const size_t lua_bytecode_size;

/* Embedded Kryon runtime modules (when KRYON_EMBEDDED_MODULES is defined) */
#ifdef KRYON_EMBEDDED_MODULES
extern const unsigned char kryon_init[];
extern const size_t kryon_init_size;
extern const unsigned char kryon_dsl[];
extern const size_t kryon_dsl_size;
extern const unsigned char kryon_dsl_web[];
extern const size_t kryon_dsl_web_size;
extern const unsigned char kryon_runtime[];
extern const size_t kryon_runtime_size;
extern const unsigned char kryon_runtime_web[];
extern const size_t kryon_runtime_web_size;
extern const unsigned char kryon_reactive[];
extern const size_t kryon_reactive_size;
extern const unsigned char kryon_reactive_web[];
extern const size_t kryon_reactive_web_size;
extern const unsigned char kryon_reactive_bindings[];
extern const size_t kryon_reactive_bindings_size;
extern const unsigned char kryon_ffi[];
extern const size_t kryon_ffi_size;
extern const unsigned char kryon_utils[];
extern const size_t kryon_utils_size;
extern const unsigned char kryon_plugin[];
extern const size_t kryon_plugin_size;
extern const unsigned char kryon_plugins_storage[];
extern const size_t kryon_plugins_storage_size;
extern const unsigned char kryon_plugins_datetime[];
extern const size_t kryon_plugins_datetime_size;
#endif

/* Embedded plugins (when KRYON_HAS_PLUGINS is defined) */
/* These are declared in the generated plugin_registration.c */
#ifdef KRYON_HAS_PLUGINS
extern void register_embedded_plugins(lua_State* L);
#else
static void register_embedded_plugins(lua_State* L) {
    (void)L;  /* No plugins */
}
#endif

/* Embedded components registration (when KRYON_HAS_COMPONENTS is defined) */
/* This function is defined in component_registration.c generated during build */
#ifdef KRYON_HAS_COMPONENTS
extern void register_embedded_components(lua_State* L);
#else
static void register_embedded_components(lua_State* L) {
    (void)L;  /* Unused when no components */
}
#endif

/* Application name (set at compile time) */
#ifndef APP_NAME
#define APP_NAME "kryon_app"
#endif

/* Kryon runtime integration flag */
#ifdef KRYON_RUNTIME
#include "kryon_desktop.h"
#endif

/**
 * Register an embedded module in package.preload
 */
static void register_module(lua_State* L, const char* name,
                           const unsigned char* bytecode, size_t size) {
    lua_getglobal(L, "package");
    lua_getfield(L, -1, "preload");
    lua_remove(L, -2);  /* Remove package table */

    /* Load the module bytecode */
    if (luaL_loadbuffer(L, (const char*)bytecode, size, name) == 0) {
        /* Store in package.preload[name] = loader_function */
        lua_setfield(L, -2, name);
    } else {
        /* If loading failed, pop the error message */
        fprintf(stderr, "Warning: Failed to load embedded module: %s\n", name);
        lua_pop(L, 1);
    }

    lua_pop(L, 1);  /* Remove package.preload table */
}

/**
 * Register all embedded Kryon modules
 */
static void register_embedded_modules(lua_State* L) {
#ifdef KRYON_EMBEDDED_MODULES
    register_module(L, "kryon.init", kryon_init, kryon_init_size);
    register_module(L, "kryon.dsl", kryon_dsl, kryon_dsl_size);
    register_module(L, "kryon.dsl_web", kryon_dsl_web, kryon_dsl_web_size);
    register_module(L, "kryon.runtime", kryon_runtime, kryon_runtime_size);
    register_module(L, "kryon.runtime_web", kryon_runtime_web, kryon_runtime_web_size);
    register_module(L, "kryon.reactive", kryon_reactive, kryon_reactive_size);
    register_module(L, "kryon.reactive_web", kryon_reactive_web, kryon_reactive_web_size);
    register_module(L, "kryon.reactive_bindings", kryon_reactive_bindings, kryon_reactive_bindings_size);
    register_module(L, "kryon.ffi", kryon_ffi, kryon_ffi_size);
    register_module(L, "kryon.utils", kryon_utils, kryon_utils_size);
    register_module(L, "kryon.plugin", kryon_plugin, kryon_plugin_size);
    register_module(L, "kryon.plugins.storage", kryon_plugins_storage, kryon_plugins_storage_size);
    register_module(L, "kryon.plugins.datetime", kryon_plugins_datetime, kryon_plugins_datetime_size);
#endif
}

/**
 * Pass command line arguments to Lua script
 * Sets up 'arg' table like standard Lua interpreter
 */
static void push_args(lua_State* L, int argc, char** argv) {
    lua_newtable(L);

    /* arg[0] = script name */
    if (argc > 0) {
        lua_pushstring(L, argv[0]);
        lua_rawseti(L, -2, 0);
    }

    /* arg[-1], arg[0], arg[1], ... = arguments */
    /* Standard Lua: arg[n] for n >= 0 are script args, arg[-1] is prog name */
    int script_arg = 0;
    for (int i = 1; i < argc; i++) {
        lua_pushstring(L, argv[i]);
        lua_rawseti(L, -2, ++script_arg);
    }

    lua_setglobal(L, "arg");
}

/**
 * Custom panic handler for Lua errors
 */
static int panic_handler(lua_State* L) {
    fprintf(stderr, "PANIC: unprotected error in call to Lua API (%s)\n",
            lua_tostring(L, -1));
    return 0;
}

/**
 * Load and run embedded bytecode, then start desktop runtime
 */
static int run_bytecode(lua_State* L, int argc, char** argv) {
    /* Push arguments to Lua */
    push_args(L, argc, argv);

    /* Load embedded bytecode */
    int load_result = luaL_loadbuffer(L,
                                     (const char*)lua_bytecode,
                                     lua_bytecode_size,
                                     APP_NAME);
    if (load_result != 0) {
        fprintf(stderr, "Error loading bytecode: %s\n", lua_tostring(L, -1));
        return 1;
    }

    /* Execute the bytecode - expect 1 result (the app object) */
    int exec_result = lua_pcall(L, 0, 1, 0);
    if (exec_result != 0) {
        fprintf(stderr, "Error executing bytecode: %s\n", lua_tostring(L, -1));
        return 1;
    }

    /* Check if an app object was returned */
    if (lua_isnil(L, -1)) {
        /* No app returned - just exit normally */
        return 0;
    }

    /* An app object was returned - start the desktop runtime */
    /* Require "kryon.runtime" and call runDesktop(app) */

    /* Get the require function */
    lua_getglobal(L, "require");
    /* Push the module name */
    lua_pushstring(L, "kryon.runtime");
    /* Call require("kryon.runtime") */
    if (lua_pcall(L, 1, 1, 0) != 0) {
        fprintf(stderr, "Warning: Failed to require kryon.runtime: %s\n", lua_tostring(L, -1));
        lua_pop(L, 1);
        return 0;
    }

    /* Now we have the Runtime module on stack, get runDesktop function */
    if (!lua_istable(L, -1)) {
        fprintf(stderr, "Warning: kryon.runtime did not return a table\n");
        lua_pop(L, 1);
        return 0;
    }

    lua_getfield(L, -1, "runDesktop");
    if (!lua_isfunction(L, -1)) {
        fprintf(stderr, "Warning: kryon.runtime.runDesktop not found\n");
        lua_pop(L, 2);  /* Pop runtime table and runDesktop (nil) */
        return 0;
    }

    /* We have runDesktop function at -1, runtime table at -2, app object at -3 */
    /* Push app object as argument */
    lua_pushvalue(L, -3);

    /* Call runDesktop(app) - this blocks until app exits */
    if (lua_pcall(L, 1, 0, 0) != 0) {
        fprintf(stderr, "Error in desktop runtime: %s\n", lua_tostring(L, -1));
        lua_pop(L, 1);
    }

    /* Cleanup stack */
    lua_pop(L, 2);  /* Pop runtime table and app object */

    return 0;
}

/**
 * Main entry point
 */
int main(int argc, char** argv) {
    /* Create Lua state */
    lua_State* L = luaL_newstate();
    if (!L) {
        fprintf(stderr, "Error: Cannot create Lua state\n");
        return 1;
    }

    /* Set panic handler */
    lua_atpanic(L, panic_handler);

    /* Open standard libraries */
    luaL_openlibs(L);

    /* Register embedded Kryon modules */
    register_embedded_modules(L);

    /* Register embedded plugins (if any) */
    register_embedded_plugins(L);

    /* Register embedded project components (if any) */
    register_embedded_components(L);

    /* Set runtime mode flag for DSL components (ForEach, etc.) */
    /* This tells ForEach to serialize actual data instead of markers */
    lua_getglobal(L, "require");
    lua_pushstring(L, "kryon.runtime");
    if (lua_pcall(L, 1, 1, 0) == 0) {
        /* Get the Runtime module table */
        if (lua_istable(L, -1)) {
            lua_pushstring(L, "_isRuntimeMode");
            lua_pushboolean(L, 1);
            lua_settable(L, -3);  /* Runtime._isRuntimeMode = true */
        }
        lua_pop(L, 1);  /* Pop Runtime module */
    } else {
        /* Pop error message if require failed */
        lua_pop(L, 1);
    }

    /* Set package.path to find local project files */
    lua_getglobal(L, "package");
    lua_pushstring(L, "./?.lua;./?/init.lua;./components/?.lua;./components/?/init.lua");
    lua_setfield(L, -2, "path");
    lua_pop(L, 1);  /* Remove package table */

    /* Set global app name */
    lua_pushstring(L, APP_NAME);
    lua_setglobal(L, "_APP_NAME");

#ifdef KRYON_RUNTIME
    /* Initialize Kryon desktop runtime */
    /* This will be available when linking with Kryon desktop backend */
    lua_pushboolean(L, 1);
    lua_setglobal(L, "_KRYON_RUNTIME");
#endif

    /* Run the embedded bytecode */
    int exit_code = run_bytecode(L, argc, argv);

    /* Cleanup */
    lua_close(L);

    return exit_code;
}

/**
 * Template for bytecode_data.c (generated by embed_bytecode):
 *
 * #include <stddef.h>
 *
 * const unsigned char lua_bytecode[] = {
 *   0x1b, 0x4c, 0x4a, 0x02, 0x00, 0x00, 0x00, ...
 * };
 *
 * const size_t lua_bytecode_size = 1234;
 */
