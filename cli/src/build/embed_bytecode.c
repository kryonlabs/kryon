/**
 * Bytecode Embedder
 * Converts bytecode files to C arrays for embedding
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <limits.h>

/**
 * Read a file into memory
 */
static char* read_file(const char* path, size_t* out_size) {
    FILE* f = fopen(path, "rb");
    if (!f) {
        fprintf(stderr, "Error: Cannot open file: %s\n", path);
        return NULL;
    }

    // Get file size
    fseek(f, 0, SEEK_END);
    long size = ftell(f);
    fseek(f, 0, SEEK_SET);

    if (size < 0) {
        fclose(f);
        fprintf(stderr, "Error: Cannot get file size: %s\n", path);
        return NULL;
    }

    // Allocate buffer
    char* buffer = (char*)malloc(size + 1);
    if (!buffer) {
        fclose(f);
        fprintf(stderr, "Error: Cannot allocate buffer for file: %s\n", path);
        return NULL;
    }

    // Read file
    size_t read_size = fread(buffer, 1, size, f);
    fclose(f);

    if (read_size != (size_t)size) {
        free(buffer);
        fprintf(stderr, "Error: Cannot read file: %s\n", path);
        return NULL;
    }

    buffer[size] = '\0';
    if (out_size) *out_size = size;

    return buffer;
}

/**
 * Escape byte for C array representation
 */
static void print_escaped_byte(FILE* f, unsigned char byte, bool* first) {
    fprintf(f, "%s0x%02x", *first ? "" : ", ", byte);
    *first = false;
}

/**
 * Embed bytecode file as C array
 */
int embed_bytecode(const char* bytecode_file, const char* output_c, const char* array_name) {
    size_t size = 0;
    char* data = read_file(bytecode_file, &size);
    if (!data) {
        return -1;
    }

    FILE* out = fopen(output_c, "w");
    if (!out) {
        fprintf(stderr, "Error: Cannot create output file: %s\n", output_c);
        free(data);
        return -1;
    }

    const char* name = array_name ? array_name : "lua_bytecode";

    fprintf(out, "/* Auto-generated by Kryon embed_bytecode */\n");
    fprintf(out, "/* Source: %s */\n\n", bytecode_file);
    fprintf(out, "#include <stddef.h>\n\n");
    fprintf(out, "const unsigned char %s[] = {", name);

    // Print bytes as hex array (12 bytes per line)
    bool first = true;
    for (size_t i = 0; i < size; i++) {
        if (i % 12 == 0) {
            fprintf(out, "\n  ");
        }
        print_escaped_byte(out, (unsigned char)data[i], &first);
    }

    fprintf(out, "\n};\n\n");
    fprintf(out, "const size_t %s_size = %zu;\n", name, size);

    fclose(out);
    free(data);

    printf("  Embedded bytecode: %s (%zu bytes) -> %s\n", bytecode_file, size, output_c);
    return 0;
}

/**
 * Embed multiple bytecode files into a single C file
 */
int embed_multiple_bytecode(const char** bytecode_files, int count,
                             const char* output_c,
                             const char* project_name) {
    FILE* out = fopen(output_c, "w");
    if (!out) {
        fprintf(stderr, "Error: Cannot create output file: %s\n", output_c);
        return -1;
    }

    fprintf(out, "/* Auto-generated by Kryon embed_bytecode */\n");
    fprintf(out, "/* Project: %s */\n\n", project_name);
    fprintf(out, "#include <stddef.h>\n\n");

    // For each file, embed it
    for (int i = 0; i < count; i++) {
        const char* bc_file = bytecode_files[i];
        if (!bc_file) continue;

        // Generate array name
        const char* basename = strrchr(bc_file, '/');
        basename = basename ? basename + 1 : bc_file;

        // Remove .bc extension if present
        char array_name[256];
        snprintf(array_name, sizeof(array_name), "%.*s",
                 (int)(strrchr(basename, '.') ? (int)(strrchr(basename, '.') - basename) : (int)strlen(basename)),
                 basename);

        // Read bytecode
        size_t size = 0;
        char* data = read_file(bc_file, &size);
        if (!data) {
            fclose(out);
            return -1;
        }

        fprintf(out, "/* Source: %s */\n", bc_file);
        fprintf(out, "const unsigned char %s[] = {", array_name);

        bool first = true;
        for (size_t j = 0; j < size; j++) {
            if (j % 12 == 0) {
                fprintf(out, "\n  ");
            }
            print_escaped_byte(out, (unsigned char)data[j], &first);
        }

        fprintf(out, "\n};\n\n");
        fprintf(out, "const size_t %s_size = %zu;\n\n", array_name, size);

        free(data);
    }

    fclose(out);
    return 0;
}
