/**
 * C Code Generator - KIR → C Source Code
 *
 * Generates idiomatic C code with Kryon DSL from KIR JSON files
 */

#include "ir_c_codegen.h"
#include "ir_c_internal.h"
#include "ir_c_output.h"
#include "ir_c_types.h"
#include "ir_c_reactive.h"
#include "ir_c_expression.h"
#include "ir_c_components.h"
#include "../codegen_common.h"
#include "../../ir/src/utils/ir_c_metadata.h"
#include "../../third_party/cJSON/cJSON.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <ctype.h>

// ============================================================================
// Internal Aliases for Utility Functions
// ============================================================================

// These aliases allow existing code to use the shorter names
#define write_indent(ctx) c_write_indent(ctx)
#define writeln(ctx, str) c_writeln(ctx, str)
#define write_raw(ctx, str) c_write_raw(ctx, str)

// Reactive function aliases
#define is_reactive_variable(ctx, name) c_is_reactive_variable(ctx, name)
#define get_scoped_var_name(ctx, name) c_get_scoped_var_name(ctx, name)
#define generate_scoped_var_name(name, scope) c_generate_scoped_var_name(name, scope)
#define get_signal_creator(type) c_get_signal_creator(type)
#define generate_reactive_signal_declarations(ctx) c_generate_reactive_signal_declarations(ctx)
#define generate_reactive_signal_initialization(ctx) c_generate_reactive_signal_initialization(ctx)
#define generate_reactive_signal_cleanup(ctx) c_generate_reactive_signal_cleanup(ctx)

// Expression/statement function aliases (from ir_c_expression.h)
#define is_range_call(expr, start, end) c_is_range_call(expr, start, end)
#define expr_to_c(expr) c_expr_to_c(expr)
#define stmt_to_c(output, stmt, indent, path) c_stmt_to_c(output, stmt, indent, path)

// Component generation aliases (from ir_c_components.h)
#define generate_component_recursive(ctx, comp, root) c_generate_component_recursive(ctx, comp, root)
#define generate_property_macro(ctx, key, val, first) c_generate_property_macro(ctx, key, val, first)
#define generate_component_definitions(ctx, defs) c_generate_component_definitions(ctx, defs)

// ============================================================================
// Utility Functions
// ============================================================================

// Get variable name for a component ID
static const char* get_variable_for_component_id(CCodegenContext* ctx, int component_id) {
    if (!ctx->variables) return NULL;

    int var_count = cJSON_GetArraySize(ctx->variables);
    for (int i = 0; i < var_count; i++) {
        cJSON* var = cJSON_GetArrayItem(ctx->variables, i);
        cJSON* id_item = cJSON_GetObjectItem(var, "component_id");
        if (id_item && id_item->valueint == component_id) {
            cJSON* name = cJSON_GetObjectItem(var, "name");
            if (name && name->valuestring) {
                return name->valuestring;
            }
        }
    }
    return NULL;
}

// get_component_macro moved to ir_c_types.c

// ============================================================================
// Header Generation
// ============================================================================

static void generate_includes(CCodegenContext* ctx) {
    fprintf(ctx->output, "/**\n");
    fprintf(ctx->output, " * Auto-generated C code from .kir file\n");
    fprintf(ctx->output, " * Generated by Kryon C Code Generator\n");
    fprintf(ctx->output, " */\n\n");

    // Check if we need reactive includes
    bool needs_reactive = ctx->has_reactive_state;

    // Generate includes from metadata
    if (ctx->includes && cJSON_IsArray(ctx->includes)) {
        int count = cJSON_GetArraySize(ctx->includes);
        for (int i = 0; i < count; i++) {
            cJSON* inc = cJSON_GetArrayItem(ctx->includes, i);
            cJSON* include_str = cJSON_GetObjectItem(inc, "include");
            if (include_str && include_str->valuestring) {
                fprintf(ctx->output, "#include %s\n", include_str->valuestring);
            }
        }
    } else {
        // Default includes if no metadata
        fprintf(ctx->output, "#include <kryon.h>\n");
        fprintf(ctx->output, "#include <kryon_dsl.h>\n");
        if (needs_reactive) {
            fprintf(ctx->output, "#include <kryon_reactive.h>\n");
            fprintf(ctx->output, "#include <kryon_reactive_ui.h>\n");
        }
        fprintf(ctx->output, "#include <stdio.h>\n");
        fprintf(ctx->output, "#include <stdbool.h>\n");
    }

    // ALWAYS add reactive headers if needed (even if metadata has includes)
    if (needs_reactive && ctx->includes && cJSON_IsArray(ctx->includes)) {
        bool has_reactive_headers = false;
        int count = cJSON_GetArraySize(ctx->includes);
        for (int i = 0; i < count; i++) {
            cJSON* inc = cJSON_GetArrayItem(ctx->includes, i);
            cJSON* include_str = cJSON_GetObjectItem(inc, "include");
            if (include_str && include_str->valuestring) {
                if (strstr(include_str->valuestring, "kryon_reactive") != NULL) {
                    has_reactive_headers = true;
                    break;
                }
            }
        }
        if (!has_reactive_headers) {
            fprintf(ctx->output, "#include <kryon_reactive.h>\n");
            fprintf(ctx->output, "#include <kryon_reactive_ui.h>\n");
        }
    }
    fprintf(ctx->output, "\n");
}

static void generate_preprocessor_directives(CCodegenContext* ctx) {
    if (!ctx->preprocessor_dirs || !cJSON_IsArray(ctx->preprocessor_dirs)) {
        return;
    }

    int count = cJSON_GetArraySize(ctx->preprocessor_dirs);
    if (count == 0) return;

    for (int i = 0; i < count; i++) {
        cJSON* dir = cJSON_GetArrayItem(ctx->preprocessor_dirs, i);
        cJSON* type = cJSON_GetObjectItem(dir, "directive_type");
        cJSON* condition = cJSON_GetObjectItem(dir, "condition");
        cJSON* value = cJSON_GetObjectItem(dir, "value");

        if (!type || !type->valuestring) continue;

        if (strcmp(type->valuestring, "define") == 0) {
            fprintf(ctx->output, "#define ");
            if (condition && condition->valuestring) {
                fprintf(ctx->output, "%s ", condition->valuestring);
            }
            if (value && value->valuestring) {
                fprintf(ctx->output, "%s", value->valuestring);
            }
            fprintf(ctx->output, "\n");
        } else if (strcmp(type->valuestring, "ifdef") == 0 && condition && condition->valuestring) {
            fprintf(ctx->output, "#ifdef %s\n", condition->valuestring);
        } else if (strcmp(type->valuestring, "ifndef") == 0 && condition && condition->valuestring) {
            fprintf(ctx->output, "#ifndef %s\n", condition->valuestring);
        } else if (strcmp(type->valuestring, "if") == 0 && condition && condition->valuestring) {
            fprintf(ctx->output, "#if %s\n", condition->valuestring);
        } else if (strcmp(type->valuestring, "elif") == 0 && condition && condition->valuestring) {
            fprintf(ctx->output, "#elif %s\n", condition->valuestring);
        } else if (strcmp(type->valuestring, "else") == 0) {
            fprintf(ctx->output, "#else\n");
        } else if (strcmp(type->valuestring, "endif") == 0) {
            fprintf(ctx->output, "#endif\n");
        }
    }
    fprintf(ctx->output, "\n");
}

// Note: Expression/statement conversion functions (expr_to_c, stmt_to_c, is_range_call)
// are now in ir_c_expression.c and accessed via macros defined above.

// is_range_call removed - now in ir_c_expression.c

/**
 * Generate exported functions from logic_block
 * Returns false on hard error (unsupported constructs)
 */
static bool generate_exported_functions(FILE* output, cJSON* logic_block, cJSON* exports, const char* output_path) {
    if (!logic_block || !exports) return true;

    cJSON* functions = cJSON_GetObjectItem(logic_block, "functions");
    if (!functions || !cJSON_IsArray(functions)) return true;

    fprintf(output, "// Exported functions\n");

    // For each export, find and generate the function
    cJSON* export_item;
    cJSON_ArrayForEach(export_item, exports) {
        cJSON* name = cJSON_GetObjectItem(export_item, "name");
        cJSON* type = cJSON_GetObjectItem(export_item, "type");

        if (!name || !cJSON_IsString(name)) continue;
        const char* export_name = name->valuestring;
        const char* export_type = type && cJSON_IsString(type) ? type->valuestring : "";

        // Skip non-function exports
        if (strcmp(export_type, "function") != 0) continue;

        // Find function in logic_block.functions
        cJSON* func;
        bool found = false;
        cJSON_ArrayForEach(func, functions) {
            cJSON* func_name = cJSON_GetObjectItem(func, "name");
            if (!func_name || !cJSON_IsString(func_name)) continue;
            if (strcmp(func_name->valuestring, export_name) != 0) continue;

            found = true;

            // Check for universal statements
            cJSON* universal = cJSON_GetObjectItem(func, "universal");
            if (!universal) {
                fprintf(stderr, "[C Codegen] Error: Exported function '%s' has no universal implementation.\n",
                        export_name);
                fprintf(stderr, "            File: %s\n", output_path ? output_path : "unknown");
                return false;
            }

            cJSON* statements = cJSON_GetObjectItem(universal, "statements");
            if (!statements || !cJSON_IsArray(statements)) {
                // Empty function body - might be just a declaration
                statements = NULL;
            }

            // Get return type and parameters
            cJSON* return_type = cJSON_GetObjectItem(func, "return_type");
            cJSON* params = cJSON_GetObjectItem(func, "params");

            const char* ret_type_str = return_type && cJSON_IsString(return_type) ?
                                       return_type->valuestring : "void";
            const char* c_ret_type = kir_type_to_c(ret_type_str);

            // Generate function signature
            fprintf(output, "\n%s %s(", c_ret_type, export_name);

            // Generate parameters
            if (params && cJSON_IsArray(params) && cJSON_GetArraySize(params) > 0) {
                int param_count = cJSON_GetArraySize(params);
                for (int i = 0; i < param_count; i++) {
                    cJSON* param = cJSON_GetArrayItem(params, i);
                    cJSON* param_name = cJSON_GetObjectItem(param, "name");
                    cJSON* param_type = cJSON_GetObjectItem(param, "type");

                    const char* p_name = param_name && cJSON_IsString(param_name) ?
                                         param_name->valuestring : "arg";
                    const char* p_type = param_type && cJSON_IsString(param_type) ?
                                         param_type->valuestring : "any";

                    if (i > 0) fprintf(output, ", ");
                    fprintf(output, "%s %s", kir_type_to_c(p_type), p_name);
                }
            } else {
                fprintf(output, "void");
            }
            fprintf(output, ") {\n");

            // Generate statements
            if (statements) {
                cJSON* stmt;
                cJSON_ArrayForEach(stmt, statements) {
                    if (!stmt_to_c(output, stmt, 4, output_path)) {
                        return false;  // Hard error
                    }
                }
            }

            fprintf(output, "}\n");
            break;
        }

        if (!found) {
            fprintf(stderr, "[C Codegen] Warning: Exported function '%s' not found in logic_block.\n",
                    export_name);
        }
    }

    return true;
}

// ============================================================================
// Variable & Function Generation
// ============================================================================

static void generate_variable_declarations(CCodegenContext* ctx) {
    if (!ctx->variables || !cJSON_IsArray(ctx->variables)) {
        return;
    }

    int count = cJSON_GetArraySize(ctx->variables);
    if (count == 0) return;

    fprintf(ctx->output, "// Component variables\n");
    for (int i = 0; i < count; i++) {
        cJSON* var = cJSON_GetArrayItem(ctx->variables, i);
        cJSON* storage = cJSON_GetObjectItem(var, "storage");
        cJSON* type = cJSON_GetObjectItem(var, "type");
        cJSON* name = cJSON_GetObjectItem(var, "name");
        cJSON* initial = cJSON_GetObjectItem(var, "initial_value");

        if (!name || !name->valuestring || !type || !type->valuestring) continue;

        if (storage && storage->valuestring) {
            fprintf(ctx->output, "%s ", storage->valuestring);
        }
        fprintf(ctx->output, "%s %s", type->valuestring, name->valuestring);

        if (initial && initial->valuestring) {
            fprintf(ctx->output, " = %s", initial->valuestring);
        }
        fprintf(ctx->output, ";\n");
    }
    fprintf(ctx->output, "\n");
}

static void generate_helper_functions(CCodegenContext* ctx) {
    if (!ctx->helper_functions || !cJSON_IsArray(ctx->helper_functions)) {
        return;
    }

    int count = cJSON_GetArraySize(ctx->helper_functions);
    if (count == 0) return;

    fprintf(ctx->output, "// Helper functions\n");
    for (int i = 0; i < count; i++) {
        cJSON* func = cJSON_GetArrayItem(ctx->helper_functions, i);
        cJSON* return_type = cJSON_GetObjectItem(func, "return_type");
        cJSON* name = cJSON_GetObjectItem(func, "name");
        cJSON* params = cJSON_GetObjectItem(func, "parameters");
        cJSON* body = cJSON_GetObjectItem(func, "body");

        if (!name || !name->valuestring || !return_type || !return_type->valuestring) continue;

        fprintf(ctx->output, "%s %s(%s) {\n",
                return_type->valuestring,
                name->valuestring,
                (params && params->valuestring) ? params->valuestring : "void");

        if (body && body->valuestring) {
            fprintf(ctx->output, "%s\n", body->valuestring);
        }

        fprintf(ctx->output, "}\n\n");
    }
}

static void generate_event_handlers(CCodegenContext* ctx) {
    if (!ctx->event_handlers || !cJSON_IsArray(ctx->event_handlers)) {
        return;
    }

    int count = cJSON_GetArraySize(ctx->event_handlers);
    if (count == 0) return;

    fprintf(ctx->output, "// Event handlers\n");
    for (int i = 0; i < count; i++) {
        cJSON* handler = cJSON_GetArrayItem(ctx->event_handlers, i);
        cJSON* return_type = cJSON_GetObjectItem(handler, "return_type");
        cJSON* name = cJSON_GetObjectItem(handler, "function_name");
        cJSON* params = cJSON_GetObjectItem(handler, "parameters");
        cJSON* body = cJSON_GetObjectItem(handler, "body");

        if (!name || !name->valuestring || !return_type || !return_type->valuestring) continue;

        fprintf(ctx->output, "%s %s(%s) {\n",
                return_type->valuestring,
                name->valuestring,
                (params && params->valuestring) ? params->valuestring : "void");

        if (body && body->valuestring) {
            fprintf(ctx->output, "%s\n", body->valuestring);
        }

        fprintf(ctx->output, "}\n\n");
    }
}

// ============================================================================
// KRY Event Handler Transpilation
// ============================================================================

/**
 * Transpile a KRY expression to C code
 * Handles simple increment/decrement expressions like:
 *   - value += 1  →  kryon_signal_set(value_signal, kryon_signal_get(value_signal) + 1)
 *   - value -= 1  →  kryon_signal_set(value_signal, kryon_signal_get(value_signal) - 1)
 */
static void transpile_kry_expression_to_c(CCodegenContext* ctx, const char* scoped_var_name, const char* op, int delta) {
    if (!scoped_var_name || !op) return;

    fprintf(ctx->output, "    int current_%s = kryon_signal_get(%s_signal);\n", scoped_var_name, scoped_var_name);

    if (strcmp(op, "+=") == 0) {
        fprintf(ctx->output, "    kryon_signal_set(%s_signal, current_%s + %d);\n", scoped_var_name, scoped_var_name, delta);
    } else if (strcmp(op, "-=") == 0) {
        fprintf(ctx->output, "    kryon_signal_set(%s_signal, current_%s - %d);\n", scoped_var_name, scoped_var_name, delta);
    } else if (strcmp(op, "=") == 0) {
        fprintf(ctx->output, "    kryon_signal_set(%s_signal, %d);\n", scoped_var_name, delta);
    }
}

/**
 * Generate C event handler functions from KRY logic_block.functions
 *
 * KIR input (C source from @c blocks):
 *   {
 *     "name": "handleButtonClick",
 *     "sources": [{"language": "c", "source": "void handleButtonClick(void) {\n  printf(...);\n}"}]
 *   }
 *
 * KIR input (KRY lambda):
 *   {
 *     "name": "handler_1_click",
 *     "sources": [{"language": "kry", "source": "() => { value -= 1 }"}]
 *   }
 *
 * C output (from C source): direct code output
 * C output (from KRY lambda): transpiled C code
 */
static void generate_kry_event_handlers(CCodegenContext* ctx, cJSON* logic_block) {
    if (!logic_block) return;

    cJSON* functions = cJSON_GetObjectItem(logic_block, "functions");
    if (!functions || !cJSON_IsArray(functions)) return;

    int func_count = cJSON_GetArraySize(functions);
    if (func_count == 0) return;

    fprintf(ctx->output, "// Event handlers (transpiled from logic_block)\n");

    cJSON* func;
    cJSON_ArrayForEach(func, functions) {
        cJSON* name = cJSON_GetObjectItem(func, "name");
        cJSON* sources = cJSON_GetObjectItem(func, "sources");
        if (!name || !name->valuestring || !sources || !cJSON_IsArray(sources)) continue;

        // Skip auto-generated top-level code block functions (they contain the @c/@lua/@js blocks)
        // The actual handlers will be extracted from the sources
        if (strncmp(name->valuestring, "_top_level_code_block_", 21) == 0) {
            // Extract the function definitions from these blocks
            for (int i = 0; i < cJSON_GetArraySize(sources); i++) {
                cJSON* src = cJSON_GetArrayItem(sources, i);
                cJSON* lang = cJSON_GetObjectItem(src, "language");
                cJSON* src_item = cJSON_GetObjectItem(src, "source");

                if (lang && lang->valuestring && src_item && src_item->valuestring) {
                    if (strcmp(lang->valuestring, "c") == 0) {
                        // Output C source code directly
                        fprintf(ctx->output, "%s\n", src_item->valuestring);
                    }
                }
            }
            continue;
        }

        // Find C source first (priority over KRY source)
        const char* c_source = NULL;
        const char* kry_source = NULL;

        for (int i = 0; i < cJSON_GetArraySize(sources); i++) {
            cJSON* src = cJSON_GetArrayItem(sources, i);
            cJSON* lang = cJSON_GetObjectItem(src, "language");
            if (!lang || !lang->valuestring) continue;

            cJSON* src_item = cJSON_GetObjectItem(src, "source");
            if (!src_item || !src_item->valuestring) continue;

            if (strcmp(lang->valuestring, "c") == 0) {
                c_source = src_item->valuestring;
                break;  // Found C source, use it
            } else if (strcmp(lang->valuestring, "kry") == 0) {
                kry_source = src_item->valuestring;
            }
        }

        // Output C source directly if found
        if (c_source) {
            fprintf(ctx->output, "%s\n", c_source);
            continue;
        }

        // Fall back to KRY source transpilation
        if (!kry_source) continue;

        // Parse KRY expression to extract variable name, operator, and delta
        char var_name[128] = {0};
        char op[4] = {0};
        int delta = 0;
        bool parsed = false;

        if (sscanf(kry_source, "() => { %127s %3s %d }", var_name, op, &delta) == 3) {
            parsed = true;
        } else if (sscanf(kry_source, "()=>{%127s %3s %d}", var_name, op, &delta) == 3) {
            parsed = true;
        } else {
            // Fallback: try to match += 1 or -= 1 patterns
            if (strstr(kry_source, "+= 1")) {
                const char* start = strchr(kry_source, '{');
                if (start) {
                    start++;
                    while (*start == ' ') start++;
                    const char* end = strstr(start, "+= 1");
                    if (end) {
                        size_t len = end - start;
                        if (len < sizeof(var_name) - 1) {
                            strncpy(var_name, start, len);
                            var_name[len] = '\0';
                            strcpy(op, "+=");
                            delta = 1;
                            parsed = true;
                        }
                    }
                }
            } else if (strstr(kry_source, "-= 1")) {
                const char* start = strchr(kry_source, '{');
                if (start) {
                    start++;
                    while (*start == ' ') start++;
                    const char* end = strstr(start, "-= 1");
                    if (end) {
                        size_t len = end - start;
                        if (len < sizeof(var_name) - 1) {
                            strncpy(var_name, start, len);
                            var_name[len] = '\0';
                            strcpy(op, "-=");
                            delta = 1;
                            parsed = true;
                        }
                    }
                }
            }
        }

        if (!parsed) {
            fprintf(ctx->output, "    // TODO: Transpile expression: %s\n", kry_source);
            continue;
        }

        // Find all scopes for this variable and generate a scoped handler for each
        // For each variable, check if there are multiple scopes
        cJSON* scopes_for_var[16];  // Max 16 scopes per variable (should be enough)
        int scope_count = 0;
        const char* base_var_name = var_name;

        // Collect all scopes for this variable
        if (ctx->reactive_vars && cJSON_IsArray(ctx->reactive_vars)) {
            int var_count = cJSON_GetArraySize(ctx->reactive_vars);
            for (int i = 0; i < var_count && scope_count < 16; i++) {
                cJSON* var = cJSON_GetArrayItem(ctx->reactive_vars, i);
                cJSON* vname = cJSON_GetObjectItem(var, "name");
                cJSON* scope = cJSON_GetObjectItem(var, "scope");

                if (vname && vname->valuestring &&
                    strcmp(vname->valuestring, base_var_name) == 0 &&
                    scope && scope->valuestring) {
                    scopes_for_var[scope_count++] = scope;
                }
            }
        }

        // Generate a handler function for each scope
        for (int s = 0; s < scope_count; s++) {
            cJSON* scope_item = scopes_for_var[s];
            const char* scope_str = scope_item->valuestring;

            // Skip component scope (will use the base handler name)
            if (strcmp(scope_str, "component") == 0) {
                // Generate base handler (for component definition)
                fprintf(ctx->output, "void %s(void) {\n", name->valuestring);
                transpile_kry_expression_to_c(ctx, base_var_name, op, delta);
                fprintf(ctx->output, "}\n\n");
            } else {
                // Generate scoped handler (e.g., "handler_1_click_Counter_0")
                char* scoped_handler_name = generate_scoped_var_name(name->valuestring, scope_str);
                char* scoped_var_name = generate_scoped_var_name(base_var_name, scope_str);

                fprintf(ctx->output, "void %s(void) {\n", scoped_handler_name);
                transpile_kry_expression_to_c(ctx, scoped_var_name, op, delta);
                fprintf(ctx->output, "}\n\n");

                free(scoped_handler_name);
                free(scoped_var_name);
            }
        }
    }
}

// ============================================================================
// Reactive Signal Generation (moved to ir_c_reactive.c)
// ============================================================================
// Functions: is_reactive_variable, get_scoped_var_name, generate_scoped_var_name,
// get_signal_creator, generate_reactive_signal_declarations,
// generate_reactive_signal_initialization, generate_reactive_signal_cleanup

// ============================================================================
// Component Tree Generation
// ============================================================================

static bool generate_property_macro(CCodegenContext* ctx, const char* key, cJSON* value, bool* first_prop);

static void generate_component_recursive(CCodegenContext* ctx, cJSON* component, bool is_root) {
    cJSON* type_obj = cJSON_GetObjectItem(component, "type");
    cJSON* id_obj = cJSON_GetObjectItem(component, "id");
    cJSON* children_obj = cJSON_GetObjectItem(component, "children");
    cJSON* text_obj = cJSON_GetObjectItem(component, "text");
    cJSON* scope_obj = cJSON_GetObjectItem(component, "scope");

    if (!type_obj || !type_obj->valuestring) return;

    const char* type = type_obj->valuestring;

    // Save and set current scope for scoped components
    const char* prev_scope = ctx->current_scope;
    if (scope_obj && scope_obj->valuestring) {
        ctx->current_scope = scope_obj->valuestring;
    }

    // Special handling for For loops - emit FOR_EACH macro
    if (strcmp(type, "For") == 0) {
        cJSON* for_def = cJSON_GetObjectItem(component, "for_def");
        if (for_def) {
            cJSON* item_name = cJSON_GetObjectItem(for_def, "item_name");
            cJSON* source = cJSON_GetObjectItem(for_def, "source");
            cJSON* source_expr = source ? cJSON_GetObjectItem(source, "expression") : NULL;

            const char* item_var = item_name ? item_name->valuestring : "item";
            const char* source_var = source_expr ? source_expr->valuestring : "items";

            // Generate FOR_EACH macro call
            write_indent(ctx);
            fprintf(ctx->output, "FOR_EACH(%s, %s, %s_count,\n",
                    item_var, source_var, source_var);

            ctx->indent_level++;

            // Generate template children as the body
            if (children_obj && cJSON_IsArray(children_obj)) {
                int child_count = cJSON_GetArraySize(children_obj);
                for (int i = 0; i < child_count; i++) {
                    cJSON* child = cJSON_GetArrayItem(children_obj, i);
                    generate_component_recursive(ctx, child, false);
                    if (i < child_count - 1) {
                        fprintf(ctx->output, ",\n");
                    }
                }
            }

            ctx->indent_level--;
            fprintf(ctx->output, "\n");
            write_indent(ctx);
            fprintf(ctx->output, ")");
            return;
        }
    }

    // Special handling for Custom components (component references)
    cJSON* component_ref = cJSON_GetObjectItem(component, "component_ref");
    if (component_ref && component_ref->valuestring) {
        write_indent(ctx);
        cJSON* arg_obj = cJSON_GetObjectItem(component, "arg");
        if (arg_obj && arg_obj->valuestring) {
            fprintf(ctx->output, "%s(%s)", component_ref->valuestring, arg_obj->valuestring);
        } else {
            fprintf(ctx->output, "%s()", component_ref->valuestring);
        }
        return;
    }

    // Check if this is a custom component (type is PascalCase and not a builtin)
    // Custom components have their type set to the component name (e.g., "HabitPanel")
    const char* macro_check = get_component_macro(type);
    bool is_custom_component = (strcmp(macro_check, "CONTAINER") == 0 &&
                                type[0] >= 'A' && type[0] <= 'Z' &&
                                strcmp(type, "Container") != 0);
    if (is_custom_component) {
        write_indent(ctx);
        cJSON* arg_obj = cJSON_GetObjectItem(component, "arg");
        if (arg_obj && arg_obj->valuestring) {
            fprintf(ctx->output, "%s(%s)", type, arg_obj->valuestring);
        } else {
            fprintf(ctx->output, "%s()", type);
        }
        return;
    }

    const char* macro = get_component_macro(type);

    // Check if this component has a variable assignment
    const char* var_name = NULL;
    if (id_obj) {
        var_name = get_variable_for_component_id(ctx, id_obj->valueint);
    }

    // Write indentation
    write_indent(ctx);

    // Variable assignment if needed
    if (var_name && !is_root) {
        fprintf(ctx->output, "%s = ", var_name);
    }

    // Component macro
    fprintf(ctx->output, "%s(", macro);

    // Note: BIND_TEXT for reactive text should be handled specially
    // It should be output immediately after the TEXT component, not as a separate child

    // Output text parameter
    cJSON* text_expr_obj = cJSON_GetObjectItem(component, "text_expression");

    // Check for reactive text binding via property_bindings
    cJSON* property_bindings = cJSON_GetObjectItem(component, "property_bindings");
    bool has_property_binding_bind_text = false;

    if (property_bindings) {
        cJSON* text_binding = cJSON_GetObjectItem(property_bindings, "text");
        if (text_binding) {
            cJSON* binding_type = cJSON_GetObjectItem(text_binding, "binding_type");
            if (binding_type && binding_type->valuestring &&
                strcmp(binding_type->valuestring, "static_template") == 0) {
                has_property_binding_bind_text = true;
            }
        }
    }

    // Fallback: check if text_expression references a reactive variable
    // (property_bindings may not be present in expanded component instances)
    bool has_fallback_bind_text = !has_property_binding_bind_text &&
                                     text_expr_obj && text_expr_obj->valuestring &&
                                     is_reactive_variable(ctx, text_expr_obj->valuestring);

    // Output text parameter
    bool has_text = (text_obj && text_obj->valuestring) || (text_expr_obj && text_expr_obj->valuestring);

    if (has_property_binding_bind_text || has_fallback_bind_text) {
        // Reactive binding - use empty string, actual value comes from signal
        fprintf(ctx->output, "\"\"");
    } else if (text_obj && text_obj->valuestring) {
        fprintf(ctx->output, "\"%s\"", text_obj->valuestring);
    } else if (text_expr_obj && text_expr_obj->valuestring) {
        fprintf(ctx->output, "\"\"");
    }

    // Special handling for Checkbox: output 'checked' parameter after label
    if (strcmp(type, "Checkbox") == 0) {
        cJSON* checked_obj = cJSON_GetObjectItem(component, "checked");
        bool checked_val = checked_obj && cJSON_IsTrue(checked_obj);
        fprintf(ctx->output, ", %s", checked_val ? "true" : "false");
    }

    // Special handling for Dropdown/Input: output 'placeholder' parameter
    if (strcmp(type, "Dropdown") == 0 || strcmp(type, "Input") == 0) {
        // For Dropdown/Input with no text, output placeholder as the first argument
        if (!has_text) {
            cJSON* placeholder_obj = cJSON_GetObjectItem(component, "placeholder");
            const char* placeholder_val = placeholder_obj && placeholder_obj->valuestring ?
                                          placeholder_obj->valuestring : "";
            fprintf(ctx->output, "\"%s\"", placeholder_val);
        }
    }

    // Check for FULL_SIZE pattern (width=100.0px AND height=100.0px)
    cJSON* width_prop = cJSON_GetObjectItem(component, "width");
    cJSON* height_prop = cJSON_GetObjectItem(component, "height");
    bool is_full_size = (width_prop && width_prop->valuestring &&
                         height_prop && height_prop->valuestring &&
                         (strcmp(width_prop->valuestring, "100.0px") == 0 ||
                          strcmp(width_prop->valuestring, "100.0%") == 0) &&
                         (strcmp(height_prop->valuestring, "100.0px") == 0 ||
                          strcmp(height_prop->valuestring, "100.0%") == 0));

    // Check if we have properties or children
    bool has_properties = false;
    cJSON* prop = NULL;
    cJSON_ArrayForEach(prop, component) {
        const char* key = prop->string;
        if (!key) continue;
        if (strcmp(key, "id") != 0 && strcmp(key, "type") != 0 &&
            strcmp(key, "text") != 0 && strcmp(key, "children") != 0 &&
            strcmp(key, "TEST_MARKER") != 0 && strcmp(key, "direction") != 0 &&
            strcmp(key, "background") != 0 && strcmp(key, "color") != 0 &&
            strcmp(key, "placeholder") != 0 &&  // Skip placeholder for Dropdown/Input
            strcmp(key, "checked") != 0) {     // Skip checked for Checkbox
            has_properties = true;
            break;
        }
        // Check if background/color are non-default
        if (strcmp(key, "background") == 0 && prop->valuestring && strcmp(prop->valuestring, "#00000000") != 0) {
            has_properties = true;
            break;
        }
        if (strcmp(key, "color") == 0 && prop->valuestring && strcmp(prop->valuestring, "#00000000") != 0) {
            has_properties = true;
            break;
        }
    }

    bool has_children = (children_obj && cJSON_GetArraySize(children_obj) > 0);

    // Check if this component has a placeholder argument (Dropdown/Input)
    // For Dropdown/Input, we always output a placeholder (even if empty), so check based on type and !has_text
    bool has_placeholder = (strcmp(type, "Dropdown") == 0 || strcmp(type, "Input") == 0) &&
                          !has_text;

    // Add comma after text/placeholder if there are properties or children
    if ((has_text || has_placeholder) && (has_properties || has_children)) {
        fprintf(ctx->output, ",\n");
    } else if (!has_text && !has_placeholder) {
        fprintf(ctx->output, "\n");
    } else if (!has_properties && !has_children) {
        fprintf(ctx->output, "\n");
    }

    ctx->indent_level++;

    // Generate FULL_SIZE if applicable
    bool first_prop = true;
    if (is_full_size) {
        if (!first_prop) {
            fprintf(ctx->output, ",\n");
        }
        write_indent(ctx);
        fprintf(ctx->output, "FULL_SIZE");
        first_prop = false;
    }

    // Special handling for dropdown_state (Dropdown components)
    cJSON* dropdown_state = cJSON_GetObjectItem(component, "dropdown_state");
    if (dropdown_state && cJSON_IsObject(dropdown_state) && strcmp(type, "Dropdown") == 0) {
        // Handle options array
        cJSON* options_array = cJSON_GetObjectItem(dropdown_state, "options");
        if (options_array && cJSON_IsArray(options_array)) {
            int count = cJSON_GetArraySize(options_array);
            if (count > 0) {
                if (!first_prop) fprintf(ctx->output, ",\n");
                write_indent(ctx);

                // Generate OPTIONS macro call with array elements
                fprintf(ctx->output, "OPTIONS(%d", count);
                for (int i = 0; i < count; i++) {
                    cJSON* item = cJSON_GetArrayItem(options_array, i);
                    if (item && cJSON_IsString(item)) {
                        fprintf(ctx->output, ", \"%s\"", item->valuestring);
                    }
                }
                fprintf(ctx->output, ")");
                first_prop = false;
            }
        }

        // Handle selectedIndex
        cJSON* selected_index = cJSON_GetObjectItem(dropdown_state, "selectedIndex");
        if (selected_index && cJSON_IsNumber(selected_index)) {
            if (!first_prop) fprintf(ctx->output, ",\n");
            write_indent(ctx);
            fprintf(ctx->output, "SELECTED_INDEX(%d)", selected_index->valueint);
            first_prop = false;
        }
    }

    // Special handling for TEXT components with reactive text_expression
    // Generate BIND_TEXT_EXPR as a property for fallback case (no property_bindings)
    if (strcmp(type, "Text") == 0) {
        cJSON* text_expr_obj = cJSON_GetObjectItem(component, "text_expression");
        if (text_expr_obj && text_expr_obj->valuestring && is_reactive_variable(ctx, text_expr_obj->valuestring)) {
            // Check that there's no property_bindings (which would be handled elsewhere)
            cJSON* property_bindings = cJSON_GetObjectItem(component, "property_bindings");
            bool has_property_binding = false;
            if (property_bindings) {
                cJSON* text_binding = cJSON_GetObjectItem(property_bindings, "text");
                if (text_binding) {
                    cJSON* binding_type = cJSON_GetObjectItem(text_binding, "binding_type");
                    if (binding_type && binding_type->valuestring &&
                        strcmp(binding_type->valuestring, "static_template") == 0) {
                        has_property_binding = true;
                    }
                }
            }

            // Only generate BIND_TEXT_EXPR for fallback case (no property_bindings)
            if (!has_property_binding) {
                if (!first_prop) fprintf(ctx->output, ",\n");
                write_indent(ctx);
                char* scoped_name = get_scoped_var_name(ctx, text_expr_obj->valuestring);
                char signal_name[256];
                snprintf(signal_name, sizeof(signal_name), "%s_signal", scoped_name);
                fprintf(ctx->output, "BIND_TEXT_EXPR(%s)", signal_name);
                free(scoped_name);
                first_prop = false;
            }
        }
    }

    // Generate properties
    cJSON* prop2 = NULL;
    cJSON_ArrayForEach(prop2, component) {
        const char* key = prop2->string;
        if (!key) continue;

        // Skip internal fields
        if (strcmp(key, "id") == 0 || strcmp(key, "type") == 0 ||
            strcmp(key, "text") == 0 || strcmp(key, "children") == 0 ||
            strcmp(key, "TEST_MARKER") == 0 || strcmp(key, "direction") == 0 ||
            strcmp(key, "placeholder") == 0 ||  // Skip placeholder for Dropdown/Input (handled as argument)
            strcmp(key, "checked") == 0 ||      // Skip checked for Checkbox (handled as argument)
            strcmp(key, "dropdown_state") == 0) { // Skip dropdown_state (handled separately below)
            continue;
        }

        // Skip width/height if we already generated FULL_SIZE
        if (is_full_size && (strcmp(key, "width") == 0 || strcmp(key, "height") == 0)) {
            continue;
        }

        // Skip transparent/default colors
        if ((strcmp(key, "background") == 0 || strcmp(key, "color") == 0) &&
            prop2->valuestring && strcmp(prop2->valuestring, "#00000000") == 0) {
            continue;
        }

        // Skip events property if there are no event handlers in metadata OR logic_block
        // KRY handlers are in logic_block.functions, C handlers are in c_metadata.event_handlers
        if (strcmp(key, "events") == 0) {
            bool has_kry_handlers = false;
            // Check if we have logic_block with functions (KRY handlers)
            cJSON* logic_block = cJSON_GetObjectItem(ctx->root_json, "logic_block");
            if (logic_block) {
                cJSON* functions = cJSON_GetObjectItem(logic_block, "functions");
                if (functions && cJSON_IsArray(functions) && cJSON_GetArraySize(functions) > 0) {
                    has_kry_handlers = true;
                }
            }
            bool has_c_handlers = (ctx->event_handlers && cJSON_GetArraySize(ctx->event_handlers) > 0);
            if (!has_kry_handlers && !has_c_handlers) {
                continue;
            }
        }

        // Generate the property (comma handling is internal now)
        generate_property_macro(ctx, key, prop2, &first_prop);
    }

    // Generate children
    if (children_obj && cJSON_IsArray(children_obj)) {
        int child_count = cJSON_GetArraySize(children_obj);
        if (child_count > 0) {
            // Print comma before children if we had properties
            if (!first_prop) {
                fprintf(ctx->output, ",\n");
                fprintf(ctx->output, "\n");  // Blank line for readability
            }

            for (int i = 0; i < child_count; i++) {
                cJSON* child = cJSON_GetArrayItem(children_obj, i);
                generate_component_recursive(ctx, child, false);
                if (i < child_count - 1) {
                    fprintf(ctx->output, ",\n");
                } else {
                    fprintf(ctx->output, "\n");
                }
            }
        }
    }

    ctx->indent_level--;
    write_indent(ctx);
    fprintf(ctx->output, ")");

    // Restore previous scope
    ctx->current_scope = prev_scope;
}

static bool generate_property_macro(CCodegenContext* ctx, const char* key, cJSON* value, bool* first_prop) {
    // NOTE: Each case that generates output must:
    // 1. Print comma if not first_prop
    // 2. Set *first_prop = false after printing

    // Width/Height
    if (strcmp(key, "width") == 0 && value->valuestring) {
        if (!*first_prop) fprintf(ctx->output, ",\n");
        write_indent(ctx);
        if (strcmp(value->valuestring, "100.0px") == 0 || strcmp(value->valuestring, "100.0%") == 0) {
            fprintf(ctx->output, "FULL_WIDTH");
        } else {
            // Parse numeric value (e.g., "200.0px" → 200)
            int width_val = 0;
            if (sscanf(value->valuestring, "%d", &width_val) == 1 && width_val > 0) {
                fprintf(ctx->output, "WIDTH(%d)", width_val);
            } else {
                fprintf(ctx->output, "WIDTH(\"%s\")", value->valuestring);
            }
        }
        *first_prop = false;
        return true;
    }
    if (strcmp(key, "height") == 0 && value->valuestring) {
        if (!*first_prop) fprintf(ctx->output, ",\n");
        write_indent(ctx);
        if (strcmp(value->valuestring, "100.0px") == 0 || strcmp(value->valuestring, "100.0%") == 0) {
            fprintf(ctx->output, "FULL_HEIGHT");
        } else {
            // Parse numeric value (e.g., "60.0px" → 60)
            int height_val = 0;
            if (sscanf(value->valuestring, "%d", &height_val) == 1 && height_val > 0) {
                fprintf(ctx->output, "HEIGHT(%d)", height_val);
            } else {
                fprintf(ctx->output, "HEIGHT(\"%s\")", value->valuestring);
            }
        }
        *first_prop = false;
        return true;
    }

    // Min/Max Width
    if (strcmp(key, "minWidth") == 0 && value->valuestring) {
        if (!*first_prop) fprintf(ctx->output, ",\n");
        write_indent(ctx);
        int val = 0;
        if (sscanf(value->valuestring, "%d", &val) == 1 && val > 0) {
            fprintf(ctx->output, "MIN_WIDTH(%d)", val);
        } else {
            fprintf(ctx->output, "MIN_WIDTH(\"%s\")", value->valuestring);
        }
        *first_prop = false;
        return true;
    }
    if (strcmp(key, "maxWidth") == 0 && value->valuestring) {
        if (!*first_prop) fprintf(ctx->output, ",\n");
        write_indent(ctx);
        int val = 0;
        if (sscanf(value->valuestring, "%d", &val) == 1 && val > 0) {
            fprintf(ctx->output, "MAX_WIDTH(%d)", val);
        } else {
            fprintf(ctx->output, "MAX_WIDTH(\"%s\")", value->valuestring);
        }
        *first_prop = false;
        return true;
    }
    // Min/Max Height
    if (strcmp(key, "minHeight") == 0 && value->valuestring) {
        if (!*first_prop) fprintf(ctx->output, ",\n");
        write_indent(ctx);
        int val = 0;
        if (sscanf(value->valuestring, "%d", &val) == 1 && val > 0) {
            fprintf(ctx->output, "MIN_HEIGHT(%d)", val);
        } else {
            fprintf(ctx->output, "MIN_HEIGHT(\"%s\")", value->valuestring);
        }
        *first_prop = false;
        return true;
    }
    if (strcmp(key, "maxHeight") == 0 && value->valuestring) {
        if (!*first_prop) fprintf(ctx->output, ",\n");
        write_indent(ctx);
        int val = 0;
        if (sscanf(value->valuestring, "%d", &val) == 1 && val > 0) {
            fprintf(ctx->output, "MAX_HEIGHT(%d)", val);
        } else {
            fprintf(ctx->output, "MAX_HEIGHT(\"%s\")", value->valuestring);
        }
        *first_prop = false;
        return true;
    }

    // Colors
    if (strcmp(key, "background") == 0 && value->valuestring) {
        if (!*first_prop) fprintf(ctx->output, ",\n");
        write_indent(ctx);
        // Convert color string "#RRGGBB" to hex 0xRRGGBB
        const char* color_str = value->valuestring;
        if (color_str[0] == '#' && strlen(color_str) >= 7) {
            fprintf(ctx->output, "BG_COLOR(0x%s)", color_str + 1);  // Skip '#'
        } else {
            // Fallback for non-hex colors
            fprintf(ctx->output, "BG_COLOR(0x%s)", color_str);
        }
        *first_prop = false;
        return true;
    }
    if (strcmp(key, "color") == 0 && value->valuestring) {
        if (!*first_prop) fprintf(ctx->output, ",\n");
        write_indent(ctx);
        // Check for named colors
        if (strcmp(value->valuestring, "#ffffff") == 0) {
            fprintf(ctx->output, "COLOR_WHITE");
        } else if (strcmp(value->valuestring, "#000000") == 0) {
            fprintf(ctx->output, "COLOR_BLACK");
        } else if (strcmp(value->valuestring, "#ff0000") == 0) {
            fprintf(ctx->output, "COLOR_RED");
        } else if (strcmp(value->valuestring, "#00ff00") == 0) {
            fprintf(ctx->output, "COLOR_GREEN");
        } else if (strcmp(value->valuestring, "#0000ff") == 0) {
            fprintf(ctx->output, "COLOR_BLUE");
        } else if (strcmp(value->valuestring, "#ffff00") == 0) {
            fprintf(ctx->output, "COLOR_YELLOW");
        } else if (strcmp(value->valuestring, "#00ffff") == 0) {
            fprintf(ctx->output, "COLOR_CYAN");
        } else if (strcmp(value->valuestring, "#ff00ff") == 0) {
            fprintf(ctx->output, "COLOR_MAGENTA");
        } else if (strcmp(value->valuestring, "#808080") == 0) {
            fprintf(ctx->output, "COLOR_GRAY");
        } else if (strcmp(value->valuestring, "#ffa500") == 0) {
            fprintf(ctx->output, "COLOR_ORANGE");
        } else if (strcmp(value->valuestring, "#800080") == 0) {
            fprintf(ctx->output, "COLOR_PURPLE");
        } else {
            // Convert color string "#RRGGBB" to hex 0xRRGGBB
            const char* color_str = value->valuestring;
            if (color_str[0] == '#' && strlen(color_str) >= 7) {
                fprintf(ctx->output, "TEXT_COLOR(0x%s)", color_str + 1);  // Skip '#'
            } else {
                fprintf(ctx->output, "TEXT_COLOR(0x%s)", color_str);
            }
        }
        *first_prop = false;
        return true;
    }

    // Padding/Margin
    if (strcmp(key, "padding") == 0) {
        if (!*first_prop) fprintf(ctx->output, ",\n");
        write_indent(ctx);
        if (cJSON_IsNumber(value)) {
            fprintf(ctx->output, "PADDING(%.0f)", value->valuedouble);
        } else if (cJSON_IsArray(value)) {
            int size = cJSON_GetArraySize(value);
            if (size == 4) {
                fprintf(ctx->output, "PADDING_SIDES(%.0f, %.0f, %.0f, %.0f)",
                        cJSON_GetArrayItem(value, 0)->valuedouble,
                        cJSON_GetArrayItem(value, 1)->valuedouble,
                        cJSON_GetArrayItem(value, 2)->valuedouble,
                        cJSON_GetArrayItem(value, 3)->valuedouble);
            }
        }
        *first_prop = false;
        return true;
    }
    if (strcmp(key, "gap") == 0 && cJSON_IsNumber(value)) {
        if (!*first_prop) fprintf(ctx->output, ",\n");
        write_indent(ctx);
        fprintf(ctx->output, "GAP(%.0f)", value->valuedouble);
        *first_prop = false;
        return true;
    }

    // Typography
    if (strcmp(key, "fontSize") == 0 && cJSON_IsNumber(value)) {
        if (!*first_prop) fprintf(ctx->output, ",\n");
        write_indent(ctx);
        fprintf(ctx->output, "FONT_SIZE(%.0f)", value->valuedouble);
        *first_prop = false;
        return true;
    }
    if (strcmp(key, "fontBold") == 0 && cJSON_IsBool(value)) {
        if (cJSON_IsTrue(value)) {
            if (!*first_prop) fprintf(ctx->output, ",\n");
            write_indent(ctx);
            fprintf(ctx->output, "FONT_BOLD");
            *first_prop = false;
            return true;
        }
        return false;  // fontBold=false generates no output, so no comma
    }

    // Layout
    if (strcmp(key, "justifyContent") == 0 && value->valuestring) {
        if (!*first_prop) fprintf(ctx->output, ",\n");
        write_indent(ctx);
        if (strcmp(value->valuestring, "center") == 0) {
            fprintf(ctx->output, "JUSTIFY_CENTER");
        } else if (strcmp(value->valuestring, "flex-start") == 0 || strcmp(value->valuestring, "start") == 0) {
            fprintf(ctx->output, "JUSTIFY_START");
        } else if (strcmp(value->valuestring, "flex-end") == 0 || strcmp(value->valuestring, "end") == 0) {
            fprintf(ctx->output, "JUSTIFY_END");
        } else if (strcmp(value->valuestring, "space-between") == 0) {
            fprintf(ctx->output, "JUSTIFY_SPACE_BETWEEN");
        } else if (strcmp(value->valuestring, "space-around") == 0) {
            fprintf(ctx->output, "JUSTIFY_SPACE_AROUND");
        } else {
            fprintf(ctx->output, "JUSTIFY_CENTER");
        }
        *first_prop = false;
        return true;
    }
    if (strcmp(key, "alignItems") == 0 && value->valuestring) {
        if (!*first_prop) fprintf(ctx->output, ",\n");
        write_indent(ctx);
        if (strcmp(value->valuestring, "center") == 0) {
            fprintf(ctx->output, "ALIGN_CENTER");
        } else if (strcmp(value->valuestring, "flex-start") == 0 || strcmp(value->valuestring, "start") == 0) {
            fprintf(ctx->output, "ALIGN_START");
        } else if (strcmp(value->valuestring, "flex-end") == 0 || strcmp(value->valuestring, "end") == 0) {
            fprintf(ctx->output, "ALIGN_END");
        } else if (strcmp(value->valuestring, "stretch") == 0) {
            fprintf(ctx->output, "ALIGN_STRETCH");
        } else {
            fprintf(ctx->output, "ALIGN_CENTER");
        }
        *first_prop = false;
        return true;
    }
    if (strcmp(key, "flexShrink") == 0 && cJSON_IsNumber(value)) {
        if (!*first_prop) fprintf(ctx->output, ",\n");
        write_indent(ctx);
        fprintf(ctx->output, "FLEX_SHRINK(%.0f)", value->valuedouble);
        *first_prop = false;
        return true;
    }

    // Visibility
    if (strcmp(key, "visible") == 0 && cJSON_IsBool(value)) {
        if (!*first_prop) fprintf(ctx->output, ",\n");
        write_indent(ctx);
        fprintf(ctx->output, "VISIBLE(%s)", cJSON_IsTrue(value) ? "true" : "false");
        *first_prop = false;
        return true;
    }

    // Events
    if (strcmp(key, "events") == 0 && cJSON_IsArray(value)) {
        int event_count = cJSON_GetArraySize(value);
        bool printed = false;
        for (int i = 0; i < event_count; i++) {
            cJSON* event = cJSON_GetArrayItem(value, i);
            cJSON* event_type = cJSON_GetObjectItem(event, "type");
            cJSON* logic_id = cJSON_GetObjectItem(event, "logic_id");

            if (event_type && event_type->valuestring && logic_id && logic_id->valuestring) {
                // For KRY handlers, logic_id is the function name directly (e.g., "handler_1_click")
                // For C metadata handlers, we need to look up the function name
                const char* func_name = logic_id->valuestring;  // Default: use logic_id as function name
                bool is_c_handler = false;  // Track if this is a C metadata handler

                // Try to find function name in c_metadata.event_handlers (legacy C handlers)
                if (ctx->event_handlers) {
                    int handler_count = cJSON_GetArraySize(ctx->event_handlers);
                    for (int j = 0; j < handler_count; j++) {
                        cJSON* handler = cJSON_GetArrayItem(ctx->event_handlers, j);
                        cJSON* h_logic_id = cJSON_GetObjectItem(handler, "logic_id");
                        cJSON* h_func_name = cJSON_GetObjectItem(handler, "function_name");

                        if (h_logic_id && h_logic_id->valuestring &&
                            h_func_name && h_func_name->valuestring &&
                            strcmp(h_logic_id->valuestring, logic_id->valuestring) == 0) {
                            func_name = h_func_name->valuestring;
                            is_c_handler = true;  // This is a C metadata handler
                            break;
                        }
                    }
                }

                // For KRY handlers, scope the function name based on current_scope
                // C handlers are already defined by the user, so don't scope them
                char* scoped_func_name = NULL;
                if (!is_c_handler && ctx->current_scope && strcmp(ctx->current_scope, "component") != 0) {
                    // Generate scoped handler name (e.g., "handler_1_click_Counter_0")
                    scoped_func_name = generate_scoped_var_name(func_name, ctx->current_scope);
                    func_name = scoped_func_name;
                }

                if (strcmp(event_type->valuestring, "click") == 0) {
                    if (!*first_prop) fprintf(ctx->output, ",\n");
                    write_indent(ctx);
                    fprintf(ctx->output, "ON_CLICK(%s)", func_name);
                    *first_prop = false;
                    printed = true;
                }

                if (scoped_func_name) {
                    free(scoped_func_name);
                }
            }
        }
        return printed;
    }

    // Dropdown options array
    if (strcmp(key, "options") == 0 && cJSON_IsArray(value)) {
        if (!*first_prop) fprintf(ctx->output, ",\n");
        write_indent(ctx);

        // Generate OPTIONS macro call with array elements
        int count = cJSON_GetArraySize(value);
        fprintf(ctx->output, "OPTIONS(%d", count);

        // Output each option string
        for (int i = 0; i < count; i++) {
            cJSON* item = cJSON_GetArrayItem(value, i);
            if (item && cJSON_IsString(item)) {
                fprintf(ctx->output, ", \"%s\"", item->valuestring);
            }
        }
        fprintf(ctx->output, ")");

        *first_prop = false;
        return true;
    }

    // Handle reactive property bindings
    if (strcmp(key, "property_bindings") == 0 && cJSON_IsObject(value)) {
        bool printed = false;
        cJSON* binding = NULL;

        cJSON_ArrayForEach(binding, value) {
            const char* prop_name = binding->string;
            if (!prop_name) continue;

            cJSON* source_expr = cJSON_GetObjectItem(binding, "source_expr");
            cJSON* binding_type = cJSON_GetObjectItem(binding, "binding_type");

            if (source_expr && source_expr->valuestring &&
                binding_type && binding_type->valuestring &&
                strcmp(binding_type->valuestring, "static_template") == 0) {

                if (!*first_prop) fprintf(ctx->output, ",\n");
                write_indent(ctx);

                // Get scoped variable name for the current scope
                char* scoped_name = get_scoped_var_name(ctx, source_expr->valuestring);
                char signal_name[256];
                snprintf(signal_name, sizeof(signal_name), "%s_signal", scoped_name);

                // Generate binding macro call
                if (strcmp(prop_name, "text") == 0) {
                    fprintf(ctx->output, "BIND_TEXT(%s)", signal_name);
                } else if (strcmp(prop_name, "visible") == 0) {
                    fprintf(ctx->output, "BIND_VISIBLE(%s)", signal_name);
                } else if (strcmp(prop_name, "background") == 0) {
                    fprintf(ctx->output, "BIND_BACKGROUND(%s)", signal_name);
                } else if (strcmp(prop_name, "color") == 0) {
                    fprintf(ctx->output, "BIND_COLOR(%s)", signal_name);
                } else if (strcmp(prop_name, "selectedIndex") == 0) {
                    fprintf(ctx->output, "SELECTED_INDEX(%s)", source_expr->valuestring);
                } else {
                    fprintf(ctx->output, "BIND(%s, %s)", prop_name, scoped_name);
                }

                free(scoped_name);
                *first_prop = false;
                printed = true;
            }
        }
        return printed;
    }

    // Fallback: skip unknown properties (no comma printed)
    return false;
}

// ============================================================================
// Component Definition Generation (for module files)
// ============================================================================

/**
 * Generate C code for component definitions (non-app modules)
 */
static void generate_component_definitions(CCodegenContext* ctx, cJSON* component_defs) {
    if (!component_defs || !cJSON_IsArray(component_defs)) return;

    cJSON* def;
    cJSON_ArrayForEach(def, component_defs) {
        cJSON* name = cJSON_GetObjectItem(def, "name");
        cJSON* props = cJSON_GetObjectItem(def, "props");
        cJSON* template = cJSON_GetObjectItem(def, "template");

        if (!name || !cJSON_IsString(name)) continue;

        const char* comp_name = cJSON_GetStringValue(name);

        // Generate component function signature
        fprintf(ctx->output, "/**\n");
        fprintf(ctx->output, " * Component: %s\n", comp_name);

        // Document props
        if (props && cJSON_IsArray(props)) {
            cJSON* prop;
            cJSON_ArrayForEach(prop, props) {
                cJSON* prop_name = cJSON_GetObjectItem(prop, "name");
                cJSON* prop_type = cJSON_GetObjectItem(prop, "type");
                if (prop_name && cJSON_IsString(prop_name)) {
                    fprintf(ctx->output, " * @param %s %s\n",
                            cJSON_GetStringValue(prop_name),
                            prop_type && cJSON_IsString(prop_type) ?
                            cJSON_GetStringValue(prop_type) : "any");
                }
            }
        }
        fprintf(ctx->output, " */\n");

        // Generate KRYON_COMPONENT macro call
        fprintf(ctx->output, "KRYON_COMPONENT(%s", comp_name);

        // Add props as macro parameters
        if (props && cJSON_IsArray(props)) {
            cJSON* prop;
            cJSON_ArrayForEach(prop, props) {
                cJSON* prop_name = cJSON_GetObjectItem(prop, "name");
                if (prop_name && cJSON_IsString(prop_name)) {
                    fprintf(ctx->output, ", %s", cJSON_GetStringValue(prop_name));
                }
            }
        }
        fprintf(ctx->output, ",\n");

        // Generate template content
        ctx->indent_level++;
        if (template) {
            generate_component_recursive(ctx, template, true);
        }
        ctx->indent_level--;

        fprintf(ctx->output, "\n);\n\n");
    }
}

/**
 * Generate C struct definitions from source_structures.struct_types
 */
static void generate_struct_definitions(CCodegenContext* ctx, cJSON* struct_types) {
    if (!struct_types || !cJSON_IsArray(struct_types)) return;

    cJSON* struct_def;
    cJSON_ArrayForEach(struct_def, struct_types) {
        cJSON* name = cJSON_GetObjectItem(struct_def, "name");
        cJSON* fields = cJSON_GetObjectItem(struct_def, "fields");

        if (!name || !cJSON_IsString(name)) continue;

        const char* struct_name = cJSON_GetStringValue(name);

        fprintf(ctx->output, "/**\n");
        fprintf(ctx->output, " * Struct: %s\n", struct_name);
        fprintf(ctx->output, " */\n");
        fprintf(ctx->output, "typedef struct {\n");

        if (fields && cJSON_IsArray(fields)) {
            cJSON* field;
            cJSON_ArrayForEach(field, fields) {
                cJSON* field_name = cJSON_GetObjectItem(field, "name");
                cJSON* field_type = cJSON_GetObjectItem(field, "type");

                if (!field_name || !cJSON_IsString(field_name)) continue;

                const char* fname = cJSON_GetStringValue(field_name);
                const char* ftype = field_type && cJSON_IsString(field_type) ?
                                    cJSON_GetStringValue(field_type) : "any";

                // Map KIR types to C types
                const char* c_type = "void*";  // default for 'any'
                if (strcmp(ftype, "string") == 0) {
                    c_type = "char*";
                } else if (strcmp(ftype, "int") == 0 || strcmp(ftype, "number") == 0) {
                    c_type = "int";
                } else if (strcmp(ftype, "float") == 0) {
                    c_type = "float";
                } else if (strcmp(ftype, "bool") == 0) {
                    c_type = "bool";
                }

                fprintf(ctx->output, "    %s %s;\n", c_type, fname);
            }
        }

        fprintf(ctx->output, "} %s;\n\n", struct_name);
    }
}

// ============================================================================
// Main Function Generation
// ============================================================================

static void generate_main_function(CCodegenContext* ctx) {
    fprintf(ctx->output, "int main(void) {\n");
    ctx->indent_level++;

    // Extract window config from KIR app object
    cJSON* app = cJSON_GetObjectItem(ctx->root_json, "app");
    const char* title = "Kryon App";
    int width = 800;
    int height = 600;

    if (app) {
        cJSON* title_item = cJSON_GetObjectItem(app, "windowTitle");
        if (title_item && cJSON_IsString(title_item)) {
            title = title_item->valuestring;
        }
        cJSON* width_item = cJSON_GetObjectItem(app, "windowWidth");
        if (width_item && cJSON_IsNumber(width_item)) {
            width = width_item->valueint;
        }
        cJSON* height_item = cJSON_GetObjectItem(app, "windowHeight");
        if (height_item && cJSON_IsNumber(height_item)) {
            height = height_item->valueint;
        }
    }

    // kryon_init() call with values from KIR file
    fprintf(ctx->output, "    kryon_init(\"%s\", %d, %d);\n", title, width, height);
    fprintf(ctx->output, "\n");

    // Initialize reactive signals
    if (ctx->has_reactive_state) {
        generate_reactive_signal_initialization(ctx);
    }

    // KRYON_APP macro
    writeln(ctx, "KRYON_APP(");
    ctx->indent_level++;

    if (ctx->component_tree) {
        generate_component_recursive(ctx, ctx->component_tree, true);
        fprintf(ctx->output, "\n");
    }

    ctx->indent_level--;
    writeln(ctx, ");");
    fprintf(ctx->output, "\n");

    // KRYON_RUN macro
    writeln(ctx, "KRYON_RUN();");

    // Cleanup reactive signals AFTER KRYON_RUN returns
    if (ctx->has_reactive_state) {
        generate_reactive_signal_cleanup(ctx);
    }

    ctx->indent_level--;
    fprintf(ctx->output, "}\n");
}

// ============================================================================
// Main Code Generation Entry Points
// ============================================================================

bool ir_generate_c_code_from_string(const char* kir_json, const char* output_path) {
    if (!kir_json || !output_path) return false;

    // Parse KIR JSON
    cJSON* root = cJSON_Parse(kir_json);
    if (!root) {
        fprintf(stderr, "Error: Failed to parse KIR JSON\n");
        return false;
    }

    // Open output file
    FILE* output = fopen(output_path, "w");
    if (!output) {
        fprintf(stderr, "Error: Failed to open output file: %s\n", output_path);
        cJSON_Delete(root);
        return false;
    }

    // Setup context
    CCodegenContext ctx = {0};
    ctx.output = output;
    ctx.indent_level = 0;
    ctx.root_json = root;
    ctx.component_tree = cJSON_GetObjectItem(root, "root");
    ctx.c_metadata = cJSON_GetObjectItem(root, "c_metadata");

    if (ctx.c_metadata) {
        ctx.variables = cJSON_GetObjectItem(ctx.c_metadata, "variables");
        ctx.event_handlers = cJSON_GetObjectItem(ctx.c_metadata, "event_handlers");
        ctx.helper_functions = cJSON_GetObjectItem(ctx.c_metadata, "helper_functions");
        ctx.includes = cJSON_GetObjectItem(ctx.c_metadata, "includes");
        ctx.preprocessor_dirs = cJSON_GetObjectItem(ctx.c_metadata, "preprocessor_directives");
    }

    // Parse reactive manifest
    ctx.reactive_manifest = cJSON_GetObjectItem(root, "reactive_manifest");
    if (ctx.reactive_manifest) {
        ctx.reactive_vars = cJSON_GetObjectItem(ctx.reactive_manifest, "variables");
        ctx.has_reactive_state = (ctx.reactive_vars &&
                                  cJSON_IsArray(ctx.reactive_vars) &&
                                  cJSON_GetArraySize(ctx.reactive_vars) > 0);
    }

    // Check if this is a component module (has component_definitions but no root)
    cJSON* component_defs = cJSON_GetObjectItem(root, "component_definitions");
    bool is_component_module = (component_defs && cJSON_IsArray(component_defs) &&
                                cJSON_GetArraySize(component_defs) > 0 &&
                                !ctx.component_tree);

    // Check for struct definitions in source_structures
    cJSON* source_structures = cJSON_GetObjectItem(root, "source_structures");
    cJSON* struct_types = source_structures ?
                          cJSON_GetObjectItem(source_structures, "struct_types") : NULL;
    bool has_struct_types = (struct_types && cJSON_IsArray(struct_types) &&
                             cJSON_GetArraySize(struct_types) > 0);

    // Check for exported functions or constants (utility modules)
    cJSON* exports = source_structures ?
                     cJSON_GetObjectItem(source_structures, "exports") : NULL;
    bool has_exports = (exports && cJSON_IsArray(exports) &&
                        cJSON_GetArraySize(exports) > 0);

    cJSON* const_decls = source_structures ?
                         cJSON_GetObjectItem(source_structures, "const_declarations") : NULL;
    bool has_const_decls = (const_decls && cJSON_IsArray(const_decls) &&
                            cJSON_GetArraySize(const_decls) > 0);

    // A utility module has exports/consts but no root or component definitions
    bool is_utility_module = (has_exports || has_const_decls) &&
                             !ctx.component_tree && !is_component_module;

    // Generate code sections
    generate_includes(&ctx);
    generate_preprocessor_directives(&ctx);

    // Generate struct definitions if present
    if (has_struct_types) {
        generate_struct_definitions(&ctx, struct_types);
    }

    generate_variable_declarations(&ctx);
    generate_helper_functions(&ctx);
    generate_event_handlers(&ctx);

    // Generate reactive signal declarations if needed (must come before KRY handlers)
    if (ctx.has_reactive_state) {
        generate_reactive_signal_declarations(&ctx);
    }

    // Generate KRY event handlers from logic_block (transpiled from KRY expressions)
    // Must come after signal declarations so handlers can reference the signals
    cJSON* logic_block = cJSON_GetObjectItem(root, "logic_block");
    generate_kry_event_handlers(&ctx, logic_block);

    if (is_component_module) {
        // Generate component definitions for module files
        generate_component_definitions(&ctx, component_defs);
    } else if (is_utility_module) {
        // Utility modules: generate exported functions and constants
        cJSON* logic_block = cJSON_GetObjectItem(root, "logic_block");
        if (!generate_exported_functions(output, logic_block, exports, output_path)) {
            // Hard error occurred - cleanup and return false
            fclose(output);
            cJSON_Delete(root);
            return false;
        }
    } else if (ctx.component_tree) {
        // App files with root: generate main()
        generate_main_function(&ctx);
    }
    // Struct-only modules: struct is already generated, no main() needed

    // Cleanup
    fclose(output);
    cJSON_Delete(root);

    return true;
}

bool ir_generate_c_code(const char* kir_path, const char* output_path) {
    if (!kir_path || !output_path) return false;

    // Set error prefix for this codegen
    codegen_set_error_prefix("C");

    // Read KIR file using shared utility
    char* content = codegen_read_kir_file(kir_path, NULL);
    if (!content) {
        return false;
    }

    // Generate code
    bool result = ir_generate_c_code_from_string(content, output_path);
    free(content);

    return result;
}

/**
 * Convert module_id to include guard name (uppercase with underscores)
 */
static char* c_module_to_guard_name(const char* module_id) {
    if (!module_id) return strdup("COMPONENT_H");

    size_t len = strlen(module_id);
    char* result = malloc(len + 3);  // _H\0
    if (!result) return strdup("COMPONENT_H");

    for (size_t i = 0; i < len; i++) {
        if (module_id[i] == '/') {
            result[i] = '_';
        } else if (module_id[i] >= 'a' && module_id[i] <= 'z') {
            result[i] = module_id[i] - 'a' + 'A';  // To uppercase
        } else {
            result[i] = module_id[i];
        }
    }
    result[len] = '_';
    result[len + 1] = 'H';
    result[len + 2] = '\0';

    return result;
}

/**
 * Generate a header file (.h) for a C component
 */
static bool c_generate_header_file(const char* module_id, const char* output_dir) {
    char* guard_name = c_module_to_guard_name(module_id);

    char header_path[2048];
    snprintf(header_path, sizeof(header_path), "%s/%s.h", output_dir, module_id);

    // Generate header content
    char header_content[4096];
    snprintf(header_content, sizeof(header_content),
             "/**\n"
             " * %s - Auto-generated header\n"
             " * Generated by Kryon C Code Generator\n"
             " */\n\n"
             "#ifndef %s\n"
             "#define %s\n\n"
             "#include <kryon.h>\n"
             "#include <kryon_dsl.h>\n\n"
             "// Component declaration\n"
             "IRComponent* %s_create(void);\n\n"
             "#endif // %s\n",
             module_id, guard_name, guard_name,
             strrchr(module_id, '/') ? strrchr(module_id, '/') + 1 : module_id,
             guard_name);

    bool result = codegen_write_file_with_mkdir(header_path, header_content);

    free(guard_name);
    return result;
}

/**
 * Recursively process a module and its transitive imports for C
 */
static int c_process_module_recursive(const char* module_id, const char* kir_dir,
                                      const char* output_dir, CodegenProcessedModules* processed) {
    // Skip if already processed
    if (codegen_processed_modules_contains(processed, module_id)) return 0;
    codegen_processed_modules_add(processed, module_id);

    // Skip internal modules
    if (codegen_is_internal_module(module_id)) return 0;

    // Skip external plugins (they're runtime dependencies, not source)
    if (codegen_is_external_plugin(module_id)) return 0;

    // Build path to component's KIR file
    char component_kir_path[2048];
    snprintf(component_kir_path, sizeof(component_kir_path),
             "%s/%s.kir", kir_dir, module_id);

    // Read component's KIR
    char* component_kir_json = codegen_read_kir_file(component_kir_path, NULL);
    if (!component_kir_json) {
        fprintf(stderr, "Warning: Cannot find KIR for '%s' at %s\n",
                module_id, component_kir_path);
        return 0;
    }

    // Parse to get transitive imports before generating
    cJSON* component_root = cJSON_Parse(component_kir_json);
    int files_written = 0;

    // Generate C source file
    char c_output_path[2048];
    snprintf(c_output_path, sizeof(c_output_path), "%s/%s.c", output_dir, module_id);

    // Create parent directories if needed (e.g., for components/habit_panel.c)
    char* dir_copy = strdup(c_output_path);
    if (dir_copy) {
        char* last_slash = strrchr(dir_copy, '/');
        if (last_slash) {
            *last_slash = '\0';
            codegen_mkdir_p(dir_copy);
        }
        free(dir_copy);
    }

    if (ir_generate_c_code_from_string(component_kir_json, c_output_path)) {
        printf("✓ Generated: %s.c\n", module_id);
        files_written++;

        // Also generate header file
        if (c_generate_header_file(module_id, output_dir)) {
            printf("✓ Generated: %s.h\n", module_id);
            files_written++;
        }
    } else {
        fprintf(stderr, "Warning: Failed to generate C code for '%s'\n", module_id);
    }

    free(component_kir_json);

    // Process transitive imports from this component
    // Imports are in source_structures.requires[].module
    if (component_root) {
        cJSON* source_structures = cJSON_GetObjectItem(component_root, "source_structures");
        cJSON* requires = source_structures ? cJSON_GetObjectItem(source_structures, "requires") : NULL;
        if (requires && cJSON_IsArray(requires)) {
            cJSON* import_item = NULL;
            cJSON_ArrayForEach(import_item, requires) {
                cJSON* module_obj = cJSON_GetObjectItem(import_item, "module");
                if (!module_obj || !cJSON_IsString(module_obj)) continue;
                const char* module_path = cJSON_GetStringValue(module_obj);
                if (module_path) {
                    // Convert module path to file path format
                    char sub_module_id[512];
                    strncpy(sub_module_id, module_path, sizeof(sub_module_id) - 1);
                    sub_module_id[sizeof(sub_module_id) - 1] = '\0';
                    for (char* p = sub_module_id; *p; p++) {
                        if (*p == '.') *p = '/';
                    }
                    files_written += c_process_module_recursive(sub_module_id, kir_dir,
                                                                output_dir, processed);
                }
            }
        }
        cJSON_Delete(component_root);
    }

    return files_written;
}

bool ir_generate_c_code_multi(const char* kir_path, const char* output_dir) {
    if (!kir_path || !output_dir) {
        fprintf(stderr, "Error: Invalid arguments to ir_generate_c_code_multi\n");
        return false;
    }

    // Set error prefix for this codegen
    codegen_set_error_prefix("C");

    // Read main KIR file
    char* main_kir_json = codegen_read_kir_file(kir_path, NULL);
    if (!main_kir_json) {
        return false;
    }

    // Parse main KIR JSON
    cJSON* main_root = cJSON_Parse(main_kir_json);
    if (!main_root) {
        fprintf(stderr, "Error: Failed to parse main KIR JSON\n");
        free(main_kir_json);
        return false;
    }

    // Check if output_dir is actually a file path (ends with .c)
    size_t output_len = strlen(output_dir);
    bool is_file_output = (output_len > 2 && strcmp(output_dir + output_len - 2, ".c") == 0);

    char actual_output_dir[2048];
    char main_output_path[2048];

    if (is_file_output) {
        // Extract directory from file path
        const char* last_slash = strrchr(output_dir, '/');
        if (last_slash) {
            size_t dir_len = last_slash - output_dir;
            strncpy(actual_output_dir, output_dir, dir_len);
            actual_output_dir[dir_len] = '\0';
        } else {
            strcpy(actual_output_dir, ".");
        }
        // Use the provided path as-is for main.c
        strncpy(main_output_path, output_dir, sizeof(main_output_path) - 1);
        main_output_path[sizeof(main_output_path) - 1] = '\0';
    } else {
        // Treat as directory, append /main.c
        strncpy(actual_output_dir, output_dir, sizeof(actual_output_dir) - 1);
        actual_output_dir[sizeof(actual_output_dir) - 1] = '\0';
        snprintf(main_output_path, sizeof(main_output_path), "%s/main.c", output_dir);
    }

    // Create output directory if it doesn't exist
    if (!codegen_mkdir_p(actual_output_dir)) {
        fprintf(stderr, "Error: Could not create output directory: %s\n", actual_output_dir);
        cJSON_Delete(main_root);
        free(main_kir_json);
        return false;
    }

    int files_written = 0;

    // 1. Generate main.c from main.kir

    if (ir_generate_c_code_from_string(main_kir_json, main_output_path)) {
        printf("✓ Generated: main.c\n");
        files_written++;
    } else {
        fprintf(stderr, "Warning: Failed to generate main.c from KIR\n");
    }

    free(main_kir_json);

    // 2. Get the KIR directory (parent of kir_path)
    char kir_dir[2048];
    codegen_get_parent_dir(kir_path, kir_dir, sizeof(kir_dir));

    // 3. Track processed modules to avoid duplicates
    CodegenProcessedModules processed = {0};
    codegen_processed_modules_add(&processed, "main");  // Mark main as processed

    // 4. Process each import recursively (including transitive imports)
    // Imports are in source_structures.requires[].module
    cJSON* source_structures = cJSON_GetObjectItem(main_root, "source_structures");
    cJSON* requires = source_structures ? cJSON_GetObjectItem(source_structures, "requires") : NULL;
    if (requires && cJSON_IsArray(requires)) {
        cJSON* import_item = NULL;
        cJSON_ArrayForEach(import_item, requires) {
            cJSON* module_obj = cJSON_GetObjectItem(import_item, "module");
            if (!module_obj || !cJSON_IsString(module_obj)) continue;

            const char* module_path = cJSON_GetStringValue(module_obj);
            if (module_path) {
                // Convert module path (e.g., "components.habit_panel") to file path format
                char module_id[512];
                strncpy(module_id, module_path, sizeof(module_id) - 1);
                module_id[sizeof(module_id) - 1] = '\0';
                // Replace dots with slashes for file path
                for (char* p = module_id; *p; p++) {
                    if (*p == '.') *p = '/';
                }
                files_written += c_process_module_recursive(module_id, kir_dir,
                                                            actual_output_dir, &processed);
            }
        }
    }

    codegen_processed_modules_free(&processed);
    cJSON_Delete(main_root);

    if (files_written == 0) {
        fprintf(stderr, "Warning: No C files were generated\n");
        return false;
    }

    printf("✓ Generated %d C files in %s\n", files_written, actual_output_dir);
    return true;
}
