/**
 * C Code Generator - KIR → C Source Code
 *
 * Generates idiomatic C code with Kryon DSL from KIR JSON files
 */

#include "ir_c_codegen.h"
#include "../codegen_common.h"
#include "../../ir/src/utils/ir_c_metadata.h"
#include "../../third_party/cJSON/cJSON.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <ctype.h>

// ============================================================================
// Code Generation Context
// ============================================================================

typedef struct {
    FILE* output;
    int indent_level;
    cJSON* root_json;           // Full KIR JSON
    cJSON* component_tree;      // Root component
    cJSON* c_metadata;          // C metadata section
    cJSON* variables;           // Variables array
    cJSON* event_handlers;      // Event handlers array
    cJSON* helper_functions;    // Helper functions array
    cJSON* includes;            // Includes array
    cJSON* preprocessor_dirs;   // Preprocessor directives array
} CCodegenContext;

// ============================================================================
// Utility Functions
// ============================================================================

static void write_indent(CCodegenContext* ctx) {
    for (int i = 0; i < ctx->indent_level; i++) {
        fprintf(ctx->output, "    ");
    }
}

static void writeln(CCodegenContext* ctx, const char* str) {
    write_indent(ctx);
    fprintf(ctx->output, "%s\n", str);
}

static void write_raw(CCodegenContext* ctx, const char* str) __attribute__((unused));
static void write_raw(CCodegenContext* ctx, const char* str) {
    fprintf(ctx->output, "%s", str);
}

// Get variable name for a component ID
static const char* get_variable_for_component_id(CCodegenContext* ctx, int component_id) {
    if (!ctx->variables) return NULL;

    int var_count = cJSON_GetArraySize(ctx->variables);
    for (int i = 0; i < var_count; i++) {
        cJSON* var = cJSON_GetArrayItem(ctx->variables, i);
        cJSON* id_item = cJSON_GetObjectItem(var, "component_id");
        if (id_item && id_item->valueint == component_id) {
            cJSON* name = cJSON_GetObjectItem(var, "name");
            if (name && name->valuestring) {
                return name->valuestring;
            }
        }
    }
    return NULL;
}

// Map component type to C DSL macro name
static const char* get_component_macro(const char* type) {
    if (strcmp(type, "Container") == 0) return "CONTAINER";
    if (strcmp(type, "Column") == 0) return "COLUMN";
    if (strcmp(type, "Row") == 0) return "ROW";
    if (strcmp(type, "Center") == 0) return "CENTER";
    if (strcmp(type, "Text") == 0) return "TEXT";
    if (strcmp(type, "Button") == 0) return "BUTTON";
    if (strcmp(type, "Input") == 0) return "INPUT";
    if (strcmp(type, "Checkbox") == 0) return "CHECKBOX";
    if (strcmp(type, "Dropdown") == 0) return "DROPDOWN";
    if (strcmp(type, "Image") == 0) return "IMAGE";
    if (strcmp(type, "TabGroup") == 0) return "TAB_GROUP";
    if (strcmp(type, "TabBar") == 0) return "TAB_BAR";
    if (strcmp(type, "Tab") == 0) return "TAB";
    if (strcmp(type, "TabContent") == 0) return "TAB_CONTENT";
    if (strcmp(type, "TabPanel") == 0) return "TAB_PANEL";
    if (strcmp(type, "Table") == 0) return "TABLE";
    if (strcmp(type, "TableHead") == 0) return "TABLE_HEAD";
    if (strcmp(type, "TableBody") == 0) return "TABLE_BODY";
    if (strcmp(type, "TableRow") == 0) return "TABLE_ROW";
    if (strcmp(type, "TableCell") == 0) return "TABLE_CELL";
    if (strcmp(type, "TableHeaderCell") == 0) return "TABLE_HEADER_CELL";
    return "CONTAINER";  // Fallback
}

// ============================================================================
// Header Generation
// ============================================================================

static void generate_includes(CCodegenContext* ctx) {
    fprintf(ctx->output, "/**\n");
    fprintf(ctx->output, " * Auto-generated C code from .kir file\n");
    fprintf(ctx->output, " * Generated by Kryon C Code Generator\n");
    fprintf(ctx->output, " */\n\n");

    // Generate includes from metadata
    if (ctx->includes && cJSON_IsArray(ctx->includes)) {
        int count = cJSON_GetArraySize(ctx->includes);
        for (int i = 0; i < count; i++) {
            cJSON* inc = cJSON_GetArrayItem(ctx->includes, i);
            cJSON* include_str = cJSON_GetObjectItem(inc, "include");
            if (include_str && include_str->valuestring) {
                fprintf(ctx->output, "#include %s\n", include_str->valuestring);
            }
        }
    } else {
        // Default includes if no metadata
        fprintf(ctx->output, "#include <kryon.h>\n");
        fprintf(ctx->output, "#include <kryon_dsl.h>\n");
        fprintf(ctx->output, "#include <stdio.h>\n");
        fprintf(ctx->output, "#include <stdbool.h>\n");
    }
    fprintf(ctx->output, "\n");
}

static void generate_preprocessor_directives(CCodegenContext* ctx) {
    if (!ctx->preprocessor_dirs || !cJSON_IsArray(ctx->preprocessor_dirs)) {
        return;
    }

    int count = cJSON_GetArraySize(ctx->preprocessor_dirs);
    if (count == 0) return;

    for (int i = 0; i < count; i++) {
        cJSON* dir = cJSON_GetArrayItem(ctx->preprocessor_dirs, i);
        cJSON* type = cJSON_GetObjectItem(dir, "directive_type");
        cJSON* condition = cJSON_GetObjectItem(dir, "condition");
        cJSON* value = cJSON_GetObjectItem(dir, "value");

        if (!type || !type->valuestring) continue;

        if (strcmp(type->valuestring, "define") == 0) {
            fprintf(ctx->output, "#define ");
            if (condition && condition->valuestring) {
                fprintf(ctx->output, "%s ", condition->valuestring);
            }
            if (value && value->valuestring) {
                fprintf(ctx->output, "%s", value->valuestring);
            }
            fprintf(ctx->output, "\n");
        } else if (strcmp(type->valuestring, "ifdef") == 0 && condition && condition->valuestring) {
            fprintf(ctx->output, "#ifdef %s\n", condition->valuestring);
        } else if (strcmp(type->valuestring, "ifndef") == 0 && condition && condition->valuestring) {
            fprintf(ctx->output, "#ifndef %s\n", condition->valuestring);
        } else if (strcmp(type->valuestring, "if") == 0 && condition && condition->valuestring) {
            fprintf(ctx->output, "#if %s\n", condition->valuestring);
        } else if (strcmp(type->valuestring, "elif") == 0 && condition && condition->valuestring) {
            fprintf(ctx->output, "#elif %s\n", condition->valuestring);
        } else if (strcmp(type->valuestring, "else") == 0) {
            fprintf(ctx->output, "#else\n");
        } else if (strcmp(type->valuestring, "endif") == 0) {
            fprintf(ctx->output, "#endif\n");
        }
    }
    fprintf(ctx->output, "\n");
}

// ============================================================================
// Variable & Function Generation
// ============================================================================

static void generate_variable_declarations(CCodegenContext* ctx) {
    if (!ctx->variables || !cJSON_IsArray(ctx->variables)) {
        return;
    }

    int count = cJSON_GetArraySize(ctx->variables);
    if (count == 0) return;

    fprintf(ctx->output, "// Component variables\n");
    for (int i = 0; i < count; i++) {
        cJSON* var = cJSON_GetArrayItem(ctx->variables, i);
        cJSON* storage = cJSON_GetObjectItem(var, "storage");
        cJSON* type = cJSON_GetObjectItem(var, "type");
        cJSON* name = cJSON_GetObjectItem(var, "name");
        cJSON* initial = cJSON_GetObjectItem(var, "initial_value");

        if (!name || !name->valuestring || !type || !type->valuestring) continue;

        if (storage && storage->valuestring) {
            fprintf(ctx->output, "%s ", storage->valuestring);
        }
        fprintf(ctx->output, "%s %s", type->valuestring, name->valuestring);

        if (initial && initial->valuestring) {
            fprintf(ctx->output, " = %s", initial->valuestring);
        }
        fprintf(ctx->output, ";\n");
    }
    fprintf(ctx->output, "\n");
}

static void generate_helper_functions(CCodegenContext* ctx) {
    if (!ctx->helper_functions || !cJSON_IsArray(ctx->helper_functions)) {
        return;
    }

    int count = cJSON_GetArraySize(ctx->helper_functions);
    if (count == 0) return;

    fprintf(ctx->output, "// Helper functions\n");
    for (int i = 0; i < count; i++) {
        cJSON* func = cJSON_GetArrayItem(ctx->helper_functions, i);
        cJSON* return_type = cJSON_GetObjectItem(func, "return_type");
        cJSON* name = cJSON_GetObjectItem(func, "name");
        cJSON* params = cJSON_GetObjectItem(func, "parameters");
        cJSON* body = cJSON_GetObjectItem(func, "body");

        if (!name || !name->valuestring || !return_type || !return_type->valuestring) continue;

        fprintf(ctx->output, "%s %s(%s) {\n",
                return_type->valuestring,
                name->valuestring,
                (params && params->valuestring) ? params->valuestring : "void");

        if (body && body->valuestring) {
            fprintf(ctx->output, "%s\n", body->valuestring);
        }

        fprintf(ctx->output, "}\n\n");
    }
}

static void generate_event_handlers(CCodegenContext* ctx) {
    if (!ctx->event_handlers || !cJSON_IsArray(ctx->event_handlers)) {
        return;
    }

    int count = cJSON_GetArraySize(ctx->event_handlers);
    if (count == 0) return;

    fprintf(ctx->output, "// Event handlers\n");
    for (int i = 0; i < count; i++) {
        cJSON* handler = cJSON_GetArrayItem(ctx->event_handlers, i);
        cJSON* return_type = cJSON_GetObjectItem(handler, "return_type");
        cJSON* name = cJSON_GetObjectItem(handler, "function_name");
        cJSON* params = cJSON_GetObjectItem(handler, "parameters");
        cJSON* body = cJSON_GetObjectItem(handler, "body");

        if (!name || !name->valuestring || !return_type || !return_type->valuestring) continue;

        fprintf(ctx->output, "%s %s(%s) {\n",
                return_type->valuestring,
                name->valuestring,
                (params && params->valuestring) ? params->valuestring : "void");

        if (body && body->valuestring) {
            fprintf(ctx->output, "%s\n", body->valuestring);
        }

        fprintf(ctx->output, "}\n\n");
    }
}

// ============================================================================
// Component Tree Generation
// ============================================================================

static bool generate_property_macro(CCodegenContext* ctx, const char* key, cJSON* value);

static void generate_component_recursive(CCodegenContext* ctx, cJSON* component, bool is_root) {
    cJSON* type_obj = cJSON_GetObjectItem(component, "type");
    cJSON* id_obj = cJSON_GetObjectItem(component, "id");
    cJSON* children_obj = cJSON_GetObjectItem(component, "children");
    cJSON* text_obj = cJSON_GetObjectItem(component, "text");

    if (!type_obj || !type_obj->valuestring) return;

    const char* type = type_obj->valuestring;
    const char* macro = get_component_macro(type);

    // Check if this component has a variable assignment
    const char* var_name = NULL;
    if (id_obj) {
        var_name = get_variable_for_component_id(ctx, id_obj->valueint);
    }

    // Write indentation
    write_indent(ctx);

    // Variable assignment if needed
    if (var_name && !is_root) {
        fprintf(ctx->output, "%s = ", var_name);
    }

    // Component macro
    fprintf(ctx->output, "%s(", macro);

    // Text/label parameter for components that need it
    bool has_text = (text_obj && text_obj->valuestring);
    if (has_text) {
        fprintf(ctx->output, "\"%s\"", text_obj->valuestring);
    }

    // Check for FULL_SIZE pattern (width=100.0px AND height=100.0px)
    cJSON* width_prop = cJSON_GetObjectItem(component, "width");
    cJSON* height_prop = cJSON_GetObjectItem(component, "height");
    bool is_full_size = (width_prop && width_prop->valuestring &&
                         height_prop && height_prop->valuestring &&
                         (strcmp(width_prop->valuestring, "100.0px") == 0 ||
                          strcmp(width_prop->valuestring, "100.0%") == 0) &&
                         (strcmp(height_prop->valuestring, "100.0px") == 0 ||
                          strcmp(height_prop->valuestring, "100.0%") == 0));

    // Check if we have properties or children
    bool has_properties = false;
    cJSON* prop = NULL;
    cJSON_ArrayForEach(prop, component) {
        const char* key = prop->string;
        if (!key) continue;
        if (strcmp(key, "id") != 0 && strcmp(key, "type") != 0 &&
            strcmp(key, "text") != 0 && strcmp(key, "children") != 0 &&
            strcmp(key, "TEST_MARKER") != 0 && strcmp(key, "direction") != 0 &&
            strcmp(key, "background") != 0 && strcmp(key, "color") != 0) {
            has_properties = true;
            break;
        }
        // Check if background/color are non-default
        if (strcmp(key, "background") == 0 && prop->valuestring && strcmp(prop->valuestring, "#00000000") != 0) {
            has_properties = true;
            break;
        }
        if (strcmp(key, "color") == 0 && prop->valuestring && strcmp(prop->valuestring, "#00000000") != 0) {
            has_properties = true;
            break;
        }
    }

    bool has_children = (children_obj && cJSON_GetArraySize(children_obj) > 0);

    // Add comma after text if there are properties or children
    if (has_text && (has_properties || has_children)) {
        fprintf(ctx->output, ",\n");
    } else if (!has_text || !has_properties) {
        fprintf(ctx->output, "\n");
    }

    ctx->indent_level++;

    // Generate FULL_SIZE if applicable
    bool first_prop = true;
    if (is_full_size) {
        if (!first_prop) {
            fprintf(ctx->output, ",\n");
        }
        write_indent(ctx);
        fprintf(ctx->output, "FULL_SIZE");
        first_prop = false;
    }

    // Generate properties
    cJSON* prop2 = NULL;
    cJSON_ArrayForEach(prop2, component) {
        const char* key = prop2->string;
        if (!key) continue;

        // Skip internal fields
        if (strcmp(key, "id") == 0 || strcmp(key, "type") == 0 ||
            strcmp(key, "text") == 0 || strcmp(key, "children") == 0 ||
            strcmp(key, "TEST_MARKER") == 0 || strcmp(key, "direction") == 0) {
            continue;
        }

        // Skip width/height if we already generated FULL_SIZE
        if (is_full_size && (strcmp(key, "width") == 0 || strcmp(key, "height") == 0)) {
            continue;
        }

        // Skip transparent/default colors
        if ((strcmp(key, "background") == 0 || strcmp(key, "color") == 0) &&
            prop2->valuestring && strcmp(prop2->valuestring, "#00000000") == 0) {
            continue;
        }

        // Skip events property if there are no event handlers in metadata
        if (strcmp(key, "events") == 0 && (!ctx->event_handlers || cJSON_GetArraySize(ctx->event_handlers) == 0)) {
            continue;
        }

        // Print comma before property (except first)
        if (!first_prop) {
            fprintf(ctx->output, ",\n");
        }

        // Generate the property
        if (generate_property_macro(ctx, key, prop2)) {
            first_prop = false;
        }
    }

    // Generate children
    if (children_obj && cJSON_IsArray(children_obj)) {
        int child_count = cJSON_GetArraySize(children_obj);
        if (child_count > 0) {
            // Print comma before children if we had properties
            if (!first_prop) {
                fprintf(ctx->output, ",\n");
                fprintf(ctx->output, "\n");  // Blank line for readability
            }

            for (int i = 0; i < child_count; i++) {
                cJSON* child = cJSON_GetArrayItem(children_obj, i);
                generate_component_recursive(ctx, child, false);
                if (i < child_count - 1) {
                    fprintf(ctx->output, ",\n");
                } else {
                    fprintf(ctx->output, "\n");
                }
            }
        }
    }

    ctx->indent_level--;
    write_indent(ctx);
    fprintf(ctx->output, ")");
}

static bool generate_property_macro(CCodegenContext* ctx, const char* key, cJSON* value) {
    // NOTE: write_indent() is called by each case that generates output
    // Don't call it here, as we might not generate anything

    // Width/Height
    if (strcmp(key, "width") == 0 && value->valuestring) {
        write_indent(ctx);
        if (strcmp(value->valuestring, "100.0px") == 0 || strcmp(value->valuestring, "100.0%") == 0) {
            fprintf(ctx->output, "FULL_WIDTH");
        } else {
            // Parse numeric value (e.g., "200.0px" → 200)
            int width_val = 0;
            if (sscanf(value->valuestring, "%d", &width_val) == 1 && width_val > 0) {
                fprintf(ctx->output, "WIDTH(%d)", width_val);
            } else {
                fprintf(ctx->output, "WIDTH(\"%s\")", value->valuestring);
            }
        }
        return true;
    }
    if (strcmp(key, "height") == 0 && value->valuestring) {
        write_indent(ctx);
        if (strcmp(value->valuestring, "100.0px") == 0 || strcmp(value->valuestring, "100.0%") == 0) {
            fprintf(ctx->output, "FULL_HEIGHT");
        } else {
            // Parse numeric value (e.g., "60.0px" → 60)
            int height_val = 0;
            if (sscanf(value->valuestring, "%d", &height_val) == 1 && height_val > 0) {
                fprintf(ctx->output, "HEIGHT(%d)", height_val);
            } else {
                fprintf(ctx->output, "HEIGHT(\"%s\")", value->valuestring);
            }
        }
        return true;
    }

    // Colors
    if (strcmp(key, "background") == 0 && value->valuestring) {
        write_indent(ctx);
        fprintf(ctx->output, "BG_COLOR(\"%s\")", value->valuestring);
        return true;
    }
    if (strcmp(key, "color") == 0 && value->valuestring) {
        write_indent(ctx);
        // Check for named colors
        if (strcmp(value->valuestring, "#ffffff") == 0) {
            fprintf(ctx->output, "COLOR_WHITE");
        } else if (strcmp(value->valuestring, "#000000") == 0) {
            fprintf(ctx->output, "COLOR_BLACK");
        } else if (strcmp(value->valuestring, "#ff0000") == 0) {
            fprintf(ctx->output, "COLOR_RED");
        } else if (strcmp(value->valuestring, "#00ff00") == 0) {
            fprintf(ctx->output, "COLOR_GREEN");
        } else if (strcmp(value->valuestring, "#0000ff") == 0) {
            fprintf(ctx->output, "COLOR_BLUE");
        } else if (strcmp(value->valuestring, "#ffff00") == 0) {
            fprintf(ctx->output, "COLOR_YELLOW");
        } else if (strcmp(value->valuestring, "#00ffff") == 0) {
            fprintf(ctx->output, "COLOR_CYAN");
        } else if (strcmp(value->valuestring, "#ff00ff") == 0) {
            fprintf(ctx->output, "COLOR_MAGENTA");
        } else if (strcmp(value->valuestring, "#808080") == 0) {
            fprintf(ctx->output, "COLOR_GRAY");
        } else if (strcmp(value->valuestring, "#ffa500") == 0) {
            fprintf(ctx->output, "COLOR_ORANGE");
        } else if (strcmp(value->valuestring, "#800080") == 0) {
            fprintf(ctx->output, "COLOR_PURPLE");
        } else {
            fprintf(ctx->output, "COLOR(\"%s\")", value->valuestring);
        }
        return true;
    }

    // Padding/Margin
    if (strcmp(key, "padding") == 0) {
        write_indent(ctx);
        if (cJSON_IsNumber(value)) {
            fprintf(ctx->output, "PADDING(%.0f)", value->valuedouble);
        } else if (cJSON_IsArray(value)) {
            int size = cJSON_GetArraySize(value);
            if (size == 4) {
                fprintf(ctx->output, "PADDING_SIDES(%.0f, %.0f, %.0f, %.0f)",
                        cJSON_GetArrayItem(value, 0)->valuedouble,
                        cJSON_GetArrayItem(value, 1)->valuedouble,
                        cJSON_GetArrayItem(value, 2)->valuedouble,
                        cJSON_GetArrayItem(value, 3)->valuedouble);
            }
        }
        return true;
    }
    if (strcmp(key, "gap") == 0 && cJSON_IsNumber(value)) {
        write_indent(ctx);
        fprintf(ctx->output, "GAP(%.0f)", value->valuedouble);
        return true;
    }

    // Typography
    if (strcmp(key, "fontSize") == 0 && cJSON_IsNumber(value)) {
        write_indent(ctx);
        fprintf(ctx->output, "FONT_SIZE(%.0f)", value->valuedouble);
        return true;
    }
    if (strcmp(key, "fontBold") == 0 && cJSON_IsBool(value)) {
        if (cJSON_IsTrue(value)) {
            write_indent(ctx);
            fprintf(ctx->output, "FONT_BOLD");
            return true;
        }
        return false;
    }

    // Layout
    if (strcmp(key, "justifyContent") == 0 && value->valuestring) {
        write_indent(ctx);
        if (strcmp(value->valuestring, "center") == 0) {
            fprintf(ctx->output, "JUSTIFY_CENTER");
        } else if (strcmp(value->valuestring, "flex-start") == 0 || strcmp(value->valuestring, "start") == 0) {
            fprintf(ctx->output, "JUSTIFY_START");
        } else if (strcmp(value->valuestring, "flex-end") == 0 || strcmp(value->valuestring, "end") == 0) {
            fprintf(ctx->output, "JUSTIFY_END");
        } else if (strcmp(value->valuestring, "space-between") == 0) {
            fprintf(ctx->output, "JUSTIFY_SPACE_BETWEEN");
        } else if (strcmp(value->valuestring, "space-around") == 0) {
            fprintf(ctx->output, "JUSTIFY_SPACE_AROUND");
        } else {
            fprintf(ctx->output, "JUSTIFY_CENTER");
        }
        return true;
    }
    if (strcmp(key, "alignItems") == 0 && value->valuestring) {
        write_indent(ctx);
        if (strcmp(value->valuestring, "center") == 0) {
            fprintf(ctx->output, "ALIGN_CENTER");
        } else if (strcmp(value->valuestring, "flex-start") == 0 || strcmp(value->valuestring, "start") == 0) {
            fprintf(ctx->output, "ALIGN_START");
        } else if (strcmp(value->valuestring, "flex-end") == 0 || strcmp(value->valuestring, "end") == 0) {
            fprintf(ctx->output, "ALIGN_END");
        } else if (strcmp(value->valuestring, "stretch") == 0) {
            fprintf(ctx->output, "ALIGN_STRETCH");
        } else {
            fprintf(ctx->output, "ALIGN_CENTER");
        }
        return true;
    }
    if (strcmp(key, "flexShrink") == 0 && cJSON_IsNumber(value)) {
        write_indent(ctx);
        fprintf(ctx->output, "FLEX_SHRINK(%.0f)", value->valuedouble);
        return true;
    }

    // Visibility
    if (strcmp(key, "visible") == 0 && cJSON_IsBool(value)) {
        write_indent(ctx);
        fprintf(ctx->output, "VISIBLE(%s)", cJSON_IsTrue(value) ? "true" : "false");
        return true;
    }

    // Events
    if (strcmp(key, "events") == 0 && cJSON_IsArray(value)) {
        int event_count = cJSON_GetArraySize(value);
        bool printed = false;
        for (int i = 0; i < event_count; i++) {
            cJSON* event = cJSON_GetArrayItem(value, i);
            cJSON* event_type = cJSON_GetObjectItem(event, "type");
            cJSON* logic_id = cJSON_GetObjectItem(event, "logic_id");

            if (event_type && event_type->valuestring && logic_id && logic_id->valuestring) {
                // Find the function name for this logic_id
                if (ctx->event_handlers) {
                    int handler_count = cJSON_GetArraySize(ctx->event_handlers);
                    for (int j = 0; j < handler_count; j++) {
                        cJSON* handler = cJSON_GetArrayItem(ctx->event_handlers, j);
                        cJSON* h_logic_id = cJSON_GetObjectItem(handler, "logic_id");
                        cJSON* h_func_name = cJSON_GetObjectItem(handler, "function_name");

                        if (h_logic_id && h_logic_id->valuestring &&
                            h_func_name && h_func_name->valuestring &&
                            strcmp(h_logic_id->valuestring, logic_id->valuestring) == 0) {

                            if (strcmp(event_type->valuestring, "click") == 0) {
                                write_indent(ctx);
                                fprintf(ctx->output, "ON_CLICK(%s)", h_func_name->valuestring);
                                printed = true;
                            }
                            break;
                        }
                    }
                }
            }
        }
        return printed;
    }

    // Fallback: skip unknown properties
    return false;
}

// ============================================================================
// Main Function Generation
// ============================================================================

static void generate_main_function(CCodegenContext* ctx) {
    fprintf(ctx->output, "int main(void) {\n");
    ctx->indent_level++;

    // kryon_init() call
    writeln(ctx, "kryon_init(\"Kryon App\", 800, 600);");
    fprintf(ctx->output, "\n");

    // KRYON_APP macro
    writeln(ctx, "KRYON_APP(");
    ctx->indent_level++;

    if (ctx->component_tree) {
        generate_component_recursive(ctx, ctx->component_tree, true);
        fprintf(ctx->output, "\n");
    }

    ctx->indent_level--;
    writeln(ctx, ");");
    fprintf(ctx->output, "\n");

    // KRYON_RUN macro
    writeln(ctx, "KRYON_RUN();");

    ctx->indent_level--;
    fprintf(ctx->output, "}\n");
}

// ============================================================================
// Main Code Generation Entry Points
// ============================================================================

bool ir_generate_c_code_from_string(const char* kir_json, const char* output_path) {
    if (!kir_json || !output_path) return false;

    // Parse KIR JSON
    cJSON* root = cJSON_Parse(kir_json);
    if (!root) {
        fprintf(stderr, "Error: Failed to parse KIR JSON\n");
        return false;
    }

    // Open output file
    FILE* output = fopen(output_path, "w");
    if (!output) {
        fprintf(stderr, "Error: Failed to open output file: %s\n", output_path);
        cJSON_Delete(root);
        return false;
    }

    // Setup context
    CCodegenContext ctx = {0};
    ctx.output = output;
    ctx.indent_level = 0;
    ctx.root_json = root;
    ctx.component_tree = cJSON_GetObjectItem(root, "root");
    ctx.c_metadata = cJSON_GetObjectItem(root, "c_metadata");

    if (ctx.c_metadata) {
        ctx.variables = cJSON_GetObjectItem(ctx.c_metadata, "variables");
        ctx.event_handlers = cJSON_GetObjectItem(ctx.c_metadata, "event_handlers");
        ctx.helper_functions = cJSON_GetObjectItem(ctx.c_metadata, "helper_functions");
        ctx.includes = cJSON_GetObjectItem(ctx.c_metadata, "includes");
        ctx.preprocessor_dirs = cJSON_GetObjectItem(ctx.c_metadata, "preprocessor_directives");
    }

    // Generate code sections
    generate_includes(&ctx);
    generate_preprocessor_directives(&ctx);
    generate_variable_declarations(&ctx);
    generate_helper_functions(&ctx);
    generate_event_handlers(&ctx);
    generate_main_function(&ctx);

    // Cleanup
    fclose(output);
    cJSON_Delete(root);

    return true;
}

bool ir_generate_c_code(const char* kir_path, const char* output_path) {
    if (!kir_path || !output_path) return false;

    // Set error prefix for this codegen
    codegen_set_error_prefix("C");

    // Read KIR file using shared utility
    char* content = codegen_read_kir_file(kir_path, NULL);
    if (!content) {
        return false;
    }

    // Generate code
    bool result = ir_generate_c_code_from_string(content, output_path);
    free(content);

    return result;
}
