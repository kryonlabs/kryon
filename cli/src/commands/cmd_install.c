/**
 * Install Command
 * Installs a Kryon application to the system
 */

#define _DEFAULT_SOURCE
#define _POSIX_C_SOURCE 200809L

#include "kryon_cli.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <errno.h>
#include <libgen.h>
#include <limits.h>

/**
 * Get default install config if none specified in kryon.toml
 */
static InstallConfig* get_default_install_config(const char* project_name) {
    InstallConfig* install = (InstallConfig*)calloc(1, sizeof(InstallConfig));
    if (!install) return NULL;

    install->mode = INSTALL_MODE_SYMLINK;
    install->binary_path = str_copy("$HOME/bin");
    install->binary_name = str_copy(project_name);
    install->binary_executable = true;
    install->files = NULL;
    install->files_count = 0;
    install->desktop.enabled = false;
    install->desktop.name = str_copy(project_name);
    install->desktop.icon = NULL;
    install->desktop.categories = NULL;
    install->desktop.categories_count = 0;
    install->target = NULL;  // Auto-detect

    return install;
}

/**
 * Determine which target to install
 * Priority: CLI override > install.target from config > desktop in targets > first target
 */
static const char* get_install_target(KryonConfig* config, const char* override, InstallConfig* install) {
    // First check CLI override
    if (override) return override;

    // Then check config-specified target
    if (install && install->target) return install->target;

    // Then check if desktop is in targets
    for (int i = 0; i < config->build_targets_count; i++) {
        if (strcmp(config->build_targets[i], "desktop") == 0) {
            return "desktop";
        }
    }

    // Default to first target
    if (config->build_targets_count > 0) {
        return config->build_targets[0];
    }

    return "desktop";  // ultimate default
}

/**
 * Create symlink from source to target
 */
static bool create_symlink(const char* source, const char* target) {
    // Remove existing symlink if it exists
    if (file_exists(target)) {
        unlink(target);
    }

    if (symlink(source, target) != 0) {
        fprintf(stderr, "Error: Failed to create symlink %s -> %s: %s\n",
                target, source, strerror(errno));
        return false;
    }

    return true;
}

/**
 * Copy file from source to target
 */
static bool copy_file(const char* source, const char* target) {
    FILE* src = fopen(source, "rb");
    if (!src) {
        fprintf(stderr, "Error: Failed to open source file %s: %s\n",
                source, strerror(errno));
        return false;
    }

    FILE* dst = fopen(target, "wb");
    if (!dst) {
        fprintf(stderr, "Error: Failed to create target file %s: %s\n",
                target, strerror(errno));
        fclose(src);
        return false;
    }

    // Copy file contents
    char buffer[8192];
    size_t bytes;
    while ((bytes = fread(buffer, 1, sizeof(buffer), src)) > 0) {
        if (fwrite(buffer, 1, bytes, dst) != bytes) {
            fprintf(stderr, "Error: Failed to write to %s\n", target);
            fclose(src);
            fclose(dst);
            return false;
        }
    }

    fclose(src);
    fclose(dst);

    // Make executable
    chmod(target, 0755);

    return true;
}

/**
 * Create wrapper script for Kry desktop apps
 */
static bool create_kry_wrapper(const char* project_dir, const char* entry_file,
                                const char* wrapper_path, const char* project_name) {
    // Create directory if needed
    char* wrapper_dir = str_copy(wrapper_path);
    char* last_slash = strrchr(wrapper_dir, '/');
    if (last_slash) {
        *last_slash = '\0';
        dir_create_recursive(wrapper_dir);
    }
    free(wrapper_dir);

    FILE* f = fopen(wrapper_path, "w");
    if (!f) {
        fprintf(stderr, "Error: Failed to create wrapper: %s\n", strerror(errno));
        return false;
    }

    fprintf(f, "#!/usr/bin/env bash\n");
    fprintf(f, "# Kryon desktop app wrapper for %s\n", project_name);
    fprintf(f, "# Auto-generated by kryon install\n\n");
    fprintf(f, "# Get directory where this script is located\n");
    fprintf(f, "SCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\n\n");
    fprintf(f, "# Project directory - resolve symlink if needed\n");
    fprintf(f, "if [ -L \"$SCRIPT_DIR\" ]; then\n");
    fprintf(f, "    PROJECT_DIR=\"$(readlink -f \"$SCRIPT_DIR\")\"\n");
    fprintf(f, "else\n");
    fprintf(f, "    PROJECT_DIR=\"$SCRIPT_DIR\"\n");
    fprintf(f, "fi\n\n");
    fprintf(f, "# Change to project directory\n");
    fprintf(f, "cd \"%s\" || exit 1\n\n", project_dir);
    fprintf(f, "# Run the application with kryon\n");
    fprintf(f, "exec kryon run %s \"$@\"\n", entry_file);

    fclose(f);

    // Make executable
    chmod(wrapper_path, 0755);

    return true;
}

/**
 * Create desktop entry file
 */
static bool create_desktop_entry(const char* project_name, const char* binary_name,
                                 const char* desktop_name, const char* icon_path,
                                 char** categories, int categories_count) {
    // Get XDG data directory
    const char* xdg_data = getenv("XDG_DATA_HOME");
    char* apps_dir;
    if (xdg_data && strlen(xdg_data) > 0) {
        apps_dir = path_join(xdg_data, "applications");
    } else {
        char* home = paths_get_home_dir();
        apps_dir = path_join(home, ".local/share/applications");
        free(home);
    }

    // Create directory if needed
    dir_create_recursive(apps_dir);

    // Create desktop file path
    char desktop_file[PATH_MAX];
    snprintf(desktop_file, sizeof(desktop_file), "%s/%s.desktop", apps_dir, project_name);

    // Expand icon path
    char* icon_expanded = icon_path ? path_expand_env_vars(icon_path) : NULL;
    char* bin_path = path_expand_env_vars("$HOME/bin");

    // Write desktop entry
    FILE* f = fopen(desktop_file, "w");
    if (!f) {
        fprintf(stderr, "Error: Failed to create desktop entry: %s\n", strerror(errno));
        free(apps_dir);
        free(icon_expanded);
        free(bin_path);
        return false;
    }

    fprintf(f, "[Desktop Entry]\n");
    fprintf(f, "Name=%s\n", desktop_name);
    fprintf(f, "Exec=%s/%s\n", bin_path, binary_name);
    if (icon_expanded) {
        fprintf(f, "Icon=%s\n", icon_expanded);
    }
    fprintf(f, "Type=Application\n");

    if (categories_count > 0) {
        fprintf(f, "Categories=");
        for (int i = 0; i < categories_count; i++) {
            fprintf(f, "%s%s", i > 0 ? ";" : "", categories[i]);
        }
        fprintf(f, ";\n");
    }

    fprintf(f, "Terminal=false\n");
    fprintf(f, "StartupNotify=true\n");

    fclose(f);
    free(apps_dir);
    free(icon_expanded);
    free(bin_path);

    printf("  Created desktop entry: %s\n", desktop_file);
    return true;
}

/**
 * Write install manifest for uninstall
 */
static bool write_install_manifest(const char* project_name, const char* version,
                                   const char* binary_path, const char* binary_name,
                                   const char* wrapper_path, const char* entry_file,
                                   const char* target, const char* frontend,
                                   InstallMode mode, bool has_desktop) {
    // Get XDG state directory
    const char* xdg_state = getenv("XDG_STATE_HOME");
    char* state_dir;
    if (xdg_state && strlen(xdg_state) > 0) {
        state_dir = path_join(xdg_state, project_name);
    } else {
        char* home = paths_get_home_dir();
        state_dir = path_join(home, ".local/state");
        char* tmp = state_dir;
        state_dir = path_join(tmp, project_name);
        free(tmp);
        free(home);
    }

    // Create directory if needed
    dir_create_recursive(state_dir);

    char manifest_path[PATH_MAX];
    snprintf(manifest_path, sizeof(manifest_path), "%s/install-manifest.json", state_dir);

    // Get binary install path
    char* expanded_binary_path = path_expand_env_vars(binary_path);
    char binary_install_path[PATH_MAX];
    snprintf(binary_install_path, sizeof(binary_install_path), "%s/%s",
             expanded_binary_path, binary_name);

    FILE* f = fopen(manifest_path, "w");
    if (!f) {
        fprintf(stderr, "Warning: Failed to write install manifest: %s\n", strerror(errno));
        free(state_dir);
        free(expanded_binary_path);
        return false;
    }

    fprintf(f, "{\n");
    fprintf(f, "  \"project\": \"%s\",\n", project_name);
    fprintf(f, "  \"version\": \"%s\",\n", version ? version : "unknown");
    fprintf(f, "  \"target\": \"%s\",\n", target);
    fprintf(f, "  \"frontend\": \"%s\",\n", frontend ? frontend : "unknown");
    if (entry_file) {
        fprintf(f, "  \"entry_file\": \"%s\",\n", entry_file);
    }
    fprintf(f, "  \"binary\": {\n");
    fprintf(f, "    \"path\": \"%s\",\n", binary_install_path);
    fprintf(f, "    \"mode\": \"%s\"\n", mode == INSTALL_MODE_SYMLINK ? "symlink" :
                              mode == INSTALL_MODE_COPY ? "copy" : "system");
    fprintf(f, "  },\n");
    if (wrapper_path) {
        fprintf(f, "  \"wrapper\": \"%s\",\n", wrapper_path);
    }
    fprintf(f, "  \"desktop\": %s\n", has_desktop ? "true" : "false");
    fprintf(f, "}\n");

    fclose(f);
    free(state_dir);
    free(expanded_binary_path);

    return true;
}

/**
 * Detect frontend type from entry file extension
 */
static const char* detect_frontend_from_entry(const char* entry) {
    if (!entry) return NULL;

    const char* ext = strrchr(entry, '.');
    if (!ext) return NULL;

    ext++;  // Skip the dot

    if (strcmp(ext, "kry") == 0) return "kry";
    if (strcmp(ext, "c") == 0) return "c";
    if (strcmp(ext, "tsx") == 0 || strcmp(ext, "ts") == 0) return "tsx";
    if (strcmp(ext, "html") == 0) return "html";

    return NULL;
}

int cmd_install(int argc, char** argv) {
    bool dry_run = false;
    bool no_build = false;
    InstallMode cli_mode = INSTALL_MODE_SYMLINK;  // Default
    bool has_cli_mode = false;
    char* target_override = NULL;

    // Parse arguments
    for (int i = 0; i < argc; i++) {
        if (strcmp(argv[i], "--help") == 0 || strcmp(argv[i], "-h") == 0) {
            printf("Usage: kryon install [options]\n\n");
            printf("Options:\n");
            printf("  --mode <mode>    Install mode: symlink (default), copy, or system\n");
            printf("  --target <t>     Target to install: desktop, web (default: auto-detect)\n");
            printf("  --dry-run        Show what would be installed without installing\n");
            printf("  --no-build       Skip automatic build before installing\n");
            printf("  --help, -h       Show this help message\n");
            return 0;
        } else if (strcmp(argv[i], "--dry-run") == 0) {
            dry_run = true;
        } else if (strcmp(argv[i], "--no-build") == 0) {
            no_build = true;
        } else if (strcmp(argv[i], "--mode") == 0) {
            if (i + 1 < argc) {
                i++;
                if (strcmp(argv[i], "symlink") == 0) {
                    cli_mode = INSTALL_MODE_SYMLINK;
                } else if (strcmp(argv[i], "copy") == 0) {
                    cli_mode = INSTALL_MODE_COPY;
                } else if (strcmp(argv[i], "system") == 0) {
                    cli_mode = INSTALL_MODE_SYSTEM;
                } else {
                    fprintf(stderr, "Error: Invalid mode '%s'. Use: symlink, copy, or system\n", argv[i]);
                    return 1;
                }
                has_cli_mode = true;
            } else {
                fprintf(stderr, "Error: --mode requires an argument\n");
                return 1;
            }
        } else if (strcmp(argv[i], "--target") == 0) {
            if (i + 1 < argc) {
                i++;
                target_override = argv[i];
            } else {
                fprintf(stderr, "Error: --target requires an argument\n");
                return 1;
            }
        }
    }

    // Load config
    KryonConfig* config = config_find_and_load();
    if (!config) {
        fprintf(stderr, "Error: No kryon.toml found in current directory\n");
        return 1;
    }

    if (!config_validate(config)) {
        config_free(config);
        return 1;
    }

    // Get install config (use defaults if not specified)
    InstallConfig* install = config->install;
    bool install_is_default = false;
    if (!install) {
        install = get_default_install_config(config->project_name);
        if (!install) {
            fprintf(stderr, "Error: Failed to create install config\n");
            config_free(config);
            return 1;
        }
        install_is_default = true;
    }

    // Use CLI mode if specified
    if (has_cli_mode) {
        install->mode = cli_mode;
    }

    // Auto-build before installing (unless --no-build is specified)
    if (!no_build && !dry_run) {
        printf("Building project...\n");
        int build_result = cmd_build(0, NULL);
        if (build_result != 0) {
            fprintf(stderr, "Error: Build failed. Aborting install.\n");
            fprintf(stderr, "       Fix build errors or use --no-build to install existing binary.\n");
            if (install != config->install) {
                free(install->binary_path);
                free(install->binary_name);
                free(install->desktop.name);
                free(install);
            }
            config_free(config);
            return 1;
        }
        printf("Build complete!\n\n");
    } else if (!no_build && dry_run) {
        printf("[DRY RUN] Would build project first (use --no-build to skip)\n");
    }

    // Determine which target to install
    const char* target = get_install_target(config, target_override, install);

    // Detect frontend from entry file
    const char* frontend = detect_frontend_from_entry(config->build_entry);
    if (!frontend) {
        // Try to detect from config
        fprintf(stderr, "Warning: Could not detect frontend type from entry file\n");
    }

    // Print install info
    printf("Installing %s %s...\n", config->project_name, config->project_version);
    printf("  Target: %s\n", target);
    if (frontend) {
        printf("  Frontend: %s\n", frontend);
    }

    const char* mode_str = install->mode == INSTALL_MODE_SYMLINK ? "symlink" :
                          install->mode == INSTALL_MODE_COPY ? "copy" : "system";
    printf("  Mode: %s\n", mode_str);

    // Check for system mode
    if (install->mode == INSTALL_MODE_SYSTEM && geteuid() != 0) {
        fprintf(stderr, "Error: system mode requires root privileges. Use sudo.\n");
        if (install != config->install) {
            free(install->binary_path);
            free(install->binary_name);
            free(install->desktop.name);
            free(install);
        }
        config_free(config);
        return 1;
    }

    // Get current working directory (project directory)
    char* project_dir = dir_get_current();

    // Check if target supports installation using capability check
    if (!target_has_capability(target, TARGET_CAN_INSTALL)) {
        fprintf(stderr, "Error: Target '%s' cannot be installed as a command.\n", target);
        fprintf(stderr, "       This target type is meant for deployment or runtime only.\n");
        fprintf(stderr, "       Use 'kryon run' to test locally, or deploy the output directory.\n");
        free(project_dir);
        if (install != config->install) {
            free(install->binary_path);
            free(install->binary_name);
            free(install->desktop.name);
            free(install);
        }
        config_free(config);
        return 1;
    }

    // For Kry desktop apps, check for compiled binary or create wrapper
    bool is_kry_app = (frontend && strcmp(frontend, "kry") == 0);
    bool is_c_app = (frontend && strcmp(frontend, "c") == 0);

    char* source_path = NULL;
    char* wrapper_path = NULL;

    if (is_kry_app) {
        // First, check if there's a compiled binary from kryon build
        char* build_output_dir = config->build_output_dir ?
                                 str_copy(config->build_output_dir) : str_copy("dist");
        char build_binary_path[PATH_MAX];
        snprintf(build_binary_path, sizeof(build_binary_path), "%s/%s",
                 build_output_dir, config->project_name);

        if (file_exists(build_binary_path)) {
            printf("  Found compiled binary: %s\n", build_binary_path);
            source_path = realpath(build_binary_path, NULL);
            if (!source_path) {
                fprintf(stderr, "Error: Cannot resolve build output path: %s\n", build_binary_path);
                free(build_output_dir);
                free(project_dir);
                if (install != config->install) {
                    free(install->binary_path);
                    free(install->binary_name);
                    free(install->desktop.name);
                    free(install);
                }
                config_free(config);
                return 1;
            }
            free(build_output_dir);
        } else {
            free(build_output_dir);
            // No compiled binary found, create wrapper script for Kry apps
            printf("  No compiled binary found, creating wrapper script...\n");

            // Get XDG data directory for wrapper
            const char* xdg_data = getenv("XDG_DATA_HOME");
            char* apps_root;
            if (xdg_data && strlen(xdg_data) > 0) {
                apps_root = path_join(xdg_data, "kryon/apps");
            } else {
                char* home = paths_get_home_dir();
                apps_root = path_join(home, ".local/share/kryon/apps");
                free(home);
            }

            // Create project-specific directory
            char* app_dir = path_join(apps_root, config->project_name);
            dir_create_recursive(app_dir);

            // Wrapper path
            wrapper_path = path_join(app_dir, "wrapper.sh");

            if (!dry_run) {
                if (!create_kry_wrapper(project_dir, config->build_entry, wrapper_path, config->project_name)) {
                    fprintf(stderr, "Error: Failed to create wrapper script\n");
                    free(project_dir);
                    free(apps_root);
                    free(app_dir);
                    if (install != config->install) {
                        free(install->binary_path);
                        free(install->binary_name);
                        free(install->desktop.name);
                        free(install);
                    }
                    config_free(config);
                    return 1;
                }
                printf("  Created wrapper: %s\n", wrapper_path);
            } else {
                printf("  [DRY RUN] Would create wrapper: %s\n", wrapper_path);
            }

            source_path = wrapper_path;
            wrapper_path = NULL;  // Mark as owned by source_path

            free(apps_root);
            free(app_dir);
        }
    } else if (is_c_app) {
        // For C apps, look for compiled binary
        char* build_output_dir = config->build_output_dir ?
                                 str_copy(config->build_output_dir) : str_copy("build");
        char build_binary_path[PATH_MAX];
        snprintf(build_binary_path, sizeof(build_binary_path), "%s/%s",
                 build_output_dir, config->project_name);

        if (!file_exists(build_binary_path)) {
            fprintf(stderr, "Error: Build output not found: %s\n", build_binary_path);
            fprintf(stderr, "       Run 'kryon build' first or compile your C application\n");
            free(build_output_dir);
            free(project_dir);
            if (install != config->install) {
                free(install->binary_path);
                free(install->binary_name);
                free(install->desktop.name);
                free(install);
            }
            config_free(config);
            return 1;
        }

        source_path = realpath(build_binary_path, NULL);
        if (!source_path) {
            fprintf(stderr, "Error: Cannot resolve build output path: %s\n", build_binary_path);
            free(build_output_dir);
            free(project_dir);
            if (install != config->install) {
                free(install->binary_path);
                free(install->binary_name);
                free(install->desktop.name);
                free(install);
            }
            config_free(config);
            return 1;
        }

        free(build_output_dir);
    } else {
        fprintf(stderr, "Error: Unsupported frontend for installation: %s\n", frontend ? frontend : "unknown");
        fprintf(stderr, "       Only kry and c frontends are supported.\n");
        free(project_dir);
        if (install != config->install) {
            free(install->binary_path);
            free(install->binary_name);
            free(install->desktop.name);
            free(install);
        }
        config_free(config);
        return 1;
    }

    // Expand install path
    char* install_dir = path_expand_env_vars(install->binary_path);

    // For system mode, use /usr/local/bin
    if (install->mode == INSTALL_MODE_SYSTEM) {
        free(install_dir);
        install_dir = str_copy("/usr/local/bin");
    }

    // Create install directory if needed
    if (!dry_run && !dir_create_recursive(install_dir)) {
        fprintf(stderr, "Error: Failed to create install directory: %s\n", install_dir);
        free(source_path);
        if (wrapper_path) free(wrapper_path);
        free(project_dir);
        free(install_dir);
        if (install != config->install) {
            free(install->binary_path);
            free(install->binary_name);
            free(install->desktop.name);
            free(install);
        }
        config_free(config);
        return 1;
    }

    // Install binary/wrapper
    char install_binary_path[PATH_MAX];
    snprintf(install_binary_path, sizeof(install_binary_path), "%s/%s",
             install_dir, install->binary_name);

    printf("  Installing: %s\n", install_binary_path);

    if (!dry_run) {
        bool success = false;
        if (install->mode == INSTALL_MODE_SYMLINK) {
            success = create_symlink(source_path, install_binary_path);
        } else {
            success = copy_file(source_path, install_binary_path);
        }

        if (!success) {
            free(source_path);
            if (wrapper_path) free(wrapper_path);
            free(project_dir);
            free(install_dir);
            if (install != config->install) {
                free(install->binary_path);
                free(install->binary_name);
                free(install->desktop.name);
                free(install);
            }
            config_free(config);
            return 1;
        }
    } else {
        printf("  [DRY RUN] Would install: %s\n", install_binary_path);
        printf("  [DRY RUN] From: %s\n", source_path);
    }

    // Create desktop entry if enabled
    bool has_desktop = false;
    if (install->desktop.enabled) {
        printf("  Creating desktop entry...\n");
        if (!dry_run) {
            has_desktop = create_desktop_entry(
                config->project_name,
                install->binary_name,
                install->desktop.name,
                install->desktop.icon,
                install->desktop.categories,
                install->desktop.categories_count
            );
        } else {
            printf("  [DRY RUN] Would create desktop entry\n");
            has_desktop = true;
        }
    }

    // Write install manifest
    if (!dry_run) {
        write_install_manifest(
            config->project_name,
            config->project_version,
            install_dir,
            install->binary_name,
            wrapper_path,
            config->build_entry,
            target,
            frontend,
            install->mode,
            has_desktop
        );
    }

    // Save binary name for final message (before cleanup)
    char* binary_name_to_show = str_copy(install->binary_name);

    // Cleanup
    free(source_path);
    free(project_dir);
    free(install_dir);
    // Only free the install config if we created a default one
    if (install_is_default) {
        free(install->binary_path);
        free(install->binary_name);
        free(install->desktop.name);
        free(install);
    }
    config_free(config);

    printf("Installation complete!\n");
    printf("Run '%s' to start your application.\n", binary_name_to_show);
    free(binary_name_to_show);

    return 0;
}
