/**
 * TSX Code Generator
 * Generates TypeScript React components from KIR JSON
 */

#include "tsx_codegen.h"
#include "../codegen_common.h"
// #include "codegen_common.h" - use ../codegen_common.h instead
#include "../../third_party/cJSON/cJSON.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char* tsx_codegen_from_json(const char* kir_json) {
    if (!kir_json) return NULL;

    // Parse JSON
    cJSON* root = cJSON_Parse(kir_json);
    if (!root) {
        fprintf(stderr, "Error: Failed to parse KIR JSON\n");
        return NULL;
    }

    // Build React context with TypeScript mode
    ReactContext ctx = {
        .mode = REACT_MODE_TYPESCRIPT,
        .logic_functions = NULL,
        .event_bindings = NULL,
        .indent_level = 0
    };

    // Extract logic functions if present (support both old "logic" and new "logic_block")
    cJSON* logic = cJSON_GetObjectItem(root, "logic_block");
    if (!logic) {
        logic = cJSON_GetObjectItem(root, "logic");  // Fallback to old format
    }

    if (logic && cJSON_IsObject(logic)) {
        ctx.logic_functions = cJSON_GetObjectItem(logic, "functions");
        ctx.event_bindings = cJSON_GetObjectItem(logic, "event_bindings");
    }

    // Get root component
    cJSON* component = cJSON_GetObjectItem(root, "root");
    if (!component) component = cJSON_GetObjectItem(root, "component");
    if (!component) component = root;

    // Extract window configuration from "app" section first, then fallback to component
    cJSON* app_section = cJSON_GetObjectItem(root, "app");
    WindowConfig win_config = react_extract_window_config(app_section ? app_section : component);

    // If background wasn't set from app section, try to get it from root component
    if (app_section && (!win_config.background || strcmp(win_config.background, "#1E1E1E") == 0)) {
        cJSON* bg = cJSON_GetObjectItem(component, "background");
        if (bg && cJSON_IsString(bg)) {
            free(win_config.background);
            win_config.background = strdup(cJSON_GetStringValue(bg));
        }
    }

    // Get reactive manifest for state hooks
    cJSON* manifest = cJSON_GetObjectItem(root, "reactive_manifest");

    // Start generating TSX
    StringBuilder* sb = sb_create(8192);

    // Add header
    sb_append(sb, "// Generated by Kryon Code Generator (TypeScript React-Hooks Style)\n\n");
    sb_append(sb, react_generate_imports(ctx.mode));
    sb_append(sb, "\n\n");

    // Generate state hooks if there's a reactive manifest
    char* state_hooks = react_generate_state_hooks(manifest, &ctx);

    // Generate main app export
    sb_append(sb, "export default kryonApp({\n");
    sb_append_fmt(sb, "  width: %d,\n", win_config.width);
    sb_append_fmt(sb, "  height: %d,\n", win_config.height);
    sb_append_fmt(sb, "  title: \"%s\",\n", win_config.title);
    sb_append_fmt(sb, "  background: \"%s\",\n\n", win_config.background);

    sb_append(sb, "  render: () => {\n");

    // Add state hooks inside render
    if (state_hooks && strlen(state_hooks) > 0) {
        sb_append(sb, state_hooks);
        sb_append(sb, "\n");
    }

    sb_append(sb, "    return (\n");

    // Check if root is a simple Container with background - if so, generate only its children
    // to avoid redundancy (kryonApp already handles the background)
    cJSON* root_type = cJSON_GetObjectItem(component, "type");
    cJSON* root_children = cJSON_GetObjectItem(component, "children");
    bool is_simple_container = root_type && cJSON_IsString(root_type) &&
                               strcmp(cJSON_GetStringValue(root_type), "Container") == 0 &&
                               root_children && cJSON_IsArray(root_children);

    if (is_simple_container && cJSON_GetArraySize(root_children) == 1) {
        // Generate only the child element
        cJSON* child = cJSON_GetArrayItem(root_children, 0);
        char* child_elem = react_generate_element(child, &ctx, 3);
        sb_append(sb, child_elem);
        free(child_elem);
    } else {
        // Generate full root element
        char* root_elem = react_generate_element(component, &ctx, 3);
        sb_append(sb, root_elem);
        free(root_elem);
    }

    sb_append(sb, "\n    );\n");
    sb_append(sb, "  }\n");
    sb_append(sb, "});\n");

    // Clean up
    free(state_hooks);
    react_free_window_config(&win_config);
    cJSON_Delete(root);

    char* result = strdup(sb_get(sb));
    sb_free(sb);
    return result;
}

bool tsx_codegen_generate(const char* kir_path, const char* output_path) {
    if (!kir_path || !output_path) return false;

    // Set error prefix for this codegen
    codegen_set_error_prefix("TSX");

    // Read KIR file using shared utility
    char* kir_json = codegen_read_kir_file(kir_path, NULL);
    if (!kir_json) {
        return false;
    }

    // Generate TSX code
    char* tsx_code = tsx_codegen_from_json(kir_json);
    free(kir_json);

    if (!tsx_code) {
        return false;
    }

    // Write output using shared utility
    bool success = codegen_write_output_file(output_path, tsx_code);
    free(tsx_code);

    if (success) {
        printf("✓ Generated TSX code: %s\n", output_path);
    }
    return success;
}

bool tsx_codegen_generate_with_options(const char* kir_path,
                                        const char* output_path,
                                        TsxCodegenOptions* options) {
    if (!kir_path || !output_path) {
        return false;
    }

    // Use defaults if no options provided
    TsxCodegenOptions default_opts = {
        .format = true,
        .use_prettier = false,
        .semicolons = true
    };
    if (!options) {
        options = &default_opts;
    }

    // Set error prefix for this codegen
    codegen_set_error_prefix("TSX");

    // Read KIR file using shared utility
    char* kir_json = codegen_read_kir_file(kir_path, NULL);
    if (!kir_json) {
        return false;
    }

    // Generate TSX code
    char* tsx_code = tsx_codegen_from_json(kir_json);
    free(kir_json);

    if (!tsx_code) {
        return false;
    }

    // Write output using shared utility
    bool success = codegen_write_output_file(output_path, tsx_code);
    free(tsx_code);

    if (!success) {
        return false;
    }

    printf("✓ Generated TSX code: %s\n", output_path);

    // Apply formatting if requested
    if (options->use_prettier) {
        char cmd[2048];
        snprintf(cmd, sizeof(cmd), "prettier --write \"%s\" 2>/dev/null", output_path);
        int result = system(cmd);
        if (result == 0) {
            printf("  Formatted with Prettier\n");
        }
    }

    // Note: semicolons option would affect generation in tsx_codegen_from_json
    // For now, TypeScript style defaults to including semicolons

    return true;
}

/**
 * Convert module_id like "components/calendar" to PascalCase "Calendar"
 */
static char* tsx_module_to_component_name(const char* module_id) {
    if (!module_id) return strdup("Component");

    // Find the last part after the final slash
    const char* name_start = strrchr(module_id, '/');
    if (name_start) {
        name_start++;  // Skip the slash
    } else {
        name_start = module_id;
    }

    // Allocate and copy
    char* result = strdup(name_start);
    if (!result) return strdup("Component");

    // Capitalize first letter (simple PascalCase)
    if (result[0] >= 'a' && result[0] <= 'z') {
        result[0] = result[0] - 'a' + 'A';
    }

    return result;
}

/**
 * Recursively process a module and its transitive imports for TSX
 */
static int tsx_process_module_recursive(const char* module_id, const char* kir_dir,
                                        const char* output_dir, CodegenProcessedModules* processed,
                                        char** export_entries, int* export_count) {
    // Skip if already processed
    if (codegen_processed_modules_contains(processed, module_id)) return 0;
    codegen_processed_modules_add(processed, module_id);

    // Skip internal modules
    if (codegen_is_internal_module(module_id)) return 0;

    // Skip external plugins (they're runtime dependencies, not source)
    if (codegen_is_external_plugin(module_id)) return 0;

    // Build path to component's KIR file
    char component_kir_path[2048];
    snprintf(component_kir_path, sizeof(component_kir_path),
             "%s/%s.kir", kir_dir, module_id);

    // Read component's KIR
    char* component_kir_json = codegen_read_kir_file(component_kir_path, NULL);
    if (!component_kir_json) {
        fprintf(stderr, "Warning: Cannot find KIR for '%s' at %s\n",
                module_id, component_kir_path);
        return 0;
    }

    // Parse to get transitive imports before generating
    cJSON* component_root = cJSON_Parse(component_kir_json);
    int files_written = 0;

    // Generate TSX from KIR
    char* component_tsx = tsx_codegen_from_json(component_kir_json);
    free(component_kir_json);

    if (component_tsx) {
        // Get component name from module_id
        char* component_name = tsx_module_to_component_name(module_id);

        // Write to output directory maintaining hierarchy
        char output_path[2048];
        snprintf(output_path, sizeof(output_path),
                 "%s/%s.tsx", output_dir, module_id);

        if (codegen_write_file_with_mkdir(output_path, component_tsx)) {
            printf("✓ Generated: %s.tsx\n", module_id);
            files_written++;

            // Add to barrel export entries
            if (export_entries && export_count && *export_count < 256) {
                char export_entry[512];
                snprintf(export_entry, sizeof(export_entry),
                         "export { default as %s } from './%s';\n", component_name, module_id);
                export_entries[*export_count] = strdup(export_entry);
                (*export_count)++;
            }

            // Create index.ts in component's directory if it's nested
            char* slash = strrchr(output_path, '/');
            if (slash) {
                // Check if there's a parent directory different from output_dir
                char dir_path[2048];
                size_t dir_len = (size_t)(slash - output_path);
                strncpy(dir_path, output_path, dir_len);
                dir_path[dir_len] = '\0';

                // Only create index.ts if this is a subdirectory
                if (strlen(dir_path) > strlen(output_dir)) {
                    char index_path[2048];
                    snprintf(index_path, sizeof(index_path), "%s/index.ts", dir_path);

                    if (!codegen_file_exists(index_path)) {
                        char index_content[1024];
                        snprintf(index_content, sizeof(index_content),
                                 "// Auto-generated barrel export\nexport { default as %s } from './%s';\n",
                                 component_name, strrchr(module_id, '/') ? strrchr(module_id, '/') + 1 : module_id);
                        codegen_write_file_with_mkdir(index_path, index_content);
                    }
                }
            }
        }

        free(component_name);
        free(component_tsx);
    } else {
        fprintf(stderr, "Warning: Failed to generate TSX for '%s'\n", module_id);
    }

    // Process transitive imports from this component
    if (component_root) {
        cJSON* imports = cJSON_GetObjectItem(component_root, "imports");
        if (imports && cJSON_IsArray(imports)) {
            cJSON* import_item = NULL;
            cJSON_ArrayForEach(import_item, imports) {
                if (!cJSON_IsString(import_item)) continue;
                const char* sub_module_id = cJSON_GetStringValue(import_item);
                if (sub_module_id) {
                    files_written += tsx_process_module_recursive(sub_module_id, kir_dir,
                                                                  output_dir, processed,
                                                                  export_entries, export_count);
                }
            }
        }
        cJSON_Delete(component_root);
    }

    return files_written;
}

bool tsx_codegen_generate_multi(const char* kir_path, const char* output_dir) {
    if (!kir_path || !output_dir) {
        fprintf(stderr, "Error: Invalid arguments to tsx_codegen_generate_multi\n");
        return false;
    }

    // Set error prefix for this codegen
    codegen_set_error_prefix("TSX");

    // Read main KIR file
    char* main_kir_json = codegen_read_kir_file(kir_path, NULL);
    if (!main_kir_json) {
        return false;
    }

    // Parse main KIR JSON
    cJSON* main_root = cJSON_Parse(main_kir_json);
    if (!main_root) {
        fprintf(stderr, "Error: Failed to parse main KIR JSON\n");
        free(main_kir_json);
        return false;
    }

    // Create output directory if it doesn't exist
    if (!codegen_mkdir_p(output_dir)) {
        fprintf(stderr, "Error: Could not create output directory: %s\n", output_dir);
        cJSON_Delete(main_root);
        free(main_kir_json);
        return false;
    }

    int files_written = 0;

    // Track barrel export entries for index.ts
    char* export_entries[256] = {0};
    int export_count = 0;

    // 1. Generate App.tsx from main.kir
    char* main_tsx = tsx_codegen_from_json(main_kir_json);
    free(main_kir_json);

    if (main_tsx) {
        char main_output_path[2048];
        snprintf(main_output_path, sizeof(main_output_path), "%s/App.tsx", output_dir);

        if (codegen_write_file_with_mkdir(main_output_path, main_tsx)) {
            printf("✓ Generated: App.tsx\n");
            files_written++;
        }
        free(main_tsx);
    } else {
        fprintf(stderr, "Warning: Failed to generate App.tsx from KIR\n");
    }

    // 2. Get the KIR directory (parent of kir_path)
    char kir_dir[2048];
    codegen_get_parent_dir(kir_path, kir_dir, sizeof(kir_dir));

    // 3. Track processed modules to avoid duplicates
    CodegenProcessedModules processed = {0};
    codegen_processed_modules_add(&processed, "main");  // Mark main as processed

    // 4. Process each import recursively (including transitive imports)
    cJSON* imports = cJSON_GetObjectItem(main_root, "imports");
    if (imports && cJSON_IsArray(imports)) {
        cJSON* import_item = NULL;
        cJSON_ArrayForEach(import_item, imports) {
            if (!cJSON_IsString(import_item)) continue;

            const char* module_id = cJSON_GetStringValue(import_item);
            if (module_id) {
                files_written += tsx_process_module_recursive(module_id, kir_dir,
                                                              output_dir, &processed,
                                                              export_entries, &export_count);
            }
        }
    }

    // 5. Generate root index.ts with all exports
    char index_path[2048];
    snprintf(index_path, sizeof(index_path), "%s/index.ts", output_dir);

    FILE* f = fopen(index_path, "w");
    if (f) {
        fprintf(f, "// Auto-generated barrel exports\n");
        fprintf(f, "export { default } from './App';\n");
        for (int i = 0; i < export_count; i++) {
            fprintf(f, "%s", export_entries[i]);
            free(export_entries[i]);
        }
        fclose(f);
        printf("✓ Generated: index.ts\n");
    }

    codegen_processed_modules_free(&processed);
    cJSON_Delete(main_root);

    if (files_written == 0) {
        fprintf(stderr, "Warning: No TSX files were generated\n");
        return false;
    }

    printf("✓ Generated %d TSX files in %s\n", files_written, output_dir);
    return true;
}
