/**
 * C Code Generator - Multi-Module Support
 */

#define _DEFAULT_SOURCE

#include "ir_c_modules.h"
#include "ir_c_codegen.h"
#include "../../third_party/cJSON/cJSON.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

char* c_module_to_guard_name(const char* module_id) {
    if (!module_id) return strdup("COMPONENT_H");

    size_t len = strlen(module_id);
    char* result = malloc(len + 3);  // _H\0
    if (!result) return strdup("COMPONENT_H");

    for (size_t i = 0; i < len; i++) {
        if (module_id[i] == '/') {
            result[i] = '_';
        } else if (module_id[i] >= 'a' && module_id[i] <= 'z') {
            result[i] = module_id[i] - 'a' + 'A';  // To uppercase
        } else {
            result[i] = module_id[i];
        }
    }
    result[len] = '_';
    result[len + 1] = 'H';
    result[len + 2] = '\0';

    return result;
}

/**
 * Generate a header file (.h) for a C component
 */
bool c_generate_header_file(const char* module_id, const char* output_dir) {
    char* guard_name = c_module_to_guard_name(module_id);

    char header_path[2048];
    snprintf(header_path, sizeof(header_path), "%s/%s.h", output_dir, module_id);

    // Generate header content
    char header_content[4096];
    snprintf(header_content, sizeof(header_content),
             "/**\n"
             " * %s - Auto-generated header\n"
             " * Generated by Kryon C Code Generator\n"
             " */\n\n"
             "#ifndef %s\n"
             "#define %s\n\n"
             "#include <kryon.h>\n"
             "#include <kryon_dsl.h>\n\n"
             "// Component declaration\n"
             "IRComponent* %s_create(void);\n\n"
             "#endif // %s\n",
             module_id, guard_name, guard_name,
             strrchr(module_id, '/') ? strrchr(module_id, '/') + 1 : module_id,
             guard_name);

    bool result = codegen_write_file_with_mkdir(header_path, header_content);

    free(guard_name);
    return result;
}

/**
 * Recursively process a module and its transitive imports for C
 */
int c_process_module_recursive(const char* module_id, const char* kir_dir,
                                      const char* output_dir, CodegenProcessedModules* processed) {
    // Skip if already processed
    if (codegen_processed_modules_contains(processed, module_id)) return 0;
    codegen_processed_modules_add(processed, module_id);

    // Skip internal modules
    if (codegen_is_internal_module(module_id)) return 0;

    // Skip external plugins (they're runtime dependencies, not source)
    if (codegen_is_external_plugin(module_id)) return 0;

    // Build path to component's KIR file
    char component_kir_path[2048];
    snprintf(component_kir_path, sizeof(component_kir_path),
             "%s/%s.kir", kir_dir, module_id);

    // Read component's KIR
    char* component_kir_json = codegen_read_kir_file(component_kir_path, NULL);
    if (!component_kir_json) {
        fprintf(stderr, "Warning: Cannot find KIR for '%s' at %s\n",
                module_id, component_kir_path);
        return 0;
    }

    // Parse to get transitive imports before generating
    cJSON* component_root = cJSON_Parse(component_kir_json);
    int files_written = 0;

    // Generate C source file
    char c_output_path[2048];
    snprintf(c_output_path, sizeof(c_output_path), "%s/%s.c", output_dir, module_id);

    // Create parent directories if needed (e.g., for components/habit_panel.c)
    char* dir_copy = strdup(c_output_path);
    if (dir_copy) {
        char* last_slash = strrchr(dir_copy, '/');
        if (last_slash) {
            *last_slash = '\0';
            codegen_mkdir_p(dir_copy);
        }
        free(dir_copy);
    }

    if (ir_generate_c_code_from_string(component_kir_json, c_output_path)) {
        printf("✓ Generated: %s.c\n", module_id);
        files_written++;

        // Also generate header file
        if (c_generate_header_file(module_id, output_dir)) {
            printf("✓ Generated: %s.h\n", module_id);
            files_written++;
        }
    } else {
        fprintf(stderr, "Warning: Failed to generate C code for '%s'\n", module_id);
    }

    free(component_kir_json);

    // Process transitive imports from this component
    // Imports are in source_structures.requires[].module
    if (component_root) {
        cJSON* source_structures = cJSON_GetObjectItem(component_root, "source_structures");
        cJSON* requires = source_structures ? cJSON_GetObjectItem(source_structures, "requires") : NULL;
        if (requires && cJSON_IsArray(requires)) {
            cJSON* import_item = NULL;
            cJSON_ArrayForEach(import_item, requires) {
                cJSON* module_obj = cJSON_GetObjectItem(import_item, "module");
                if (!module_obj || !cJSON_IsString(module_obj)) continue;
                const char* module_path = cJSON_GetStringValue(module_obj);
                if (module_path) {
                    // Convert module path to file path format
                    char sub_module_id[512];
                    strncpy(sub_module_id, module_path, sizeof(sub_module_id) - 1);
                    sub_module_id[sizeof(sub_module_id) - 1] = '\0';
                    for (char* p = sub_module_id; *p; p++) {
                        if (*p == '.') *p = '/';
                    }
                    files_written += c_process_module_recursive(sub_module_id, kir_dir,
                                                                output_dir, processed);
                }
            }
        }
        cJSON_Delete(component_root);
    }

    return files_written;
}
