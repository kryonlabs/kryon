/**
 * C Code Generator - KIR → C Source Code
 *
 * Generates idiomatic C code with Kryon DSL from KIR JSON files
 */

#include "ir_c_codegen.h"
#include "ir_c_internal.h"
#include "ir_c_output.h"
#include "ir_c_types.h"
#include "ir_c_reactive.h"
#include "ir_c_expression.h"
#include "ir_c_components.h"
#include "ir_c_main.h"
#include "ir_c_modules.h"
#include "../codegen_common.h"
#include "../../ir/src/utils/ir_c_metadata.h"
#include "../../third_party/cJSON/cJSON.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <ctype.h>

// ============================================================================
// Internal Aliases for Utility Functions
// ============================================================================

// These aliases allow existing code to use the shorter names
#define write_indent(ctx) c_write_indent(ctx)
#define writeln(ctx, str) c_writeln(ctx, str)
#define write_raw(ctx, str) c_write_raw(ctx, str)

// Reactive function aliases
#define is_reactive_variable(ctx, name) c_is_reactive_variable(ctx, name)
#define get_scoped_var_name(ctx, name) c_get_scoped_var_name(ctx, name)
#define generate_scoped_var_name(name, scope) c_generate_scoped_var_name(name, scope)
#define get_signal_creator(type) c_get_signal_creator(type)
#define generate_reactive_signal_declarations(ctx) c_generate_reactive_signal_declarations(ctx)
#define generate_reactive_signal_initialization(ctx) c_generate_reactive_signal_initialization(ctx)
#define generate_reactive_signal_cleanup(ctx) c_generate_reactive_signal_cleanup(ctx)

// Expression/statement function aliases (from ir_c_expression.h)
#define is_range_call(expr, start, end) c_is_range_call(expr, start, end)
#define expr_to_c(expr) c_expr_to_c(expr)
#define stmt_to_c(output, stmt, indent, path) c_stmt_to_c(output, stmt, indent, path)

// Component generation aliases (from ir_c_components.h)
#define generate_component_recursive(ctx, comp, root) c_generate_component_recursive(ctx, comp, root)
#define generate_property_macro(ctx, key, val, first) c_generate_property_macro(ctx, key, val, first)
#define generate_component_definitions(ctx, defs) c_generate_component_definitions(ctx, defs)

// Main/struct generation aliases (from ir_c_main.h)
#define generate_struct_definitions(ctx, types) c_generate_struct_definitions(ctx, types)
#define generate_main_function(ctx) c_generate_main_function(ctx)

// ============================================================================
// Utility Functions
// ============================================================================

// get_variable_for_component_id moved to ir_c_components.c
// get_component_macro moved to ir_c_types.c

// ============================================================================
// Header Generation
// ============================================================================

void generate_includes(CCodegenContext* ctx) {
    fprintf(ctx->output, "/**\n");
    fprintf(ctx->output, " * Auto-generated C code from .kir file\n");
    fprintf(ctx->output, " * Generated by Kryon C Code Generator\n");
    fprintf(ctx->output, " */\n\n");

    // Check if we need reactive includes
    bool needs_reactive = ctx->has_reactive_state;

    // Generate includes from metadata
    if (ctx->includes && cJSON_IsArray(ctx->includes)) {
        int count = cJSON_GetArraySize(ctx->includes);
        for (int i = 0; i < count; i++) {
            cJSON* inc = cJSON_GetArrayItem(ctx->includes, i);
            cJSON* include_str = cJSON_GetObjectItem(inc, "include");
            if (include_str && include_str->valuestring) {
                fprintf(ctx->output, "#include %s\n", include_str->valuestring);
            }
        }
    } else {
        // Default includes if no metadata
        fprintf(ctx->output, "#include <kryon.h>\n");
        fprintf(ctx->output, "#include <kryon_dsl.h>\n");
        if (needs_reactive) {
            fprintf(ctx->output, "#include <kryon_reactive.h>\n");
            fprintf(ctx->output, "#include <kryon_reactive_ui.h>\n");
        }
        fprintf(ctx->output, "#include <stdio.h>\n");
        fprintf(ctx->output, "#include <stdbool.h>\n");
    }

    // ALWAYS add reactive headers if needed (even if metadata has includes)
    if (needs_reactive && ctx->includes && cJSON_IsArray(ctx->includes)) {
        bool has_reactive_headers = false;
        int count = cJSON_GetArraySize(ctx->includes);
        for (int i = 0; i < count; i++) {
            cJSON* inc = cJSON_GetArrayItem(ctx->includes, i);
            cJSON* include_str = cJSON_GetObjectItem(inc, "include");
            if (include_str && include_str->valuestring) {
                if (strstr(include_str->valuestring, "kryon_reactive") != NULL) {
                    has_reactive_headers = true;
                    break;
                }
            }
        }
        if (!has_reactive_headers) {
            fprintf(ctx->output, "#include <kryon_reactive.h>\n");
            fprintf(ctx->output, "#include <kryon_reactive_ui.h>\n");
        }
    }
    fprintf(ctx->output, "\n");
}

void generate_preprocessor_directives(CCodegenContext* ctx) {
    if (!ctx->preprocessor_dirs || !cJSON_IsArray(ctx->preprocessor_dirs)) {
        return;
    }

    int count = cJSON_GetArraySize(ctx->preprocessor_dirs);
    if (count == 0) return;

    for (int i = 0; i < count; i++) {
        cJSON* dir = cJSON_GetArrayItem(ctx->preprocessor_dirs, i);
        cJSON* type = cJSON_GetObjectItem(dir, "directive_type");
        cJSON* condition = cJSON_GetObjectItem(dir, "condition");
        cJSON* value = cJSON_GetObjectItem(dir, "value");

        if (!type || !type->valuestring) continue;

        if (strcmp(type->valuestring, "define") == 0) {
            fprintf(ctx->output, "#define ");
            if (condition && condition->valuestring) {
                fprintf(ctx->output, "%s ", condition->valuestring);
            }
            if (value && value->valuestring) {
                fprintf(ctx->output, "%s", value->valuestring);
            }
            fprintf(ctx->output, "\n");
        } else if (strcmp(type->valuestring, "ifdef") == 0 && condition && condition->valuestring) {
            fprintf(ctx->output, "#ifdef %s\n", condition->valuestring);
        } else if (strcmp(type->valuestring, "ifndef") == 0 && condition && condition->valuestring) {
            fprintf(ctx->output, "#ifndef %s\n", condition->valuestring);
        } else if (strcmp(type->valuestring, "if") == 0 && condition && condition->valuestring) {
            fprintf(ctx->output, "#if %s\n", condition->valuestring);
        } else if (strcmp(type->valuestring, "elif") == 0 && condition && condition->valuestring) {
            fprintf(ctx->output, "#elif %s\n", condition->valuestring);
        } else if (strcmp(type->valuestring, "else") == 0) {
            fprintf(ctx->output, "#else\n");
        } else if (strcmp(type->valuestring, "endif") == 0) {
            fprintf(ctx->output, "#endif\n");
        }
    }
    fprintf(ctx->output, "\n");
}

// Note: Expression/statement conversion functions (expr_to_c, stmt_to_c, is_range_call)
// are now in ir_c_expression.c and accessed via macros defined above.

// is_range_call removed - now in ir_c_expression.c

/**
 * Generate exported functions from logic_block
 * Returns false on hard error (unsupported constructs)
 */
bool generate_exported_functions(FILE* output, cJSON* logic_block, cJSON* exports, const char* output_path) {
    if (!logic_block || !exports) return true;

    cJSON* functions = cJSON_GetObjectItem(logic_block, "functions");
    if (!functions || !cJSON_IsArray(functions)) return true;

    fprintf(output, "// Exported functions\n");

    // For each export, find and generate the function
    cJSON* export_item;
    cJSON_ArrayForEach(export_item, exports) {
        cJSON* name = cJSON_GetObjectItem(export_item, "name");
        cJSON* type = cJSON_GetObjectItem(export_item, "type");

        if (!name || !cJSON_IsString(name)) continue;
        const char* export_name = name->valuestring;
        const char* export_type = type && cJSON_IsString(type) ? type->valuestring : "";

        // Skip non-function exports
        if (strcmp(export_type, "function") != 0) continue;

        // Find function in logic_block.functions
        cJSON* func;
        bool found = false;
        cJSON_ArrayForEach(func, functions) {
            cJSON* func_name = cJSON_GetObjectItem(func, "name");
            if (!func_name || !cJSON_IsString(func_name)) continue;
            if (strcmp(func_name->valuestring, export_name) != 0) continue;

            found = true;

            // Check for universal statements
            cJSON* universal = cJSON_GetObjectItem(func, "universal");
            if (!universal) {
                fprintf(stderr, "[C Codegen] Error: Exported function '%s' has no universal implementation.\n",
                        export_name);
                fprintf(stderr, "            File: %s\n", output_path ? output_path : "unknown");
                return false;
            }

            cJSON* statements = cJSON_GetObjectItem(universal, "statements");
            if (!statements || !cJSON_IsArray(statements)) {
                // Empty function body - might be just a declaration
                statements = NULL;
            }

            // Get return type and parameters
            cJSON* return_type = cJSON_GetObjectItem(func, "return_type");
            cJSON* params = cJSON_GetObjectItem(func, "params");

            const char* ret_type_str = return_type && cJSON_IsString(return_type) ?
                                       return_type->valuestring : "void";
            const char* c_ret_type = kir_type_to_c(ret_type_str);

            // Generate function signature
            fprintf(output, "\n%s %s(", c_ret_type, export_name);

            // Generate parameters
            if (params && cJSON_IsArray(params) && cJSON_GetArraySize(params) > 0) {
                int param_count = cJSON_GetArraySize(params);
                for (int i = 0; i < param_count; i++) {
                    cJSON* param = cJSON_GetArrayItem(params, i);
                    cJSON* param_name = cJSON_GetObjectItem(param, "name");
                    cJSON* param_type = cJSON_GetObjectItem(param, "type");

                    const char* p_name = param_name && cJSON_IsString(param_name) ?
                                         param_name->valuestring : "arg";
                    const char* p_type = param_type && cJSON_IsString(param_type) ?
                                         param_type->valuestring : "any";

                    if (i > 0) fprintf(output, ", ");
                    fprintf(output, "%s %s", kir_type_to_c(p_type), p_name);
                }
            } else {
                fprintf(output, "void");
            }
            fprintf(output, ") {\n");

            // Generate statements
            if (statements) {
                cJSON* stmt;
                cJSON_ArrayForEach(stmt, statements) {
                    if (!stmt_to_c(output, stmt, 4, output_path)) {
                        return false;  // Hard error
                    }
                }
            }

            fprintf(output, "}\n");
            break;
        }

        if (!found) {
            fprintf(stderr, "[C Codegen] Warning: Exported function '%s' not found in logic_block.\n",
                    export_name);
        }
    }

    return true;
}

// ============================================================================
// Variable & Function Generation
// ============================================================================

void generate_variable_declarations(CCodegenContext* ctx) {
    if (!ctx->variables || !cJSON_IsArray(ctx->variables)) {
        return;
    }

    int count = cJSON_GetArraySize(ctx->variables);
    if (count == 0) return;

    fprintf(ctx->output, "// Component variables\n");
    for (int i = 0; i < count; i++) {
        cJSON* var = cJSON_GetArrayItem(ctx->variables, i);
        cJSON* storage = cJSON_GetObjectItem(var, "storage");
        cJSON* type = cJSON_GetObjectItem(var, "type");
        cJSON* name = cJSON_GetObjectItem(var, "name");
        cJSON* initial = cJSON_GetObjectItem(var, "initial_value");

        if (!name || !name->valuestring || !type || !type->valuestring) continue;

        if (storage && storage->valuestring) {
            fprintf(ctx->output, "%s ", storage->valuestring);
        }
        fprintf(ctx->output, "%s %s", type->valuestring, name->valuestring);

        if (initial && initial->valuestring) {
            fprintf(ctx->output, " = %s", initial->valuestring);
        }
        fprintf(ctx->output, ";\n");
    }
    fprintf(ctx->output, "\n");
}

void generate_helper_functions(CCodegenContext* ctx) {
    if (!ctx->helper_functions || !cJSON_IsArray(ctx->helper_functions)) {
        return;
    }

    int count = cJSON_GetArraySize(ctx->helper_functions);
    if (count == 0) return;

    fprintf(ctx->output, "// Helper functions\n");
    for (int i = 0; i < count; i++) {
        cJSON* func = cJSON_GetArrayItem(ctx->helper_functions, i);
        cJSON* return_type = cJSON_GetObjectItem(func, "return_type");
        cJSON* name = cJSON_GetObjectItem(func, "name");
        cJSON* params = cJSON_GetObjectItem(func, "parameters");
        cJSON* body = cJSON_GetObjectItem(func, "body");

        if (!name || !name->valuestring || !return_type || !return_type->valuestring) continue;

        fprintf(ctx->output, "%s %s(%s) {\n",
                return_type->valuestring,
                name->valuestring,
                (params && params->valuestring) ? params->valuestring : "void");

        if (body && body->valuestring) {
            fprintf(ctx->output, "%s\n", body->valuestring);
        }

        fprintf(ctx->output, "}\n\n");
    }
}

void generate_event_handlers(CCodegenContext* ctx) {
    if (!ctx->event_handlers || !cJSON_IsArray(ctx->event_handlers)) {
        return;
    }

    int count = cJSON_GetArraySize(ctx->event_handlers);
    if (count == 0) return;

    fprintf(ctx->output, "// Event handlers\n");
    for (int i = 0; i < count; i++) {
        cJSON* handler = cJSON_GetArrayItem(ctx->event_handlers, i);
        cJSON* return_type = cJSON_GetObjectItem(handler, "return_type");
        cJSON* name = cJSON_GetObjectItem(handler, "function_name");
        cJSON* params = cJSON_GetObjectItem(handler, "parameters");
        cJSON* body = cJSON_GetObjectItem(handler, "body");

        if (!name || !name->valuestring || !return_type || !return_type->valuestring) continue;

        fprintf(ctx->output, "%s %s(%s) {\n",
                return_type->valuestring,
                name->valuestring,
                (params && params->valuestring) ? params->valuestring : "void");

        if (body && body->valuestring) {
            fprintf(ctx->output, "%s\n", body->valuestring);
        }

        fprintf(ctx->output, "}\n\n");
    }
}

// ============================================================================
// KRY Event Handler Transpilation
// ============================================================================

/**
 * Transpile a KRY expression to C code
 * Handles simple increment/decrement expressions like:
 *   - value += 1  →  kryon_signal_set(value_signal, kryon_signal_get(value_signal) + 1)
 *   - value -= 1  →  kryon_signal_set(value_signal, kryon_signal_get(value_signal) - 1)
 */
static void transpile_kry_expression_to_c(CCodegenContext* ctx, const char* scoped_var_name, const char* op, int delta) {
    if (!scoped_var_name || !op) return;

    fprintf(ctx->output, "    int current_%s = kryon_signal_get(%s_signal);\n", scoped_var_name, scoped_var_name);

    if (strcmp(op, "+=") == 0) {
        fprintf(ctx->output, "    kryon_signal_set(%s_signal, current_%s + %d);\n", scoped_var_name, scoped_var_name, delta);
    } else if (strcmp(op, "-=") == 0) {
        fprintf(ctx->output, "    kryon_signal_set(%s_signal, current_%s - %d);\n", scoped_var_name, scoped_var_name, delta);
    } else if (strcmp(op, "=") == 0) {
        fprintf(ctx->output, "    kryon_signal_set(%s_signal, %d);\n", scoped_var_name, delta);
    }
}

/**
 * Generate C event handler functions from KRY logic_block.functions
 *
 * KIR input (C source from @c blocks):
 *   {
 *     "name": "handleButtonClick",
 *     "sources": [{"language": "c", "source": "void handleButtonClick(void) {\n  printf(...);\n}"}]
 *   }
 *
 * KIR input (KRY lambda):
 *   {
 *     "name": "handler_1_click",
 *     "sources": [{"language": "kry", "source": "() => { value -= 1 }"}]
 *   }
 *
 * C output (from C source): direct code output
 * C output (from KRY lambda): transpiled C code
 */
void c_generate_kry_event_handlers(CCodegenContext* ctx, cJSON* logic_block) {
    if (!logic_block) return;

    cJSON* functions = cJSON_GetObjectItem(logic_block, "functions");
    if (!functions || !cJSON_IsArray(functions)) return;

    int func_count = cJSON_GetArraySize(functions);
    if (func_count == 0) return;

    fprintf(ctx->output, "// Event handlers (transpiled from logic_block)\n");

    cJSON* func;
    cJSON_ArrayForEach(func, functions) {
        cJSON* name = cJSON_GetObjectItem(func, "name");
        cJSON* sources = cJSON_GetObjectItem(func, "sources");
        if (!name || !name->valuestring || !sources || !cJSON_IsArray(sources)) continue;

        // Skip auto-generated top-level code block functions (they contain the @c/@lua/@js blocks)
        // The actual handlers will be extracted from the sources
        if (strncmp(name->valuestring, "_top_level_code_block_", 21) == 0) {
            // Extract the function definitions from these blocks
            for (int i = 0; i < cJSON_GetArraySize(sources); i++) {
                cJSON* src = cJSON_GetArrayItem(sources, i);
                cJSON* lang = cJSON_GetObjectItem(src, "language");
                cJSON* src_item = cJSON_GetObjectItem(src, "source");

                if (lang && lang->valuestring && src_item && src_item->valuestring) {
                    if (strcmp(lang->valuestring, "c") == 0) {
                        // Output C source code directly
                        fprintf(ctx->output, "%s\n", src_item->valuestring);
                    }
                }
            }
            continue;
        }

        // Find C source first (priority over KRY source)
        const char* c_source = NULL;
        const char* kry_source = NULL;

        for (int i = 0; i < cJSON_GetArraySize(sources); i++) {
            cJSON* src = cJSON_GetArrayItem(sources, i);
            cJSON* lang = cJSON_GetObjectItem(src, "language");
            if (!lang || !lang->valuestring) continue;

            cJSON* src_item = cJSON_GetObjectItem(src, "source");
            if (!src_item || !src_item->valuestring) continue;

            if (strcmp(lang->valuestring, "c") == 0) {
                c_source = src_item->valuestring;
                break;  // Found C source, use it
            } else if (strcmp(lang->valuestring, "kry") == 0) {
                kry_source = src_item->valuestring;
            }
        }

        // Output C source directly if found
        if (c_source) {
            fprintf(ctx->output, "%s\n", c_source);
            continue;
        }

        // Fall back to KRY source transpilation
        if (!kry_source) continue;

        // Parse KRY expression to extract variable name, operator, and delta
        char var_name[128] = {0};
        char op[4] = {0};
        int delta = 0;
        bool parsed = false;

        if (sscanf(kry_source, "() => { %127s %3s %d }", var_name, op, &delta) == 3) {
            parsed = true;
        } else if (sscanf(kry_source, "()=>{%127s %3s %d}", var_name, op, &delta) == 3) {
            parsed = true;
        } else {
            // Fallback: try to match += 1 or -= 1 patterns
            if (strstr(kry_source, "+= 1")) {
                const char* start = strchr(kry_source, '{');
                if (start) {
                    start++;
                    while (*start == ' ') start++;
                    const char* end = strstr(start, "+= 1");
                    if (end) {
                        size_t len = end - start;
                        if (len < sizeof(var_name) - 1) {
                            strncpy(var_name, start, len);
                            var_name[len] = '\0';
                            strcpy(op, "+=");
                            delta = 1;
                            parsed = true;
                        }
                    }
                }
            } else if (strstr(kry_source, "-= 1")) {
                const char* start = strchr(kry_source, '{');
                if (start) {
                    start++;
                    while (*start == ' ') start++;
                    const char* end = strstr(start, "-= 1");
                    if (end) {
                        size_t len = end - start;
                        if (len < sizeof(var_name) - 1) {
                            strncpy(var_name, start, len);
                            var_name[len] = '\0';
                            strcpy(op, "-=");
                            delta = 1;
                            parsed = true;
                        }
                    }
                }
            }
        }

        if (!parsed) {
            fprintf(ctx->output, "    // TODO: Transpile expression: %s\n", kry_source);
            continue;
        }

        // Find all scopes for this variable and generate a scoped handler for each
        // For each variable, check if there are multiple scopes
        cJSON* scopes_for_var[16];  // Max 16 scopes per variable (should be enough)
        int scope_count = 0;
        const char* base_var_name = var_name;

        // Collect all scopes for this variable
        if (ctx->reactive_vars && cJSON_IsArray(ctx->reactive_vars)) {
            int var_count = cJSON_GetArraySize(ctx->reactive_vars);
            for (int i = 0; i < var_count && scope_count < 16; i++) {
                cJSON* var = cJSON_GetArrayItem(ctx->reactive_vars, i);
                cJSON* vname = cJSON_GetObjectItem(var, "name");
                cJSON* scope = cJSON_GetObjectItem(var, "scope");

                if (vname && vname->valuestring &&
                    strcmp(vname->valuestring, base_var_name) == 0 &&
                    scope && scope->valuestring) {
                    scopes_for_var[scope_count++] = scope;
                }
            }
        }

        // Generate a handler function for each scope
        for (int s = 0; s < scope_count; s++) {
            cJSON* scope_item = scopes_for_var[s];
            const char* scope_str = scope_item->valuestring;

            // Skip component scope (will use the base handler name)
            if (strcmp(scope_str, "component") == 0) {
                // Generate base handler (for component definition)
                fprintf(ctx->output, "void %s(void) {\n", name->valuestring);
                transpile_kry_expression_to_c(ctx, base_var_name, op, delta);
                fprintf(ctx->output, "}\n\n");
            } else {
                // Generate scoped handler (e.g., "handler_1_click_Counter_0")
                char* scoped_handler_name = generate_scoped_var_name(name->valuestring, scope_str);
                char* scoped_var_name = generate_scoped_var_name(base_var_name, scope_str);

                fprintf(ctx->output, "void %s(void) {\n", scoped_handler_name);
                transpile_kry_expression_to_c(ctx, scoped_var_name, op, delta);
                fprintf(ctx->output, "}\n\n");

                free(scoped_handler_name);
                free(scoped_var_name);
            }
        }
    }
}

// ============================================================================
// Reactive Signal Generation (moved to ir_c_reactive.c)
// ============================================================================
// Functions: is_reactive_variable, get_scoped_var_name, generate_scoped_var_name,
// get_signal_creator, generate_reactive_signal_declarations,
// generate_reactive_signal_initialization, generate_reactive_signal_cleanup

// ============================================================================
// Component Generation (moved to ir_c_components.c)
// ============================================================================
// Functions: generate_component_recursive, generate_property_macro,
// generate_component_definitions

/**
 * Generate C struct definitions from source_structures.struct_types
 */

bool ir_generate_c_code_multi(const char* kir_path, const char* output_dir) {
    if (!kir_path || !output_dir) {
        fprintf(stderr, "Error: Invalid arguments to ir_generate_c_code_multi\n");
        return false;
    }

    // Set error prefix for this codegen
    codegen_set_error_prefix("C");

    // Read main KIR file
    char* main_kir_json = codegen_read_kir_file(kir_path, NULL);
    if (!main_kir_json) {
        return false;
    }

    // Parse main KIR JSON
    cJSON* main_root = cJSON_Parse(main_kir_json);
    if (!main_root) {
        fprintf(stderr, "Error: Failed to parse main KIR JSON\n");
        free(main_kir_json);
        return false;
    }

    // Check if output_dir is actually a file path (ends with .c)
    size_t output_len = strlen(output_dir);
    bool is_file_output = (output_len > 2 && strcmp(output_dir + output_len - 2, ".c") == 0);

    char actual_output_dir[2048];
    char main_output_path[2048];

    if (is_file_output) {
        // Extract directory from file path
        const char* last_slash = strrchr(output_dir, '/');
        if (last_slash) {
            size_t dir_len = last_slash - output_dir;
            strncpy(actual_output_dir, output_dir, dir_len);
            actual_output_dir[dir_len] = '\0';
        } else {
            strcpy(actual_output_dir, ".");
        }
        // Use the provided path as-is for main.c
        strncpy(main_output_path, output_dir, sizeof(main_output_path) - 1);
        main_output_path[sizeof(main_output_path) - 1] = '\0';
    } else {
        // Treat as directory, append /main.c
        strncpy(actual_output_dir, output_dir, sizeof(actual_output_dir) - 1);
        actual_output_dir[sizeof(actual_output_dir) - 1] = '\0';
        snprintf(main_output_path, sizeof(main_output_path), "%s/main.c", output_dir);
    }

    // Create output directory if it doesn't exist
    if (!codegen_mkdir_p(actual_output_dir)) {
        fprintf(stderr, "Error: Could not create output directory: %s\n", actual_output_dir);
        cJSON_Delete(main_root);
        free(main_kir_json);
        return false;
    }

    int files_written = 0;

    // 1. Generate main.c from main.kir

    if (ir_generate_c_code_from_string(main_kir_json, main_output_path)) {
        printf("✓ Generated: main.c\n");
        files_written++;
    } else {
        fprintf(stderr, "Warning: Failed to generate main.c from KIR\n");
    }

    free(main_kir_json);

    // 2. Get the KIR directory (parent of kir_path)
    char kir_dir[2048];
    codegen_get_parent_dir(kir_path, kir_dir, sizeof(kir_dir));

    // 3. Track processed modules to avoid duplicates
    CodegenProcessedModules processed = {0};
    codegen_processed_modules_add(&processed, "main");  // Mark main as processed

    // 4. Process each import recursively (including transitive imports)
    // Imports are in source_structures.requires[].module
    cJSON* source_structures = cJSON_GetObjectItem(main_root, "source_structures");
    cJSON* requires = source_structures ? cJSON_GetObjectItem(source_structures, "requires") : NULL;
    if (requires && cJSON_IsArray(requires)) {
        cJSON* import_item = NULL;
        cJSON_ArrayForEach(import_item, requires) {
            cJSON* module_obj = cJSON_GetObjectItem(import_item, "module");
            if (!module_obj || !cJSON_IsString(module_obj)) continue;

            const char* module_path = cJSON_GetStringValue(module_obj);
            if (module_path) {
                // Convert module path (e.g., "components.habit_panel") to file path format
                char module_id[512];
                strncpy(module_id, module_path, sizeof(module_id) - 1);
                module_id[sizeof(module_id) - 1] = '\0';
                // Replace dots with slashes for file path
                for (char* p = module_id; *p; p++) {
                    if (*p == '.') *p = '/';
                }
                files_written += c_process_module_recursive(module_id, kir_dir,
                                                            actual_output_dir, &processed);
            }
        }
    }

    codegen_processed_modules_free(&processed);
    cJSON_Delete(main_root);

    if (files_written == 0) {
        fprintf(stderr, "Warning: No C files were generated\n");
        return false;
    }

    printf("✓ Generated %d C files in %s\n", files_written, actual_output_dir);
    return true;
}
