/**
 * C Code Generator - KIR → C Source Code
 *
 * Generates idiomatic C code with Kryon DSL from KIR JSON files
 */

#include "ir_c_codegen.h"
#include "../codegen_common.h"
#include "../../ir/src/utils/ir_c_metadata.h"
#include "../../third_party/cJSON/cJSON.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <ctype.h>

// ============================================================================
// Code Generation Context
// ============================================================================

typedef struct {
    FILE* output;
    int indent_level;
    cJSON* root_json;           // Full KIR JSON
    cJSON* component_tree;      // Root component
    cJSON* c_metadata;          // C metadata section
    cJSON* variables;           // Variables array
    cJSON* event_handlers;      // Event handlers array
    cJSON* helper_functions;    // Helper functions array
    cJSON* includes;            // Includes array
    cJSON* preprocessor_dirs;   // Preprocessor directives array
} CCodegenContext;

// ============================================================================
// Utility Functions
// ============================================================================

static void write_indent(CCodegenContext* ctx) {
    for (int i = 0; i < ctx->indent_level; i++) {
        fprintf(ctx->output, "    ");
    }
}

static void writeln(CCodegenContext* ctx, const char* str) {
    write_indent(ctx);
    fprintf(ctx->output, "%s\n", str);
}

static void write_raw(CCodegenContext* ctx, const char* str) __attribute__((unused));
static void write_raw(CCodegenContext* ctx, const char* str) {
    fprintf(ctx->output, "%s", str);
}

// Get variable name for a component ID
static const char* get_variable_for_component_id(CCodegenContext* ctx, int component_id) {
    if (!ctx->variables) return NULL;

    int var_count = cJSON_GetArraySize(ctx->variables);
    for (int i = 0; i < var_count; i++) {
        cJSON* var = cJSON_GetArrayItem(ctx->variables, i);
        cJSON* id_item = cJSON_GetObjectItem(var, "component_id");
        if (id_item && id_item->valueint == component_id) {
            cJSON* name = cJSON_GetObjectItem(var, "name");
            if (name && name->valuestring) {
                return name->valuestring;
            }
        }
    }
    return NULL;
}

// Map component type to C DSL macro name
static const char* get_component_macro(const char* type) {
    if (strcmp(type, "Container") == 0) return "CONTAINER";
    if (strcmp(type, "Column") == 0) return "COLUMN";
    if (strcmp(type, "Row") == 0) return "ROW";
    if (strcmp(type, "Center") == 0) return "CENTER";
    if (strcmp(type, "Text") == 0) return "TEXT";
    if (strcmp(type, "Button") == 0) return "BUTTON";
    if (strcmp(type, "Input") == 0) return "INPUT";
    if (strcmp(type, "Checkbox") == 0) return "CHECKBOX";
    if (strcmp(type, "Dropdown") == 0) return "DROPDOWN";
    if (strcmp(type, "Image") == 0) return "IMAGE";
    if (strcmp(type, "TabGroup") == 0) return "TAB_GROUP";
    if (strcmp(type, "TabBar") == 0) return "TAB_BAR";
    if (strcmp(type, "Tab") == 0) return "TAB";
    if (strcmp(type, "TabContent") == 0) return "TAB_CONTENT";
    if (strcmp(type, "TabPanel") == 0) return "TAB_PANEL";
    if (strcmp(type, "Table") == 0) return "TABLE";
    if (strcmp(type, "TableHead") == 0) return "TABLE_HEAD";
    if (strcmp(type, "TableBody") == 0) return "TABLE_BODY";
    if (strcmp(type, "TableRow") == 0) return "TABLE_ROW";
    if (strcmp(type, "TableCell") == 0) return "TABLE_CELL";
    if (strcmp(type, "TableHeaderCell") == 0) return "TABLE_HEADER_CELL";
    if (strcmp(type, "For") == 0) return "FOR_EACH";
    if (strcmp(type, "Custom") == 0) return "COMPONENT";
    return "CONTAINER";  // Fallback
}

// ============================================================================
// Header Generation
// ============================================================================

static void generate_includes(CCodegenContext* ctx) {
    fprintf(ctx->output, "/**\n");
    fprintf(ctx->output, " * Auto-generated C code from .kir file\n");
    fprintf(ctx->output, " * Generated by Kryon C Code Generator\n");
    fprintf(ctx->output, " */\n\n");

    // Generate includes from metadata
    if (ctx->includes && cJSON_IsArray(ctx->includes)) {
        int count = cJSON_GetArraySize(ctx->includes);
        for (int i = 0; i < count; i++) {
            cJSON* inc = cJSON_GetArrayItem(ctx->includes, i);
            cJSON* include_str = cJSON_GetObjectItem(inc, "include");
            if (include_str && include_str->valuestring) {
                fprintf(ctx->output, "#include %s\n", include_str->valuestring);
            }
        }
    } else {
        // Default includes if no metadata
        fprintf(ctx->output, "#include <kryon.h>\n");
        fprintf(ctx->output, "#include <kryon_dsl.h>\n");
        fprintf(ctx->output, "#include <stdio.h>\n");
        fprintf(ctx->output, "#include <stdbool.h>\n");
    }
    fprintf(ctx->output, "\n");
}

static void generate_preprocessor_directives(CCodegenContext* ctx) {
    if (!ctx->preprocessor_dirs || !cJSON_IsArray(ctx->preprocessor_dirs)) {
        return;
    }

    int count = cJSON_GetArraySize(ctx->preprocessor_dirs);
    if (count == 0) return;

    for (int i = 0; i < count; i++) {
        cJSON* dir = cJSON_GetArrayItem(ctx->preprocessor_dirs, i);
        cJSON* type = cJSON_GetObjectItem(dir, "directive_type");
        cJSON* condition = cJSON_GetObjectItem(dir, "condition");
        cJSON* value = cJSON_GetObjectItem(dir, "value");

        if (!type || !type->valuestring) continue;

        if (strcmp(type->valuestring, "define") == 0) {
            fprintf(ctx->output, "#define ");
            if (condition && condition->valuestring) {
                fprintf(ctx->output, "%s ", condition->valuestring);
            }
            if (value && value->valuestring) {
                fprintf(ctx->output, "%s", value->valuestring);
            }
            fprintf(ctx->output, "\n");
        } else if (strcmp(type->valuestring, "ifdef") == 0 && condition && condition->valuestring) {
            fprintf(ctx->output, "#ifdef %s\n", condition->valuestring);
        } else if (strcmp(type->valuestring, "ifndef") == 0 && condition && condition->valuestring) {
            fprintf(ctx->output, "#ifndef %s\n", condition->valuestring);
        } else if (strcmp(type->valuestring, "if") == 0 && condition && condition->valuestring) {
            fprintf(ctx->output, "#if %s\n", condition->valuestring);
        } else if (strcmp(type->valuestring, "elif") == 0 && condition && condition->valuestring) {
            fprintf(ctx->output, "#elif %s\n", condition->valuestring);
        } else if (strcmp(type->valuestring, "else") == 0) {
            fprintf(ctx->output, "#else\n");
        } else if (strcmp(type->valuestring, "endif") == 0) {
            fprintf(ctx->output, "#endif\n");
        }
    }
    fprintf(ctx->output, "\n");
}

// ============================================================================
// KIR Expression/Statement to C Conversion (for exported functions)
// ============================================================================

// Forward declarations
static char* expr_to_c(cJSON* expr);
static bool stmt_to_c(FILE* output, cJSON* stmt, int indent, const char* output_path);

/**
 * Check if expression is a __range__ call and extract start/end
 * Returns true if it's a range, false otherwise
 */
static bool is_range_call(cJSON* expr, cJSON** out_start, cJSON** out_end) {
    if (!expr) return false;

    cJSON* op = cJSON_GetObjectItem(expr, "op");
    if (!op || !cJSON_IsString(op) || strcmp(op->valuestring, "call") != 0) {
        return false;
    }

    cJSON* func = cJSON_GetObjectItem(expr, "function");
    if (!func || !cJSON_IsString(func) || strcmp(func->valuestring, "__range__") != 0) {
        return false;
    }

    cJSON* args = cJSON_GetObjectItem(expr, "args");
    if (!args || !cJSON_IsArray(args) || cJSON_GetArraySize(args) < 2) {
        return false;
    }

    *out_start = cJSON_GetArrayItem(args, 0);
    *out_end = cJSON_GetArrayItem(args, 1);
    return true;
}

/**
 * Convert KIR expression to C code string
 * Returns malloc'd string, caller must free
 */
static char* expr_to_c(cJSON* expr) {
    if (!expr) return strdup("NULL");

    // String literal
    if (cJSON_IsString(expr)) {
        // Escape quotes in string
        const char* str = expr->valuestring;
        size_t len = strlen(str);
        char* result = malloc(len * 2 + 3);  // Worst case: all chars escaped + quotes + null
        char* p = result;
        *p++ = '"';
        for (size_t i = 0; i < len; i++) {
            if (str[i] == '"' || str[i] == '\\') {
                *p++ = '\\';
            }
            *p++ = str[i];
        }
        *p++ = '"';
        *p = '\0';
        return result;
    }

    // Number literal
    if (cJSON_IsNumber(expr)) {
        char* result = malloc(32);
        if (expr->valuedouble == (int)expr->valuedouble) {
            sprintf(result, "%d", expr->valueint);
        } else {
            sprintf(result, "%g", expr->valuedouble);
        }
        return result;
    }

    // Boolean
    if (cJSON_IsBool(expr)) {
        return strdup(cJSON_IsTrue(expr) ? "true" : "false");
    }

    // Null
    if (cJSON_IsNull(expr)) {
        return strdup("NULL");
    }

    // Variable reference: {"var": "name"}
    cJSON* var = cJSON_GetObjectItem(expr, "var");
    if (var && cJSON_IsString(var)) {
        return strdup(var->valuestring);
    }

    // Non-op based index access: {"index": arr, "at": idx}
    // This pattern is used in KIR for array indexing without explicit "op" field
    cJSON* index_arr = cJSON_GetObjectItem(expr, "index");
    cJSON* at_expr = cJSON_GetObjectItem(expr, "at");
    if (index_arr && at_expr) {
        char* arr_c = expr_to_c(index_arr);
        char* at_c = expr_to_c(at_expr);
        char* result = malloc(strlen(arr_c) + strlen(at_c) + 4);
        sprintf(result, "%s[%s]", arr_c, at_c);
        free(arr_c); free(at_c);
        return result;
    }

    // Operation
    cJSON* op = cJSON_GetObjectItem(expr, "op");
    if (!op || !cJSON_IsString(op)) {
        return strdup("/* unknown expr */");
    }

    const char* op_str = op->valuestring;

    // Binary arithmetic operations
    if (strcmp(op_str, "add") == 0) {
        char* left = expr_to_c(cJSON_GetObjectItem(expr, "left"));
        char* right = expr_to_c(cJSON_GetObjectItem(expr, "right"));
        char* result = malloc(strlen(left) + strlen(right) + 10);
        sprintf(result, "(%s + %s)", left, right);
        free(left); free(right);
        return result;
    }
    if (strcmp(op_str, "sub") == 0) {
        char* left = expr_to_c(cJSON_GetObjectItem(expr, "left"));
        char* right = expr_to_c(cJSON_GetObjectItem(expr, "right"));
        char* result = malloc(strlen(left) + strlen(right) + 10);
        sprintf(result, "(%s - %s)", left, right);
        free(left); free(right);
        return result;
    }
    if (strcmp(op_str, "mul") == 0) {
        char* left = expr_to_c(cJSON_GetObjectItem(expr, "left"));
        char* right = expr_to_c(cJSON_GetObjectItem(expr, "right"));
        char* result = malloc(strlen(left) + strlen(right) + 10);
        sprintf(result, "(%s * %s)", left, right);
        free(left); free(right);
        return result;
    }
    if (strcmp(op_str, "div") == 0) {
        char* left = expr_to_c(cJSON_GetObjectItem(expr, "left"));
        char* right = expr_to_c(cJSON_GetObjectItem(expr, "right"));
        char* result = malloc(strlen(left) + strlen(right) + 10);
        sprintf(result, "(%s / %s)", left, right);
        free(left); free(right);
        return result;
    }
    if (strcmp(op_str, "mod") == 0) {
        char* left = expr_to_c(cJSON_GetObjectItem(expr, "left"));
        char* right = expr_to_c(cJSON_GetObjectItem(expr, "right"));
        char* result = malloc(strlen(left) + strlen(right) + 10);
        sprintf(result, "(%s %% %s)", left, right);
        free(left); free(right);
        return result;
    }

    // Comparison operations
    if (strcmp(op_str, "eq") == 0) {
        char* left = expr_to_c(cJSON_GetObjectItem(expr, "left"));
        char* right = expr_to_c(cJSON_GetObjectItem(expr, "right"));
        char* result = malloc(strlen(left) + strlen(right) + 10);
        sprintf(result, "(%s == %s)", left, right);
        free(left); free(right);
        return result;
    }
    if (strcmp(op_str, "ne") == 0) {
        char* left = expr_to_c(cJSON_GetObjectItem(expr, "left"));
        char* right = expr_to_c(cJSON_GetObjectItem(expr, "right"));
        char* result = malloc(strlen(left) + strlen(right) + 10);
        sprintf(result, "(%s != %s)", left, right);
        free(left); free(right);
        return result;
    }
    if (strcmp(op_str, "lt") == 0) {
        char* left = expr_to_c(cJSON_GetObjectItem(expr, "left"));
        char* right = expr_to_c(cJSON_GetObjectItem(expr, "right"));
        char* result = malloc(strlen(left) + strlen(right) + 10);
        sprintf(result, "(%s < %s)", left, right);
        free(left); free(right);
        return result;
    }
    if (strcmp(op_str, "gt") == 0) {
        char* left = expr_to_c(cJSON_GetObjectItem(expr, "left"));
        char* right = expr_to_c(cJSON_GetObjectItem(expr, "right"));
        char* result = malloc(strlen(left) + strlen(right) + 10);
        sprintf(result, "(%s > %s)", left, right);
        free(left); free(right);
        return result;
    }
    if (strcmp(op_str, "le") == 0) {
        char* left = expr_to_c(cJSON_GetObjectItem(expr, "left"));
        char* right = expr_to_c(cJSON_GetObjectItem(expr, "right"));
        char* result = malloc(strlen(left) + strlen(right) + 10);
        sprintf(result, "(%s <= %s)", left, right);
        free(left); free(right);
        return result;
    }
    if (strcmp(op_str, "ge") == 0) {
        char* left = expr_to_c(cJSON_GetObjectItem(expr, "left"));
        char* right = expr_to_c(cJSON_GetObjectItem(expr, "right"));
        char* result = malloc(strlen(left) + strlen(right) + 10);
        sprintf(result, "(%s >= %s)", left, right);
        free(left); free(right);
        return result;
    }

    // Logical operations
    if (strcmp(op_str, "and") == 0) {
        char* left = expr_to_c(cJSON_GetObjectItem(expr, "left"));
        char* right = expr_to_c(cJSON_GetObjectItem(expr, "right"));
        char* result = malloc(strlen(left) + strlen(right) + 10);
        sprintf(result, "(%s && %s)", left, right);
        free(left); free(right);
        return result;
    }
    if (strcmp(op_str, "or") == 0) {
        char* left = expr_to_c(cJSON_GetObjectItem(expr, "left"));
        char* right = expr_to_c(cJSON_GetObjectItem(expr, "right"));
        char* result = malloc(strlen(left) + strlen(right) + 10);
        sprintf(result, "(%s || %s)", left, right);
        free(left); free(right);
        return result;
    }
    if (strcmp(op_str, "not") == 0) {
        char* operand = expr_to_c(cJSON_GetObjectItem(expr, "operand"));
        char* result = malloc(strlen(operand) + 5);
        sprintf(result, "(!%s)", operand);
        free(operand);
        return result;
    }

    // Unary minus
    if (strcmp(op_str, "neg") == 0) {
        char* operand = expr_to_c(cJSON_GetObjectItem(expr, "operand"));
        char* result = malloc(strlen(operand) + 5);
        sprintf(result, "(-%s)", operand);
        free(operand);
        return result;
    }

    // Member access: obj.property
    if (strcmp(op_str, "member_access") == 0) {
        char* obj = expr_to_c(cJSON_GetObjectItem(expr, "object"));
        cJSON* prop = cJSON_GetObjectItem(expr, "property");
        const char* prop_str = prop && cJSON_IsString(prop) ? prop->valuestring : "unknown";
        char* result = malloc(strlen(obj) + strlen(prop_str) + 2);
        sprintf(result, "%s.%s", obj, prop_str);
        free(obj);
        return result;
    }

    // Index access: arr[index]
    if (strcmp(op_str, "index_access") == 0) {
        char* obj = expr_to_c(cJSON_GetObjectItem(expr, "object"));
        char* index = expr_to_c(cJSON_GetObjectItem(expr, "index"));
        char* result = malloc(strlen(obj) + strlen(index) + 4);
        sprintf(result, "%s[%s]", obj, index);
        free(obj); free(index);
        return result;
    }

    // Array literal: [a, b, c]
    if (strcmp(op_str, "array_literal") == 0) {
        cJSON* elements = cJSON_GetObjectItem(expr, "elements");
        if (!elements || !cJSON_IsArray(elements)) {
            return strdup("{}");
        }

        // Calculate needed size
        size_t total_len = 3;  // { } \0
        int count = cJSON_GetArraySize(elements);
        char** elem_strs = malloc(count * sizeof(char*));

        for (int i = 0; i < count; i++) {
            elem_strs[i] = expr_to_c(cJSON_GetArrayItem(elements, i));
            total_len += strlen(elem_strs[i]) + 2;  // ", "
        }

        char* result = malloc(total_len);
        char* p = result;
        *p++ = '{';
        for (int i = 0; i < count; i++) {
            if (i > 0) {
                *p++ = ',';
                *p++ = ' ';
            }
            strcpy(p, elem_strs[i]);
            p += strlen(elem_strs[i]);
            free(elem_strs[i]);
        }
        *p++ = '}';
        *p = '\0';
        free(elem_strs);
        return result;
    }

    // Function call: func(args)
    if (strcmp(op_str, "call") == 0) {
        cJSON* func = cJSON_GetObjectItem(expr, "function");
        cJSON* args = cJSON_GetObjectItem(expr, "args");

        char* func_str = func ? expr_to_c(func) : strdup("unknown_func");

        // Build args string
        size_t total_len = strlen(func_str) + 3;  // () \0
        int arg_count = args ? cJSON_GetArraySize(args) : 0;
        char** arg_strs = NULL;

        if (arg_count > 0) {
            arg_strs = malloc(arg_count * sizeof(char*));
            for (int i = 0; i < arg_count; i++) {
                arg_strs[i] = expr_to_c(cJSON_GetArrayItem(args, i));
                total_len += strlen(arg_strs[i]) + 2;
            }
        }

        char* result = malloc(total_len);
        char* p = result;
        strcpy(p, func_str);
        p += strlen(func_str);
        *p++ = '(';
        for (int i = 0; i < arg_count; i++) {
            if (i > 0) {
                *p++ = ',';
                *p++ = ' ';
            }
            strcpy(p, arg_strs[i]);
            p += strlen(arg_strs[i]);
            free(arg_strs[i]);
        }
        *p++ = ')';
        *p = '\0';

        free(func_str);
        free(arg_strs);
        return result;
    }

    // Method call: receiver.method(args)
    if (strcmp(op_str, "method_call") == 0) {
        cJSON* receiver = cJSON_GetObjectItem(expr, "receiver");
        cJSON* method = cJSON_GetObjectItem(expr, "method");
        cJSON* args = cJSON_GetObjectItem(expr, "args");

        char* recv_str = receiver ? expr_to_c(receiver) : strdup("this");
        const char* method_str = method && cJSON_IsString(method) ? method->valuestring : "method";

        // Build args string
        size_t total_len = strlen(recv_str) + strlen(method_str) + 4;  // .() \0
        int arg_count = args ? cJSON_GetArraySize(args) : 0;
        char** arg_strs = NULL;

        if (arg_count > 0) {
            arg_strs = malloc(arg_count * sizeof(char*));
            for (int i = 0; i < arg_count; i++) {
                arg_strs[i] = expr_to_c(cJSON_GetArrayItem(args, i));
                total_len += strlen(arg_strs[i]) + 2;
            }
        }

        char* result = malloc(total_len);
        sprintf(result, "%s.%s(", recv_str, method_str);
        char* p = result + strlen(result);
        for (int i = 0; i < arg_count; i++) {
            if (i > 0) {
                *p++ = ',';
                *p++ = ' ';
            }
            strcpy(p, arg_strs[i]);
            p += strlen(arg_strs[i]);
            free(arg_strs[i]);
        }
        *p++ = ')';
        *p = '\0';

        free(recv_str);
        free(arg_strs);
        return result;
    }

    // Ternary/conditional: cond ? then : else
    if (strcmp(op_str, "ternary") == 0 || strcmp(op_str, "conditional") == 0) {
        char* cond = expr_to_c(cJSON_GetObjectItem(expr, "condition"));
        char* then_expr = expr_to_c(cJSON_GetObjectItem(expr, "then"));
        char* else_expr = expr_to_c(cJSON_GetObjectItem(expr, "else"));
        char* result = malloc(strlen(cond) + strlen(then_expr) + strlen(else_expr) + 10);
        sprintf(result, "(%s ? %s : %s)", cond, then_expr, else_expr);
        free(cond); free(then_expr); free(else_expr);
        return result;
    }

    // Unsupported operation - return a comment to indicate what's missing
    char* result = malloc(strlen(op_str) + 30);
    sprintf(result, "/* UNSUPPORTED: %s */", op_str);
    return result;
}

/**
 * Convert KIR statement to C code, write to output
 * Returns false on unsupported construct (hard error)
 */
static bool stmt_to_c(FILE* output, cJSON* stmt, int indent, const char* output_path) {
    if (!stmt || !cJSON_IsObject(stmt)) return true;

    cJSON* op = cJSON_GetObjectItem(stmt, "op");
    if (!op || !cJSON_IsString(op)) return true;

    const char* op_str = op->valuestring;

    // Variable declaration: let/const/var name = expr;
    if (strcmp(op_str, "var_decl") == 0 || strcmp(op_str, "let") == 0 || strcmp(op_str, "const") == 0) {
        cJSON* name = cJSON_GetObjectItem(stmt, "name");
        cJSON* type = cJSON_GetObjectItem(stmt, "type");
        cJSON* init = cJSON_GetObjectItem(stmt, "init");

        const char* var_name = name && cJSON_IsString(name) ? name->valuestring : "var";
        const char* var_type = type && cJSON_IsString(type) ? type->valuestring : "auto";

        // Map KIR types to C types
        const char* c_type = "void*";
        if (strcmp(var_type, "string") == 0) {
            c_type = "const char*";
        } else if (strcmp(var_type, "int") == 0 || strcmp(var_type, "number") == 0) {
            c_type = "int";
        } else if (strcmp(var_type, "float") == 0 || strcmp(var_type, "double") == 0) {
            c_type = "double";
        } else if (strcmp(var_type, "bool") == 0) {
            c_type = "bool";
        } else if (strcmp(var_type, "auto") == 0) {
            // Try to infer from init expression
            c_type = "auto";  // C23 supports this, or we use void*
        }

        fprintf(output, "%*s%s %s", indent, "", c_type, var_name);
        if (init) {
            char* init_c = expr_to_c(init);
            fprintf(output, " = %s", init_c);
            free(init_c);
        }
        fprintf(output, ";\n");
        return true;
    }

    // Assignment: target = expr;
    if (strcmp(op_str, "assign") == 0) {
        cJSON* target = cJSON_GetObjectItem(stmt, "target");
        cJSON* expr = cJSON_GetObjectItem(stmt, "expr");

        // Target is either a string (variable name) or an expression (for member/index access)
        const char* target_str;
        char* target_c = NULL;
        if (cJSON_IsString(target)) {
            target_str = target->valuestring;
        } else {
            target_c = expr_to_c(target);
            target_str = target_c;
        }

        char* expr_c = expr ? expr_to_c(expr) : strdup("NULL");
        fprintf(output, "%*s%s = %s;\n", indent, "", target_str, expr_c);
        if (target_c) free(target_c);
        free(expr_c);
        return true;
    }

    // Return: return expr;
    if (strcmp(op_str, "return") == 0) {
        cJSON* value = cJSON_GetObjectItem(stmt, "value");
        if (value) {
            char* expr_c = expr_to_c(value);
            fprintf(output, "%*sreturn %s;\n", indent, "", expr_c);
            free(expr_c);
        } else {
            fprintf(output, "%*sreturn;\n", indent, "");
        }
        return true;
    }

    // Expression statement (function call, etc.)
    if (strcmp(op_str, "expr_stmt") == 0) {
        cJSON* expr = cJSON_GetObjectItem(stmt, "expr");
        if (expr) {
            char* expr_c = expr_to_c(expr);
            fprintf(output, "%*s%s;\n", indent, "", expr_c);
            free(expr_c);
        }
        return true;
    }

    // If statement
    if (strcmp(op_str, "if") == 0) {
        cJSON* cond = cJSON_GetObjectItem(stmt, "condition");
        cJSON* then_block = cJSON_GetObjectItem(stmt, "then");
        cJSON* else_block = cJSON_GetObjectItem(stmt, "else");

        char* cond_c = expr_to_c(cond);
        fprintf(output, "%*sif (%s) {\n", indent, "", cond_c);
        free(cond_c);

        // Process then statements
        if (then_block && cJSON_IsArray(then_block)) {
            cJSON* then_stmt;
            cJSON_ArrayForEach(then_stmt, then_block) {
                if (!stmt_to_c(output, then_stmt, indent + 4, output_path)) return false;
            }
        }

        if (else_block && cJSON_IsArray(else_block) && cJSON_GetArraySize(else_block) > 0) {
            fprintf(output, "%*s} else {\n", indent, "");
            cJSON* else_stmt;
            cJSON_ArrayForEach(else_stmt, else_block) {
                if (!stmt_to_c(output, else_stmt, indent + 4, output_path)) return false;
            }
        }
        fprintf(output, "%*s}\n", indent, "");
        return true;
    }

    // While loop
    if (strcmp(op_str, "while") == 0) {
        cJSON* cond = cJSON_GetObjectItem(stmt, "condition");
        cJSON* body = cJSON_GetObjectItem(stmt, "body");

        char* cond_c = expr_to_c(cond);
        fprintf(output, "%*swhile (%s) {\n", indent, "", cond_c);
        free(cond_c);

        if (body && cJSON_IsArray(body)) {
            cJSON* body_stmt;
            cJSON_ArrayForEach(body_stmt, body) {
                if (!stmt_to_c(output, body_stmt, indent + 4, output_path)) return false;
            }
        }
        fprintf(output, "%*s}\n", indent, "");
        return true;
    }

    // For loop (classic for, not for-each)
    if (strcmp(op_str, "for") == 0) {
        cJSON* init = cJSON_GetObjectItem(stmt, "init");
        cJSON* cond = cJSON_GetObjectItem(stmt, "condition");
        cJSON* update = cJSON_GetObjectItem(stmt, "update");
        cJSON* body = cJSON_GetObjectItem(stmt, "body");

        char* init_c = init ? expr_to_c(init) : strdup("");
        char* cond_c = cond ? expr_to_c(cond) : strdup("true");
        char* update_c = update ? expr_to_c(update) : strdup("");

        fprintf(output, "%*sfor (%s; %s; %s) {\n", indent, "", init_c, cond_c, update_c);
        free(init_c); free(cond_c); free(update_c);

        if (body && cJSON_IsArray(body)) {
            cJSON* body_stmt;
            cJSON_ArrayForEach(body_stmt, body) {
                if (!stmt_to_c(output, body_stmt, indent + 4, output_path)) return false;
            }
        }
        fprintf(output, "%*s}\n", indent, "");
        return true;
    }

    // For-each loop
    if (strcmp(op_str, "for_each") == 0) {
        cJSON* item = cJSON_GetObjectItem(stmt, "item");
        cJSON* in_expr = cJSON_GetObjectItem(stmt, "in");
        cJSON* body = cJSON_GetObjectItem(stmt, "body");

        const char* item_name = item && cJSON_IsString(item) ? item->valuestring : "item";

        // Check if it's a range-based loop: __range__(start, end)
        cJSON* range_start = NULL;
        cJSON* range_end = NULL;

        if (is_range_call(in_expr, &range_start, &range_end)) {
            // Generate: for (int item = start; item < end; item++)
            char* start_c = expr_to_c(range_start);
            char* end_c = expr_to_c(range_end);

            fprintf(output, "%*sfor (int %s = %s; %s < %s; %s++) {\n",
                    indent, "", item_name, start_c, item_name, end_c, item_name);

            free(start_c);
            free(end_c);
        } else {
            // Array iteration: for (int _idx = 0; _idx < arr_len; _idx++)
            char* arr_c = expr_to_c(in_expr);

            // Generate index variable with unique name
            fprintf(output, "%*sfor (int _%s_idx = 0; _%s_idx < %s_len; _%s_idx++) {\n",
                    indent, "", item_name, item_name, arr_c, item_name);

            // Generate item assignment: type item = arr[_idx]
            fprintf(output, "%*s    %s = %s[_%s_idx];\n",
                    indent, "", item_name, arr_c, item_name);

            free(arr_c);
        }

        // Generate body statements
        if (body && cJSON_IsArray(body)) {
            cJSON* body_stmt;
            cJSON_ArrayForEach(body_stmt, body) {
                if (!stmt_to_c(output, body_stmt, indent + 4, output_path)) {
                    return false;
                }
            }
        }

        fprintf(output, "%*s}\n", indent, "");
        return true;
    }

    // Break statement
    if (strcmp(op_str, "break") == 0) {
        fprintf(output, "%*sbreak;\n", indent, "");
        return true;
    }

    // Continue statement
    if (strcmp(op_str, "continue") == 0) {
        fprintf(output, "%*scontinue;\n", indent, "");
        return true;
    }

    // Block statement
    if (strcmp(op_str, "block") == 0) {
        cJSON* stmts = cJSON_GetObjectItem(stmt, "statements");
        fprintf(output, "%*s{\n", indent, "");
        if (stmts && cJSON_IsArray(stmts)) {
            cJSON* s;
            cJSON_ArrayForEach(s, stmts) {
                if (!stmt_to_c(output, s, indent + 4, output_path)) return false;
            }
        }
        fprintf(output, "%*s}\n", indent, "");
        return true;
    }

    // Unknown statement - HARD ERROR
    fprintf(stderr, "[C Codegen] Error: Unsupported statement op '%s' in C codegen.\n", op_str);
    fprintf(stderr, "            File: %s\n", output_path ? output_path : "unknown");
    return false;
}

/**
 * Map KIR type to C type string
 */
static const char* kir_type_to_c(const char* kir_type) {
    if (!kir_type) return "void";

    if (strcmp(kir_type, "string") == 0) return "const char*";
    if (strcmp(kir_type, "int") == 0) return "int";
    if (strcmp(kir_type, "number") == 0) return "double";
    if (strcmp(kir_type, "float") == 0) return "float";
    if (strcmp(kir_type, "double") == 0) return "double";
    if (strcmp(kir_type, "bool") == 0) return "bool";
    if (strcmp(kir_type, "void") == 0) return "void";

    // Array types like "string[]" -> "const char**"
    size_t len = strlen(kir_type);
    if (len > 2 && kir_type[len-2] == '[' && kir_type[len-1] == ']') {
        // Create base type string
        char base[64];
        strncpy(base, kir_type, len - 2);
        base[len - 2] = '\0';

        if (strcmp(base, "string") == 0) return "const char**";
        if (strcmp(base, "int") == 0) return "int*";
        if (strcmp(base, "number") == 0) return "double*";
        if (strcmp(base, "float") == 0) return "float*";
        if (strcmp(base, "double") == 0) return "double*";
        if (strcmp(base, "bool") == 0) return "bool*";
    }

    return "void*";  // Unknown type
}

/**
 * Generate exported functions from logic_block
 * Returns false on hard error (unsupported constructs)
 */
static bool generate_exported_functions(FILE* output, cJSON* logic_block, cJSON* exports, const char* output_path) {
    if (!logic_block || !exports) return true;

    cJSON* functions = cJSON_GetObjectItem(logic_block, "functions");
    if (!functions || !cJSON_IsArray(functions)) return true;

    fprintf(output, "// Exported functions\n");

    // For each export, find and generate the function
    cJSON* export_item;
    cJSON_ArrayForEach(export_item, exports) {
        cJSON* name = cJSON_GetObjectItem(export_item, "name");
        cJSON* type = cJSON_GetObjectItem(export_item, "type");

        if (!name || !cJSON_IsString(name)) continue;
        const char* export_name = name->valuestring;
        const char* export_type = type && cJSON_IsString(type) ? type->valuestring : "";

        // Skip non-function exports
        if (strcmp(export_type, "function") != 0) continue;

        // Find function in logic_block.functions
        cJSON* func;
        bool found = false;
        cJSON_ArrayForEach(func, functions) {
            cJSON* func_name = cJSON_GetObjectItem(func, "name");
            if (!func_name || !cJSON_IsString(func_name)) continue;
            if (strcmp(func_name->valuestring, export_name) != 0) continue;

            found = true;

            // Check for universal statements
            cJSON* universal = cJSON_GetObjectItem(func, "universal");
            if (!universal) {
                fprintf(stderr, "[C Codegen] Error: Exported function '%s' has no universal implementation.\n",
                        export_name);
                fprintf(stderr, "            File: %s\n", output_path ? output_path : "unknown");
                return false;
            }

            cJSON* statements = cJSON_GetObjectItem(universal, "statements");
            if (!statements || !cJSON_IsArray(statements)) {
                // Empty function body - might be just a declaration
                statements = NULL;
            }

            // Get return type and parameters
            cJSON* return_type = cJSON_GetObjectItem(func, "return_type");
            cJSON* params = cJSON_GetObjectItem(func, "params");

            const char* ret_type_str = return_type && cJSON_IsString(return_type) ?
                                       return_type->valuestring : "void";
            const char* c_ret_type = kir_type_to_c(ret_type_str);

            // Generate function signature
            fprintf(output, "\n%s %s(", c_ret_type, export_name);

            // Generate parameters
            if (params && cJSON_IsArray(params) && cJSON_GetArraySize(params) > 0) {
                int param_count = cJSON_GetArraySize(params);
                for (int i = 0; i < param_count; i++) {
                    cJSON* param = cJSON_GetArrayItem(params, i);
                    cJSON* param_name = cJSON_GetObjectItem(param, "name");
                    cJSON* param_type = cJSON_GetObjectItem(param, "type");

                    const char* p_name = param_name && cJSON_IsString(param_name) ?
                                         param_name->valuestring : "arg";
                    const char* p_type = param_type && cJSON_IsString(param_type) ?
                                         param_type->valuestring : "any";

                    if (i > 0) fprintf(output, ", ");
                    fprintf(output, "%s %s", kir_type_to_c(p_type), p_name);
                }
            } else {
                fprintf(output, "void");
            }
            fprintf(output, ") {\n");

            // Generate statements
            if (statements) {
                cJSON* stmt;
                cJSON_ArrayForEach(stmt, statements) {
                    if (!stmt_to_c(output, stmt, 4, output_path)) {
                        return false;  // Hard error
                    }
                }
            }

            fprintf(output, "}\n");
            break;
        }

        if (!found) {
            fprintf(stderr, "[C Codegen] Warning: Exported function '%s' not found in logic_block.\n",
                    export_name);
        }
    }

    return true;
}

// ============================================================================
// Variable & Function Generation
// ============================================================================

static void generate_variable_declarations(CCodegenContext* ctx) {
    if (!ctx->variables || !cJSON_IsArray(ctx->variables)) {
        return;
    }

    int count = cJSON_GetArraySize(ctx->variables);
    if (count == 0) return;

    fprintf(ctx->output, "// Component variables\n");
    for (int i = 0; i < count; i++) {
        cJSON* var = cJSON_GetArrayItem(ctx->variables, i);
        cJSON* storage = cJSON_GetObjectItem(var, "storage");
        cJSON* type = cJSON_GetObjectItem(var, "type");
        cJSON* name = cJSON_GetObjectItem(var, "name");
        cJSON* initial = cJSON_GetObjectItem(var, "initial_value");

        if (!name || !name->valuestring || !type || !type->valuestring) continue;

        if (storage && storage->valuestring) {
            fprintf(ctx->output, "%s ", storage->valuestring);
        }
        fprintf(ctx->output, "%s %s", type->valuestring, name->valuestring);

        if (initial && initial->valuestring) {
            fprintf(ctx->output, " = %s", initial->valuestring);
        }
        fprintf(ctx->output, ";\n");
    }
    fprintf(ctx->output, "\n");
}

static void generate_helper_functions(CCodegenContext* ctx) {
    if (!ctx->helper_functions || !cJSON_IsArray(ctx->helper_functions)) {
        return;
    }

    int count = cJSON_GetArraySize(ctx->helper_functions);
    if (count == 0) return;

    fprintf(ctx->output, "// Helper functions\n");
    for (int i = 0; i < count; i++) {
        cJSON* func = cJSON_GetArrayItem(ctx->helper_functions, i);
        cJSON* return_type = cJSON_GetObjectItem(func, "return_type");
        cJSON* name = cJSON_GetObjectItem(func, "name");
        cJSON* params = cJSON_GetObjectItem(func, "parameters");
        cJSON* body = cJSON_GetObjectItem(func, "body");

        if (!name || !name->valuestring || !return_type || !return_type->valuestring) continue;

        fprintf(ctx->output, "%s %s(%s) {\n",
                return_type->valuestring,
                name->valuestring,
                (params && params->valuestring) ? params->valuestring : "void");

        if (body && body->valuestring) {
            fprintf(ctx->output, "%s\n", body->valuestring);
        }

        fprintf(ctx->output, "}\n\n");
    }
}

static void generate_event_handlers(CCodegenContext* ctx) {
    if (!ctx->event_handlers || !cJSON_IsArray(ctx->event_handlers)) {
        return;
    }

    int count = cJSON_GetArraySize(ctx->event_handlers);
    if (count == 0) return;

    fprintf(ctx->output, "// Event handlers\n");
    for (int i = 0; i < count; i++) {
        cJSON* handler = cJSON_GetArrayItem(ctx->event_handlers, i);
        cJSON* return_type = cJSON_GetObjectItem(handler, "return_type");
        cJSON* name = cJSON_GetObjectItem(handler, "function_name");
        cJSON* params = cJSON_GetObjectItem(handler, "parameters");
        cJSON* body = cJSON_GetObjectItem(handler, "body");

        if (!name || !name->valuestring || !return_type || !return_type->valuestring) continue;

        fprintf(ctx->output, "%s %s(%s) {\n",
                return_type->valuestring,
                name->valuestring,
                (params && params->valuestring) ? params->valuestring : "void");

        if (body && body->valuestring) {
            fprintf(ctx->output, "%s\n", body->valuestring);
        }

        fprintf(ctx->output, "}\n\n");
    }
}

// ============================================================================
// Component Tree Generation
// ============================================================================

static bool generate_property_macro(CCodegenContext* ctx, const char* key, cJSON* value, bool* first_prop);

static void generate_component_recursive(CCodegenContext* ctx, cJSON* component, bool is_root) {
    cJSON* type_obj = cJSON_GetObjectItem(component, "type");
    cJSON* id_obj = cJSON_GetObjectItem(component, "id");
    cJSON* children_obj = cJSON_GetObjectItem(component, "children");
    cJSON* text_obj = cJSON_GetObjectItem(component, "text");

    if (!type_obj || !type_obj->valuestring) return;

    const char* type = type_obj->valuestring;

    // Special handling for For loops
    if (strcmp(type, "For") == 0) {
        cJSON* for_def = cJSON_GetObjectItem(component, "for_def");
        if (for_def) {
            cJSON* item_name = cJSON_GetObjectItem(for_def, "item_name");
            cJSON* source = cJSON_GetObjectItem(for_def, "source");
            cJSON* source_expr = source ? cJSON_GetObjectItem(source, "expression") : NULL;

            write_indent(ctx);
            fprintf(ctx->output, "FOR_EACH(%s, %s,\n",
                    item_name ? item_name->valuestring : "item",
                    source_expr ? source_expr->valuestring : "items");

            ctx->indent_level++;
            // Generate template children
            if (children_obj && cJSON_IsArray(children_obj)) {
                int child_count = cJSON_GetArraySize(children_obj);
                for (int i = 0; i < child_count; i++) {
                    cJSON* child = cJSON_GetArrayItem(children_obj, i);
                    generate_component_recursive(ctx, child, false);
                    if (i < child_count - 1) {
                        fprintf(ctx->output, ",\n");
                    } else {
                        fprintf(ctx->output, "\n");
                    }
                }
            }
            ctx->indent_level--;
            write_indent(ctx);
            fprintf(ctx->output, ")");
            return;
        }
    }

    // Special handling for Custom components (component references)
    cJSON* component_ref = cJSON_GetObjectItem(component, "component_ref");
    if (component_ref && component_ref->valuestring) {
        write_indent(ctx);
        cJSON* arg_obj = cJSON_GetObjectItem(component, "arg");
        if (arg_obj && arg_obj->valuestring) {
            fprintf(ctx->output, "%s(%s)", component_ref->valuestring, arg_obj->valuestring);
        } else {
            fprintf(ctx->output, "%s()", component_ref->valuestring);
        }
        return;
    }

    // Check if this is a custom component (type is PascalCase and not a builtin)
    // Custom components have their type set to the component name (e.g., "HabitPanel")
    const char* macro_check = get_component_macro(type);
    bool is_custom_component = (strcmp(macro_check, "CONTAINER") == 0 &&
                                type[0] >= 'A' && type[0] <= 'Z' &&
                                strcmp(type, "Container") != 0);
    if (is_custom_component) {
        write_indent(ctx);
        cJSON* arg_obj = cJSON_GetObjectItem(component, "arg");
        if (arg_obj && arg_obj->valuestring) {
            fprintf(ctx->output, "%s(%s)", type, arg_obj->valuestring);
        } else {
            fprintf(ctx->output, "%s()", type);
        }
        return;
    }

    const char* macro = get_component_macro(type);

    // Check if this component has a variable assignment
    const char* var_name = NULL;
    if (id_obj) {
        var_name = get_variable_for_component_id(ctx, id_obj->valueint);
    }

    // Write indentation
    write_indent(ctx);

    // Variable assignment if needed
    if (var_name && !is_root) {
        fprintf(ctx->output, "%s = ", var_name);
    }

    // Component macro
    fprintf(ctx->output, "%s(", macro);

    // Text/label parameter for components that need it
    // Check for text_expression (dynamic binding) first
    cJSON* text_expr_obj = cJSON_GetObjectItem(component, "text_expression");
    bool has_text = (text_obj && text_obj->valuestring) || (text_expr_obj && text_expr_obj->valuestring);
    if (text_expr_obj && text_expr_obj->valuestring) {
        // Dynamic text expression - output as variable reference
        fprintf(ctx->output, "%s", text_expr_obj->valuestring);
    } else if (text_obj && text_obj->valuestring) {
        fprintf(ctx->output, "\"%s\"", text_obj->valuestring);
    }

    // Check for FULL_SIZE pattern (width=100.0px AND height=100.0px)
    cJSON* width_prop = cJSON_GetObjectItem(component, "width");
    cJSON* height_prop = cJSON_GetObjectItem(component, "height");
    bool is_full_size = (width_prop && width_prop->valuestring &&
                         height_prop && height_prop->valuestring &&
                         (strcmp(width_prop->valuestring, "100.0px") == 0 ||
                          strcmp(width_prop->valuestring, "100.0%") == 0) &&
                         (strcmp(height_prop->valuestring, "100.0px") == 0 ||
                          strcmp(height_prop->valuestring, "100.0%") == 0));

    // Check if we have properties or children
    bool has_properties = false;
    cJSON* prop = NULL;
    cJSON_ArrayForEach(prop, component) {
        const char* key = prop->string;
        if (!key) continue;
        if (strcmp(key, "id") != 0 && strcmp(key, "type") != 0 &&
            strcmp(key, "text") != 0 && strcmp(key, "children") != 0 &&
            strcmp(key, "TEST_MARKER") != 0 && strcmp(key, "direction") != 0 &&
            strcmp(key, "background") != 0 && strcmp(key, "color") != 0) {
            has_properties = true;
            break;
        }
        // Check if background/color are non-default
        if (strcmp(key, "background") == 0 && prop->valuestring && strcmp(prop->valuestring, "#00000000") != 0) {
            has_properties = true;
            break;
        }
        if (strcmp(key, "color") == 0 && prop->valuestring && strcmp(prop->valuestring, "#00000000") != 0) {
            has_properties = true;
            break;
        }
    }

    bool has_children = (children_obj && cJSON_GetArraySize(children_obj) > 0);

    // Add comma after text if there are properties or children
    if (has_text && (has_properties || has_children)) {
        fprintf(ctx->output, ",\n");
    } else if (!has_text || !has_properties) {
        fprintf(ctx->output, "\n");
    }

    ctx->indent_level++;

    // Generate FULL_SIZE if applicable
    bool first_prop = true;
    if (is_full_size) {
        if (!first_prop) {
            fprintf(ctx->output, ",\n");
        }
        write_indent(ctx);
        fprintf(ctx->output, "FULL_SIZE");
        first_prop = false;
    }

    // Generate properties
    cJSON* prop2 = NULL;
    cJSON_ArrayForEach(prop2, component) {
        const char* key = prop2->string;
        if (!key) continue;

        // Skip internal fields
        if (strcmp(key, "id") == 0 || strcmp(key, "type") == 0 ||
            strcmp(key, "text") == 0 || strcmp(key, "children") == 0 ||
            strcmp(key, "TEST_MARKER") == 0 || strcmp(key, "direction") == 0) {
            continue;
        }

        // Skip width/height if we already generated FULL_SIZE
        if (is_full_size && (strcmp(key, "width") == 0 || strcmp(key, "height") == 0)) {
            continue;
        }

        // Skip transparent/default colors
        if ((strcmp(key, "background") == 0 || strcmp(key, "color") == 0) &&
            prop2->valuestring && strcmp(prop2->valuestring, "#00000000") == 0) {
            continue;
        }

        // Skip events property if there are no event handlers in metadata
        if (strcmp(key, "events") == 0 && (!ctx->event_handlers || cJSON_GetArraySize(ctx->event_handlers) == 0)) {
            continue;
        }

        // Generate the property (comma handling is internal now)
        generate_property_macro(ctx, key, prop2, &first_prop);
    }

    // Generate children
    if (children_obj && cJSON_IsArray(children_obj)) {
        int child_count = cJSON_GetArraySize(children_obj);
        if (child_count > 0) {
            // Print comma before children if we had properties
            if (!first_prop) {
                fprintf(ctx->output, ",\n");
                fprintf(ctx->output, "\n");  // Blank line for readability
            }

            for (int i = 0; i < child_count; i++) {
                cJSON* child = cJSON_GetArrayItem(children_obj, i);
                generate_component_recursive(ctx, child, false);
                if (i < child_count - 1) {
                    fprintf(ctx->output, ",\n");
                } else {
                    fprintf(ctx->output, "\n");
                }
            }
        }
    }

    ctx->indent_level--;
    write_indent(ctx);
    fprintf(ctx->output, ")");
}

static bool generate_property_macro(CCodegenContext* ctx, const char* key, cJSON* value, bool* first_prop) {
    // NOTE: Each case that generates output must:
    // 1. Print comma if not first_prop
    // 2. Set *first_prop = false after printing

    // Width/Height
    if (strcmp(key, "width") == 0 && value->valuestring) {
        if (!*first_prop) fprintf(ctx->output, ",\n");
        write_indent(ctx);
        if (strcmp(value->valuestring, "100.0px") == 0 || strcmp(value->valuestring, "100.0%") == 0) {
            fprintf(ctx->output, "FULL_WIDTH");
        } else {
            // Parse numeric value (e.g., "200.0px" → 200)
            int width_val = 0;
            if (sscanf(value->valuestring, "%d", &width_val) == 1 && width_val > 0) {
                fprintf(ctx->output, "WIDTH(%d)", width_val);
            } else {
                fprintf(ctx->output, "WIDTH(\"%s\")", value->valuestring);
            }
        }
        *first_prop = false;
        return true;
    }
    if (strcmp(key, "height") == 0 && value->valuestring) {
        if (!*first_prop) fprintf(ctx->output, ",\n");
        write_indent(ctx);
        if (strcmp(value->valuestring, "100.0px") == 0 || strcmp(value->valuestring, "100.0%") == 0) {
            fprintf(ctx->output, "FULL_HEIGHT");
        } else {
            // Parse numeric value (e.g., "60.0px" → 60)
            int height_val = 0;
            if (sscanf(value->valuestring, "%d", &height_val) == 1 && height_val > 0) {
                fprintf(ctx->output, "HEIGHT(%d)", height_val);
            } else {
                fprintf(ctx->output, "HEIGHT(\"%s\")", value->valuestring);
            }
        }
        *first_prop = false;
        return true;
    }

    // Colors
    if (strcmp(key, "background") == 0 && value->valuestring) {
        if (!*first_prop) fprintf(ctx->output, ",\n");
        write_indent(ctx);
        // Convert color string "#RRGGBB" to hex 0xRRGGBB
        const char* color_str = value->valuestring;
        if (color_str[0] == '#' && strlen(color_str) >= 7) {
            fprintf(ctx->output, "BG_COLOR(0x%s)", color_str + 1);  // Skip '#'
        } else {
            // Fallback for non-hex colors
            fprintf(ctx->output, "BG_COLOR(0x%s)", color_str);
        }
        *first_prop = false;
        return true;
    }
    if (strcmp(key, "color") == 0 && value->valuestring) {
        if (!*first_prop) fprintf(ctx->output, ",\n");
        write_indent(ctx);
        // Check for named colors
        if (strcmp(value->valuestring, "#ffffff") == 0) {
            fprintf(ctx->output, "COLOR_WHITE");
        } else if (strcmp(value->valuestring, "#000000") == 0) {
            fprintf(ctx->output, "COLOR_BLACK");
        } else if (strcmp(value->valuestring, "#ff0000") == 0) {
            fprintf(ctx->output, "COLOR_RED");
        } else if (strcmp(value->valuestring, "#00ff00") == 0) {
            fprintf(ctx->output, "COLOR_GREEN");
        } else if (strcmp(value->valuestring, "#0000ff") == 0) {
            fprintf(ctx->output, "COLOR_BLUE");
        } else if (strcmp(value->valuestring, "#ffff00") == 0) {
            fprintf(ctx->output, "COLOR_YELLOW");
        } else if (strcmp(value->valuestring, "#00ffff") == 0) {
            fprintf(ctx->output, "COLOR_CYAN");
        } else if (strcmp(value->valuestring, "#ff00ff") == 0) {
            fprintf(ctx->output, "COLOR_MAGENTA");
        } else if (strcmp(value->valuestring, "#808080") == 0) {
            fprintf(ctx->output, "COLOR_GRAY");
        } else if (strcmp(value->valuestring, "#ffa500") == 0) {
            fprintf(ctx->output, "COLOR_ORANGE");
        } else if (strcmp(value->valuestring, "#800080") == 0) {
            fprintf(ctx->output, "COLOR_PURPLE");
        } else {
            // Convert color string "#RRGGBB" to hex 0xRRGGBB
            const char* color_str = value->valuestring;
            if (color_str[0] == '#' && strlen(color_str) >= 7) {
                fprintf(ctx->output, "TEXT_COLOR(0x%s)", color_str + 1);  // Skip '#'
            } else {
                fprintf(ctx->output, "TEXT_COLOR(0x%s)", color_str);
            }
        }
        *first_prop = false;
        return true;
    }

    // Padding/Margin
    if (strcmp(key, "padding") == 0) {
        if (!*first_prop) fprintf(ctx->output, ",\n");
        write_indent(ctx);
        if (cJSON_IsNumber(value)) {
            fprintf(ctx->output, "PADDING(%.0f)", value->valuedouble);
        } else if (cJSON_IsArray(value)) {
            int size = cJSON_GetArraySize(value);
            if (size == 4) {
                fprintf(ctx->output, "PADDING_SIDES(%.0f, %.0f, %.0f, %.0f)",
                        cJSON_GetArrayItem(value, 0)->valuedouble,
                        cJSON_GetArrayItem(value, 1)->valuedouble,
                        cJSON_GetArrayItem(value, 2)->valuedouble,
                        cJSON_GetArrayItem(value, 3)->valuedouble);
            }
        }
        *first_prop = false;
        return true;
    }
    if (strcmp(key, "gap") == 0 && cJSON_IsNumber(value)) {
        if (!*first_prop) fprintf(ctx->output, ",\n");
        write_indent(ctx);
        fprintf(ctx->output, "GAP(%.0f)", value->valuedouble);
        *first_prop = false;
        return true;
    }

    // Typography
    if (strcmp(key, "fontSize") == 0 && cJSON_IsNumber(value)) {
        if (!*first_prop) fprintf(ctx->output, ",\n");
        write_indent(ctx);
        fprintf(ctx->output, "FONT_SIZE(%.0f)", value->valuedouble);
        *first_prop = false;
        return true;
    }
    if (strcmp(key, "fontBold") == 0 && cJSON_IsBool(value)) {
        if (cJSON_IsTrue(value)) {
            if (!*first_prop) fprintf(ctx->output, ",\n");
            write_indent(ctx);
            fprintf(ctx->output, "FONT_BOLD");
            *first_prop = false;
            return true;
        }
        return false;  // fontBold=false generates no output, so no comma
    }

    // Layout
    if (strcmp(key, "justifyContent") == 0 && value->valuestring) {
        if (!*first_prop) fprintf(ctx->output, ",\n");
        write_indent(ctx);
        if (strcmp(value->valuestring, "center") == 0) {
            fprintf(ctx->output, "JUSTIFY_CENTER");
        } else if (strcmp(value->valuestring, "flex-start") == 0 || strcmp(value->valuestring, "start") == 0) {
            fprintf(ctx->output, "JUSTIFY_START");
        } else if (strcmp(value->valuestring, "flex-end") == 0 || strcmp(value->valuestring, "end") == 0) {
            fprintf(ctx->output, "JUSTIFY_END");
        } else if (strcmp(value->valuestring, "space-between") == 0) {
            fprintf(ctx->output, "JUSTIFY_SPACE_BETWEEN");
        } else if (strcmp(value->valuestring, "space-around") == 0) {
            fprintf(ctx->output, "JUSTIFY_SPACE_AROUND");
        } else {
            fprintf(ctx->output, "JUSTIFY_CENTER");
        }
        *first_prop = false;
        return true;
    }
    if (strcmp(key, "alignItems") == 0 && value->valuestring) {
        if (!*first_prop) fprintf(ctx->output, ",\n");
        write_indent(ctx);
        if (strcmp(value->valuestring, "center") == 0) {
            fprintf(ctx->output, "ALIGN_CENTER");
        } else if (strcmp(value->valuestring, "flex-start") == 0 || strcmp(value->valuestring, "start") == 0) {
            fprintf(ctx->output, "ALIGN_START");
        } else if (strcmp(value->valuestring, "flex-end") == 0 || strcmp(value->valuestring, "end") == 0) {
            fprintf(ctx->output, "ALIGN_END");
        } else if (strcmp(value->valuestring, "stretch") == 0) {
            fprintf(ctx->output, "ALIGN_STRETCH");
        } else {
            fprintf(ctx->output, "ALIGN_CENTER");
        }
        *first_prop = false;
        return true;
    }
    if (strcmp(key, "flexShrink") == 0 && cJSON_IsNumber(value)) {
        if (!*first_prop) fprintf(ctx->output, ",\n");
        write_indent(ctx);
        fprintf(ctx->output, "FLEX_SHRINK(%.0f)", value->valuedouble);
        *first_prop = false;
        return true;
    }

    // Visibility
    if (strcmp(key, "visible") == 0 && cJSON_IsBool(value)) {
        if (!*first_prop) fprintf(ctx->output, ",\n");
        write_indent(ctx);
        fprintf(ctx->output, "VISIBLE(%s)", cJSON_IsTrue(value) ? "true" : "false");
        *first_prop = false;
        return true;
    }

    // Events
    if (strcmp(key, "events") == 0 && cJSON_IsArray(value)) {
        int event_count = cJSON_GetArraySize(value);
        bool printed = false;
        for (int i = 0; i < event_count; i++) {
            cJSON* event = cJSON_GetArrayItem(value, i);
            cJSON* event_type = cJSON_GetObjectItem(event, "type");
            cJSON* logic_id = cJSON_GetObjectItem(event, "logic_id");

            if (event_type && event_type->valuestring && logic_id && logic_id->valuestring) {
                // Find the function name for this logic_id
                if (ctx->event_handlers) {
                    int handler_count = cJSON_GetArraySize(ctx->event_handlers);
                    for (int j = 0; j < handler_count; j++) {
                        cJSON* handler = cJSON_GetArrayItem(ctx->event_handlers, j);
                        cJSON* h_logic_id = cJSON_GetObjectItem(handler, "logic_id");
                        cJSON* h_func_name = cJSON_GetObjectItem(handler, "function_name");

                        if (h_logic_id && h_logic_id->valuestring &&
                            h_func_name && h_func_name->valuestring &&
                            strcmp(h_logic_id->valuestring, logic_id->valuestring) == 0) {

                            if (strcmp(event_type->valuestring, "click") == 0) {
                                if (!*first_prop) fprintf(ctx->output, ",\n");
                                write_indent(ctx);
                                fprintf(ctx->output, "ON_CLICK(%s)", h_func_name->valuestring);
                                *first_prop = false;
                                printed = true;
                            }
                            break;
                        }
                    }
                }
            }
        }
        return printed;
    }

    // Property bindings (for reactive properties like selectedIndex)
    if (strcmp(key, "property_bindings") == 0 && cJSON_IsObject(value)) {
        bool printed = false;
        cJSON* binding = NULL;
        cJSON_ArrayForEach(binding, value) {
            const char* prop_name = binding->string;
            if (!prop_name) continue;

            cJSON* source_expr = cJSON_GetObjectItem(binding, "source_expr");
            if (source_expr && source_expr->valuestring) {
                if (!*first_prop || printed) fprintf(ctx->output, ",\n");
                write_indent(ctx);

                if (strcmp(prop_name, "selectedIndex") == 0) {
                    fprintf(ctx->output, "SELECTED_INDEX(%s)", source_expr->valuestring);
                } else {
                    fprintf(ctx->output, "BIND(%s, %s)", prop_name, source_expr->valuestring);
                }
                printed = true;
                *first_prop = false;
            }
        }
        return printed;
    }

    // Fallback: skip unknown properties (no comma printed)
    return false;
}

// ============================================================================
// Component Definition Generation (for module files)
// ============================================================================

/**
 * Generate C code for component definitions (non-app modules)
 */
static void generate_component_definitions(CCodegenContext* ctx, cJSON* component_defs) {
    if (!component_defs || !cJSON_IsArray(component_defs)) return;

    cJSON* def;
    cJSON_ArrayForEach(def, component_defs) {
        cJSON* name = cJSON_GetObjectItem(def, "name");
        cJSON* props = cJSON_GetObjectItem(def, "props");
        cJSON* template = cJSON_GetObjectItem(def, "template");

        if (!name || !cJSON_IsString(name)) continue;

        const char* comp_name = cJSON_GetStringValue(name);

        // Generate component function signature
        fprintf(ctx->output, "/**\n");
        fprintf(ctx->output, " * Component: %s\n", comp_name);

        // Document props
        if (props && cJSON_IsArray(props)) {
            cJSON* prop;
            cJSON_ArrayForEach(prop, props) {
                cJSON* prop_name = cJSON_GetObjectItem(prop, "name");
                cJSON* prop_type = cJSON_GetObjectItem(prop, "type");
                if (prop_name && cJSON_IsString(prop_name)) {
                    fprintf(ctx->output, " * @param %s %s\n",
                            cJSON_GetStringValue(prop_name),
                            prop_type && cJSON_IsString(prop_type) ?
                            cJSON_GetStringValue(prop_type) : "any");
                }
            }
        }
        fprintf(ctx->output, " */\n");

        // Generate KRYON_COMPONENT macro call
        fprintf(ctx->output, "KRYON_COMPONENT(%s", comp_name);

        // Add props as macro parameters
        if (props && cJSON_IsArray(props)) {
            cJSON* prop;
            cJSON_ArrayForEach(prop, props) {
                cJSON* prop_name = cJSON_GetObjectItem(prop, "name");
                if (prop_name && cJSON_IsString(prop_name)) {
                    fprintf(ctx->output, ", %s", cJSON_GetStringValue(prop_name));
                }
            }
        }
        fprintf(ctx->output, ",\n");

        // Generate template content
        ctx->indent_level++;
        if (template) {
            generate_component_recursive(ctx, template, true);
        }
        ctx->indent_level--;

        fprintf(ctx->output, "\n);\n\n");
    }
}

/**
 * Generate C struct definitions from source_structures.struct_types
 */
static void generate_struct_definitions(CCodegenContext* ctx, cJSON* struct_types) {
    if (!struct_types || !cJSON_IsArray(struct_types)) return;

    cJSON* struct_def;
    cJSON_ArrayForEach(struct_def, struct_types) {
        cJSON* name = cJSON_GetObjectItem(struct_def, "name");
        cJSON* fields = cJSON_GetObjectItem(struct_def, "fields");

        if (!name || !cJSON_IsString(name)) continue;

        const char* struct_name = cJSON_GetStringValue(name);

        fprintf(ctx->output, "/**\n");
        fprintf(ctx->output, " * Struct: %s\n", struct_name);
        fprintf(ctx->output, " */\n");
        fprintf(ctx->output, "typedef struct {\n");

        if (fields && cJSON_IsArray(fields)) {
            cJSON* field;
            cJSON_ArrayForEach(field, fields) {
                cJSON* field_name = cJSON_GetObjectItem(field, "name");
                cJSON* field_type = cJSON_GetObjectItem(field, "type");

                if (!field_name || !cJSON_IsString(field_name)) continue;

                const char* fname = cJSON_GetStringValue(field_name);
                const char* ftype = field_type && cJSON_IsString(field_type) ?
                                    cJSON_GetStringValue(field_type) : "any";

                // Map KIR types to C types
                const char* c_type = "void*";  // default for 'any'
                if (strcmp(ftype, "string") == 0) {
                    c_type = "char*";
                } else if (strcmp(ftype, "int") == 0 || strcmp(ftype, "number") == 0) {
                    c_type = "int";
                } else if (strcmp(ftype, "float") == 0) {
                    c_type = "float";
                } else if (strcmp(ftype, "bool") == 0) {
                    c_type = "bool";
                }

                fprintf(ctx->output, "    %s %s;\n", c_type, fname);
            }
        }

        fprintf(ctx->output, "} %s;\n\n", struct_name);
    }
}

// ============================================================================
// Main Function Generation
// ============================================================================

static void generate_main_function(CCodegenContext* ctx) {
    fprintf(ctx->output, "int main(void) {\n");
    ctx->indent_level++;

    // kryon_init() call
    writeln(ctx, "kryon_init(\"Kryon App\", 800, 600);");
    fprintf(ctx->output, "\n");

    // KRYON_APP macro
    writeln(ctx, "KRYON_APP(");
    ctx->indent_level++;

    if (ctx->component_tree) {
        generate_component_recursive(ctx, ctx->component_tree, true);
        fprintf(ctx->output, "\n");
    }

    ctx->indent_level--;
    writeln(ctx, ");");
    fprintf(ctx->output, "\n");

    // KRYON_RUN macro
    writeln(ctx, "KRYON_RUN();");

    ctx->indent_level--;
    fprintf(ctx->output, "}\n");
}

// ============================================================================
// Main Code Generation Entry Points
// ============================================================================

bool ir_generate_c_code_from_string(const char* kir_json, const char* output_path) {
    if (!kir_json || !output_path) return false;

    // Parse KIR JSON
    cJSON* root = cJSON_Parse(kir_json);
    if (!root) {
        fprintf(stderr, "Error: Failed to parse KIR JSON\n");
        return false;
    }

    // Open output file
    FILE* output = fopen(output_path, "w");
    if (!output) {
        fprintf(stderr, "Error: Failed to open output file: %s\n", output_path);
        cJSON_Delete(root);
        return false;
    }

    // Setup context
    CCodegenContext ctx = {0};
    ctx.output = output;
    ctx.indent_level = 0;
    ctx.root_json = root;
    ctx.component_tree = cJSON_GetObjectItem(root, "root");
    ctx.c_metadata = cJSON_GetObjectItem(root, "c_metadata");

    if (ctx.c_metadata) {
        ctx.variables = cJSON_GetObjectItem(ctx.c_metadata, "variables");
        ctx.event_handlers = cJSON_GetObjectItem(ctx.c_metadata, "event_handlers");
        ctx.helper_functions = cJSON_GetObjectItem(ctx.c_metadata, "helper_functions");
        ctx.includes = cJSON_GetObjectItem(ctx.c_metadata, "includes");
        ctx.preprocessor_dirs = cJSON_GetObjectItem(ctx.c_metadata, "preprocessor_directives");
    }

    // Check if this is a component module (has component_definitions but no root)
    cJSON* component_defs = cJSON_GetObjectItem(root, "component_definitions");
    bool is_component_module = (component_defs && cJSON_IsArray(component_defs) &&
                                cJSON_GetArraySize(component_defs) > 0 &&
                                !ctx.component_tree);

    // Check for struct definitions in source_structures
    cJSON* source_structures = cJSON_GetObjectItem(root, "source_structures");
    cJSON* struct_types = source_structures ?
                          cJSON_GetObjectItem(source_structures, "struct_types") : NULL;
    bool has_struct_types = (struct_types && cJSON_IsArray(struct_types) &&
                             cJSON_GetArraySize(struct_types) > 0);

    // Check for exported functions or constants (utility modules)
    cJSON* exports = source_structures ?
                     cJSON_GetObjectItem(source_structures, "exports") : NULL;
    bool has_exports = (exports && cJSON_IsArray(exports) &&
                        cJSON_GetArraySize(exports) > 0);

    cJSON* const_decls = source_structures ?
                         cJSON_GetObjectItem(source_structures, "const_declarations") : NULL;
    bool has_const_decls = (const_decls && cJSON_IsArray(const_decls) &&
                            cJSON_GetArraySize(const_decls) > 0);

    // A utility module has exports/consts but no root or component definitions
    bool is_utility_module = (has_exports || has_const_decls) &&
                             !ctx.component_tree && !is_component_module;

    // Generate code sections
    generate_includes(&ctx);
    generate_preprocessor_directives(&ctx);

    // Generate struct definitions if present
    if (has_struct_types) {
        generate_struct_definitions(&ctx, struct_types);
    }

    generate_variable_declarations(&ctx);
    generate_helper_functions(&ctx);
    generate_event_handlers(&ctx);

    if (is_component_module) {
        // Generate component definitions for module files
        generate_component_definitions(&ctx, component_defs);
    } else if (is_utility_module) {
        // Utility modules: generate exported functions and constants
        cJSON* logic_block = cJSON_GetObjectItem(root, "logic_block");
        if (!generate_exported_functions(output, logic_block, exports, output_path)) {
            // Hard error occurred - cleanup and return false
            fclose(output);
            cJSON_Delete(root);
            return false;
        }
    } else if (ctx.component_tree) {
        // App files with root: generate main()
        generate_main_function(&ctx);
    }
    // Struct-only modules: struct is already generated, no main() needed

    // Cleanup
    fclose(output);
    cJSON_Delete(root);

    return true;
}

bool ir_generate_c_code(const char* kir_path, const char* output_path) {
    if (!kir_path || !output_path) return false;

    // Set error prefix for this codegen
    codegen_set_error_prefix("C");

    // Read KIR file using shared utility
    char* content = codegen_read_kir_file(kir_path, NULL);
    if (!content) {
        return false;
    }

    // Generate code
    bool result = ir_generate_c_code_from_string(content, output_path);
    free(content);

    return result;
}

/**
 * Convert module_id to include guard name (uppercase with underscores)
 */
static char* c_module_to_guard_name(const char* module_id) {
    if (!module_id) return strdup("COMPONENT_H");

    size_t len = strlen(module_id);
    char* result = malloc(len + 3);  // _H\0
    if (!result) return strdup("COMPONENT_H");

    for (size_t i = 0; i < len; i++) {
        if (module_id[i] == '/') {
            result[i] = '_';
        } else if (module_id[i] >= 'a' && module_id[i] <= 'z') {
            result[i] = module_id[i] - 'a' + 'A';  // To uppercase
        } else {
            result[i] = module_id[i];
        }
    }
    result[len] = '_';
    result[len + 1] = 'H';
    result[len + 2] = '\0';

    return result;
}

/**
 * Generate a header file (.h) for a C component
 */
static bool c_generate_header_file(const char* module_id, const char* output_dir) {
    char* guard_name = c_module_to_guard_name(module_id);

    char header_path[2048];
    snprintf(header_path, sizeof(header_path), "%s/%s.h", output_dir, module_id);

    // Generate header content
    char header_content[4096];
    snprintf(header_content, sizeof(header_content),
             "/**\n"
             " * %s - Auto-generated header\n"
             " * Generated by Kryon C Code Generator\n"
             " */\n\n"
             "#ifndef %s\n"
             "#define %s\n\n"
             "#include <kryon.h>\n"
             "#include <kryon_dsl.h>\n\n"
             "// Component declaration\n"
             "IRComponent* %s_create(void);\n\n"
             "#endif // %s\n",
             module_id, guard_name, guard_name,
             strrchr(module_id, '/') ? strrchr(module_id, '/') + 1 : module_id,
             guard_name);

    bool result = codegen_write_file_with_mkdir(header_path, header_content);

    free(guard_name);
    return result;
}

/**
 * Recursively process a module and its transitive imports for C
 */
static int c_process_module_recursive(const char* module_id, const char* kir_dir,
                                      const char* output_dir, CodegenProcessedModules* processed) {
    // Skip if already processed
    if (codegen_processed_modules_contains(processed, module_id)) return 0;
    codegen_processed_modules_add(processed, module_id);

    // Skip internal modules
    if (codegen_is_internal_module(module_id)) return 0;

    // Skip external plugins (they're runtime dependencies, not source)
    if (codegen_is_external_plugin(module_id)) return 0;

    // Build path to component's KIR file
    char component_kir_path[2048];
    snprintf(component_kir_path, sizeof(component_kir_path),
             "%s/%s.kir", kir_dir, module_id);

    // Read component's KIR
    char* component_kir_json = codegen_read_kir_file(component_kir_path, NULL);
    if (!component_kir_json) {
        fprintf(stderr, "Warning: Cannot find KIR for '%s' at %s\n",
                module_id, component_kir_path);
        return 0;
    }

    // Parse to get transitive imports before generating
    cJSON* component_root = cJSON_Parse(component_kir_json);
    int files_written = 0;

    // Generate C source file
    char c_output_path[2048];
    snprintf(c_output_path, sizeof(c_output_path), "%s/%s.c", output_dir, module_id);

    // Create parent directories if needed (e.g., for components/habit_panel.c)
    char* dir_copy = strdup(c_output_path);
    if (dir_copy) {
        char* last_slash = strrchr(dir_copy, '/');
        if (last_slash) {
            *last_slash = '\0';
            codegen_mkdir_p(dir_copy);
        }
        free(dir_copy);
    }

    if (ir_generate_c_code_from_string(component_kir_json, c_output_path)) {
        printf("✓ Generated: %s.c\n", module_id);
        files_written++;

        // Also generate header file
        if (c_generate_header_file(module_id, output_dir)) {
            printf("✓ Generated: %s.h\n", module_id);
            files_written++;
        }
    } else {
        fprintf(stderr, "Warning: Failed to generate C code for '%s'\n", module_id);
    }

    free(component_kir_json);

    // Process transitive imports from this component
    // Imports are in source_structures.requires[].module
    if (component_root) {
        cJSON* source_structures = cJSON_GetObjectItem(component_root, "source_structures");
        cJSON* requires = source_structures ? cJSON_GetObjectItem(source_structures, "requires") : NULL;
        if (requires && cJSON_IsArray(requires)) {
            cJSON* import_item = NULL;
            cJSON_ArrayForEach(import_item, requires) {
                cJSON* module_obj = cJSON_GetObjectItem(import_item, "module");
                if (!module_obj || !cJSON_IsString(module_obj)) continue;
                const char* module_path = cJSON_GetStringValue(module_obj);
                if (module_path) {
                    // Convert module path to file path format
                    char sub_module_id[512];
                    strncpy(sub_module_id, module_path, sizeof(sub_module_id) - 1);
                    sub_module_id[sizeof(sub_module_id) - 1] = '\0';
                    for (char* p = sub_module_id; *p; p++) {
                        if (*p == '.') *p = '/';
                    }
                    files_written += c_process_module_recursive(sub_module_id, kir_dir,
                                                                output_dir, processed);
                }
            }
        }
        cJSON_Delete(component_root);
    }

    return files_written;
}

bool ir_generate_c_code_multi(const char* kir_path, const char* output_dir) {
    if (!kir_path || !output_dir) {
        fprintf(stderr, "Error: Invalid arguments to ir_generate_c_code_multi\n");
        return false;
    }

    // Set error prefix for this codegen
    codegen_set_error_prefix("C");

    // Read main KIR file
    char* main_kir_json = codegen_read_kir_file(kir_path, NULL);
    if (!main_kir_json) {
        return false;
    }

    // Parse main KIR JSON
    cJSON* main_root = cJSON_Parse(main_kir_json);
    if (!main_root) {
        fprintf(stderr, "Error: Failed to parse main KIR JSON\n");
        free(main_kir_json);
        return false;
    }

    // Check if output_dir is actually a file path (ends with .c)
    size_t output_len = strlen(output_dir);
    bool is_file_output = (output_len > 2 && strcmp(output_dir + output_len - 2, ".c") == 0);

    char actual_output_dir[2048];
    char main_output_path[2048];

    if (is_file_output) {
        // Extract directory from file path
        const char* last_slash = strrchr(output_dir, '/');
        if (last_slash) {
            size_t dir_len = last_slash - output_dir;
            strncpy(actual_output_dir, output_dir, dir_len);
            actual_output_dir[dir_len] = '\0';
        } else {
            strcpy(actual_output_dir, ".");
        }
        // Use the provided path as-is for main.c
        strncpy(main_output_path, output_dir, sizeof(main_output_path) - 1);
        main_output_path[sizeof(main_output_path) - 1] = '\0';
    } else {
        // Treat as directory, append /main.c
        strncpy(actual_output_dir, output_dir, sizeof(actual_output_dir) - 1);
        actual_output_dir[sizeof(actual_output_dir) - 1] = '\0';
        snprintf(main_output_path, sizeof(main_output_path), "%s/main.c", output_dir);
    }

    // Create output directory if it doesn't exist
    if (!codegen_mkdir_p(actual_output_dir)) {
        fprintf(stderr, "Error: Could not create output directory: %s\n", actual_output_dir);
        cJSON_Delete(main_root);
        free(main_kir_json);
        return false;
    }

    int files_written = 0;

    // 1. Generate main.c from main.kir

    if (ir_generate_c_code_from_string(main_kir_json, main_output_path)) {
        printf("✓ Generated: main.c\n");
        files_written++;
    } else {
        fprintf(stderr, "Warning: Failed to generate main.c from KIR\n");
    }

    free(main_kir_json);

    // 2. Get the KIR directory (parent of kir_path)
    char kir_dir[2048];
    codegen_get_parent_dir(kir_path, kir_dir, sizeof(kir_dir));

    // 3. Track processed modules to avoid duplicates
    CodegenProcessedModules processed = {0};
    codegen_processed_modules_add(&processed, "main");  // Mark main as processed

    // 4. Process each import recursively (including transitive imports)
    // Imports are in source_structures.requires[].module
    cJSON* source_structures = cJSON_GetObjectItem(main_root, "source_structures");
    cJSON* requires = source_structures ? cJSON_GetObjectItem(source_structures, "requires") : NULL;
    if (requires && cJSON_IsArray(requires)) {
        cJSON* import_item = NULL;
        cJSON_ArrayForEach(import_item, requires) {
            cJSON* module_obj = cJSON_GetObjectItem(import_item, "module");
            if (!module_obj || !cJSON_IsString(module_obj)) continue;

            const char* module_path = cJSON_GetStringValue(module_obj);
            if (module_path) {
                // Convert module path (e.g., "components.habit_panel") to file path format
                char module_id[512];
                strncpy(module_id, module_path, sizeof(module_id) - 1);
                module_id[sizeof(module_id) - 1] = '\0';
                // Replace dots with slashes for file path
                for (char* p = module_id; *p; p++) {
                    if (*p == '.') *p = '/';
                }
                files_written += c_process_module_recursive(module_id, kir_dir,
                                                            actual_output_dir, &processed);
            }
        }
    }

    codegen_processed_modules_free(&processed);
    cJSON_Delete(main_root);

    if (files_written == 0) {
        fprintf(stderr, "Warning: No C files were generated\n");
        return false;
    }

    printf("✓ Generated %d C files in %s\n", files_written, actual_output_dir);
    return true;
}
