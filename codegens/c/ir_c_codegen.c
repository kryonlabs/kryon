/**
 * C Code Generator - KIR → C Source Code
 *
 * Generates idiomatic C code with Kryon DSL from KIR JSON files
 */

#include "ir_c_codegen.h"
#include "ir_c_internal.h"
#include "ir_c_output.h"
#include "ir_c_types.h"
#include "ir_c_reactive.h"
#include "ir_c_expression.h"
#include "ir_c_components.h"
#include "ir_c_main.h"
#include "ir_c_modules.h"
#include "../codegen_common.h"
#include "../../ir/src/utils/ir_c_metadata.h"
#include "../../third_party/cJSON/cJSON.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <ctype.h>

// ============================================================================
// Internal Aliases for Utility Functions
// ============================================================================

// These aliases allow existing code to use the shorter names
#define write_indent(ctx) c_write_indent(ctx)
#define writeln(ctx, str) c_writeln(ctx, str)
#define write_raw(ctx, str) c_write_raw(ctx, str)

// Reactive function aliases
#define is_reactive_variable(ctx, name) c_is_reactive_variable(ctx, name)
#define get_scoped_var_name(ctx, name) c_get_scoped_var_name(ctx, name)
#define generate_scoped_var_name(name, scope) c_generate_scoped_var_name(name, scope)
#define get_signal_creator(type) c_get_signal_creator(type)
#define generate_reactive_signal_declarations(ctx) c_generate_reactive_signal_declarations(ctx)
#define generate_reactive_signal_initialization(ctx) c_generate_reactive_signal_initialization(ctx)
#define generate_reactive_signal_cleanup(ctx) c_generate_reactive_signal_cleanup(ctx)

// Expression/statement function aliases (from ir_c_expression.h)
#define is_range_call(expr, start, end) c_is_range_call(expr, start, end)
#define expr_to_c(expr) c_expr_to_c(expr)
#define stmt_to_c(output, stmt, indent, path) c_stmt_to_c(output, stmt, indent, path)

// Component generation aliases (from ir_c_components.h)
#define generate_component_recursive(ctx, comp, root) c_generate_component_recursive(ctx, comp, root)
#define generate_property_macro(ctx, key, val, first) c_generate_property_macro(ctx, key, val, first)
#define generate_component_definitions(ctx, defs) c_generate_component_definitions(ctx, defs)

// Main/struct generation aliases (from ir_c_main.h)
#define generate_struct_definitions(ctx, types) c_generate_struct_definitions(ctx, types)
#define generate_main_function(ctx) c_generate_main_function(ctx)

// ============================================================================
// Utility Functions
// ============================================================================

// get_variable_for_component_id moved to ir_c_components.c
// get_component_macro moved to ir_c_types.c

// ============================================================================
// Header Generation
// ============================================================================

// Helper to check if the KIR has any array variables
static bool has_array_variables(CCodegenContext* ctx) {
    if (!ctx || !ctx->root_json) return false;

    cJSON* source_structures = cJSON_GetObjectItem(ctx->root_json, "source_structures");
    if (!source_structures) return false;

    cJSON* const_decls = cJSON_GetObjectItem(source_structures, "const_declarations");
    if (!const_decls || !cJSON_IsArray(const_decls)) return false;

    cJSON* decl;
    cJSON_ArrayForEach(decl, const_decls) {
        cJSON* value_type = cJSON_GetObjectItem(decl, "value_type");
        if (value_type && value_type->valuestring && strcmp(value_type->valuestring, "array") == 0) {
            return true;
        }
    }
    return false;
}

void generate_includes(CCodegenContext* ctx) {
    fprintf(ctx->output, "/**\n");
    fprintf(ctx->output, " * Auto-generated C code from .kir file\n");
    fprintf(ctx->output, " * Generated by Kryon C Code Generator\n");
    fprintf(ctx->output, " */\n\n");

    // Check if we need reactive includes
    bool needs_reactive = ctx->has_reactive_state;
    bool needs_arrays = has_array_variables(ctx);

    // Generate includes from metadata
    if (ctx->includes && cJSON_IsArray(ctx->includes)) {
        int count = cJSON_GetArraySize(ctx->includes);
        for (int i = 0; i < count; i++) {
            cJSON* inc = cJSON_GetArrayItem(ctx->includes, i);
            cJSON* include_str = cJSON_GetObjectItem(inc, "include");
            if (include_str && include_str->valuestring) {
                fprintf(ctx->output, "#include %s\n", include_str->valuestring);
            }
        }
    } else {
        // Default includes if no metadata
        fprintf(ctx->output, "#include <kryon.h>\n");
        fprintf(ctx->output, "#include <kryon_dsl.h>\n");
        if (needs_reactive) {
            fprintf(ctx->output, "#include <kryon_reactive.h>\n");
            fprintf(ctx->output, "#include <kryon_reactive_ui.h>\n");
        }
        fprintf(ctx->output, "#include <stdio.h>\n");
        fprintf(ctx->output, "#include <stdbool.h>\n");
    }

    // Add stdlib.h and string.h for array support (malloc, strdup)
    if (needs_arrays) {
        fprintf(ctx->output, "#include <stdlib.h>\n");
        fprintf(ctx->output, "#include <string.h>\n");
    }

    // ALWAYS add reactive headers if needed (even if metadata has includes)
    if (needs_reactive && ctx->includes && cJSON_IsArray(ctx->includes)) {
        bool has_reactive_headers = false;
        int count = cJSON_GetArraySize(ctx->includes);
        for (int i = 0; i < count; i++) {
            cJSON* inc = cJSON_GetArrayItem(ctx->includes, i);
            cJSON* include_str = cJSON_GetObjectItem(inc, "include");
            if (include_str && include_str->valuestring) {
                if (strstr(include_str->valuestring, "kryon_reactive") != NULL) {
                    has_reactive_headers = true;
                    break;
                }
            }
        }
        if (!has_reactive_headers) {
            fprintf(ctx->output, "#include <kryon_reactive.h>\n");
            fprintf(ctx->output, "#include <kryon_reactive_ui.h>\n");
        }
    }
    fprintf(ctx->output, "\n");
}

void generate_preprocessor_directives(CCodegenContext* ctx) {
    if (!ctx->preprocessor_dirs || !cJSON_IsArray(ctx->preprocessor_dirs)) {
        return;
    }

    int count = cJSON_GetArraySize(ctx->preprocessor_dirs);
    if (count == 0) return;

    for (int i = 0; i < count; i++) {
        cJSON* dir = cJSON_GetArrayItem(ctx->preprocessor_dirs, i);
        cJSON* type = cJSON_GetObjectItem(dir, "directive_type");
        cJSON* condition = cJSON_GetObjectItem(dir, "condition");
        cJSON* value = cJSON_GetObjectItem(dir, "value");

        if (!type || !type->valuestring) continue;

        if (strcmp(type->valuestring, "define") == 0) {
            fprintf(ctx->output, "#define ");
            if (condition && condition->valuestring) {
                fprintf(ctx->output, "%s ", condition->valuestring);
            }
            if (value && value->valuestring) {
                fprintf(ctx->output, "%s", value->valuestring);
            }
            fprintf(ctx->output, "\n");
        } else if (strcmp(type->valuestring, "ifdef") == 0 && condition && condition->valuestring) {
            fprintf(ctx->output, "#ifdef %s\n", condition->valuestring);
        } else if (strcmp(type->valuestring, "ifndef") == 0 && condition && condition->valuestring) {
            fprintf(ctx->output, "#ifndef %s\n", condition->valuestring);
        } else if (strcmp(type->valuestring, "if") == 0 && condition && condition->valuestring) {
            fprintf(ctx->output, "#if %s\n", condition->valuestring);
        } else if (strcmp(type->valuestring, "elif") == 0 && condition && condition->valuestring) {
            fprintf(ctx->output, "#elif %s\n", condition->valuestring);
        } else if (strcmp(type->valuestring, "else") == 0) {
            fprintf(ctx->output, "#else\n");
        } else if (strcmp(type->valuestring, "endif") == 0) {
            fprintf(ctx->output, "#endif\n");
        }
    }
    fprintf(ctx->output, "\n");
}

// Note: Expression/statement conversion functions (expr_to_c, stmt_to_c, is_range_call)
// are now in ir_c_expression.c and accessed via macros defined above.

// is_range_call removed - now in ir_c_expression.c

/**
 * Generate exported functions from logic_block
 * Returns false on hard error (unsupported constructs)
 */
bool generate_exported_functions(FILE* output, cJSON* logic_block, cJSON* exports, const char* output_path) {
    if (!logic_block || !exports) return true;

    cJSON* functions = cJSON_GetObjectItem(logic_block, "functions");
    if (!functions || !cJSON_IsArray(functions)) return true;

    fprintf(output, "// Exported functions\n");

    // For each export, find and generate the function
    cJSON* export_item;
    cJSON_ArrayForEach(export_item, exports) {
        cJSON* name = cJSON_GetObjectItem(export_item, "name");
        cJSON* type = cJSON_GetObjectItem(export_item, "type");

        if (!name || !cJSON_IsString(name)) continue;
        const char* export_name = name->valuestring;
        const char* export_type = type && cJSON_IsString(type) ? type->valuestring : "";

        // Skip non-function exports
        if (strcmp(export_type, "function") != 0) continue;

        // Find function in logic_block.functions
        cJSON* func;
        bool found = false;
        cJSON_ArrayForEach(func, functions) {
            cJSON* func_name = cJSON_GetObjectItem(func, "name");
            if (!func_name || !cJSON_IsString(func_name)) continue;
            if (strcmp(func_name->valuestring, export_name) != 0) continue;

            found = true;

            // Check for universal statements
            cJSON* universal = cJSON_GetObjectItem(func, "universal");
            if (!universal) {
                fprintf(stderr, "[C Codegen] Error: Exported function '%s' has no universal implementation.\n",
                        export_name);
                fprintf(stderr, "            File: %s\n", output_path ? output_path : "unknown");
                return false;
            }

            cJSON* statements = cJSON_GetObjectItem(universal, "statements");
            if (!statements || !cJSON_IsArray(statements)) {
                // Empty function body - might be just a declaration
                statements = NULL;
            }

            // Get return type and parameters
            cJSON* return_type = cJSON_GetObjectItem(func, "return_type");
            cJSON* params = cJSON_GetObjectItem(func, "params");

            const char* ret_type_str = return_type && cJSON_IsString(return_type) ?
                                       return_type->valuestring : "void";
            const char* c_ret_type = kir_type_to_c(ret_type_str);

            // Generate function signature
            fprintf(output, "\n%s %s(", c_ret_type, export_name);

            // Generate parameters
            if (params && cJSON_IsArray(params) && cJSON_GetArraySize(params) > 0) {
                int param_count = cJSON_GetArraySize(params);
                for (int i = 0; i < param_count; i++) {
                    cJSON* param = cJSON_GetArrayItem(params, i);
                    cJSON* param_name = cJSON_GetObjectItem(param, "name");
                    cJSON* param_type = cJSON_GetObjectItem(param, "type");

                    const char* p_name = param_name && cJSON_IsString(param_name) ?
                                         param_name->valuestring : "arg";
                    const char* p_type = param_type && cJSON_IsString(param_type) ?
                                         param_type->valuestring : "any";

                    if (i > 0) fprintf(output, ", ");
                    fprintf(output, "%s %s", kir_type_to_c(p_type), p_name);
                }
            } else {
                fprintf(output, "void");
            }
            fprintf(output, ") {\n");

            // Generate statements
            if (statements) {
                cJSON* stmt;
                cJSON_ArrayForEach(stmt, statements) {
                    if (!stmt_to_c(output, stmt, 4, output_path)) {
                        return false;  // Hard error
                    }
                }
            }

            fprintf(output, "}\n");
            break;
        }

        if (!found) {
            fprintf(stderr, "[C Codegen] Warning: Exported function '%s' not found in logic_block.\n",
                    export_name);
        }
    }

    return true;
}

// ============================================================================
// Variable & Function Generation
// ============================================================================

void generate_variable_declarations(CCodegenContext* ctx) {
    if (!ctx->variables || !cJSON_IsArray(ctx->variables)) {
        return;
    }

    int count = cJSON_GetArraySize(ctx->variables);
    if (count == 0) return;

    fprintf(ctx->output, "// Component variables\n");
    for (int i = 0; i < count; i++) {
        cJSON* var = cJSON_GetArrayItem(ctx->variables, i);
        cJSON* storage = cJSON_GetObjectItem(var, "storage");
        cJSON* type = cJSON_GetObjectItem(var, "type");
        cJSON* name = cJSON_GetObjectItem(var, "name");
        cJSON* initial = cJSON_GetObjectItem(var, "initial_value");

        if (!name || !name->valuestring || !type || !type->valuestring) continue;

        if (storage && storage->valuestring) {
            fprintf(ctx->output, "%s ", storage->valuestring);
        }
        fprintf(ctx->output, "%s %s", type->valuestring, name->valuestring);

        if (initial && initial->valuestring) {
            fprintf(ctx->output, " = %s", initial->valuestring);
        }
        fprintf(ctx->output, ";\n");
    }
    fprintf(ctx->output, "\n");
}

void generate_helper_functions(CCodegenContext* ctx) {
    if (!ctx->helper_functions || !cJSON_IsArray(ctx->helper_functions)) {
        return;
    }

    int count = cJSON_GetArraySize(ctx->helper_functions);
    if (count == 0) return;

    fprintf(ctx->output, "// Helper functions\n");
    for (int i = 0; i < count; i++) {
        cJSON* func = cJSON_GetArrayItem(ctx->helper_functions, i);
        cJSON* return_type = cJSON_GetObjectItem(func, "return_type");
        cJSON* name = cJSON_GetObjectItem(func, "name");
        cJSON* params = cJSON_GetObjectItem(func, "parameters");
        cJSON* body = cJSON_GetObjectItem(func, "body");

        if (!name || !name->valuestring || !return_type || !return_type->valuestring) continue;

        fprintf(ctx->output, "%s %s(%s) {\n",
                return_type->valuestring,
                name->valuestring,
                (params && params->valuestring) ? params->valuestring : "void");

        if (body && body->valuestring) {
            fprintf(ctx->output, "%s\n", body->valuestring);
        }

        fprintf(ctx->output, "}\n\n");
    }
}

void generate_event_handlers(CCodegenContext* ctx) {
    if (!ctx->event_handlers || !cJSON_IsArray(ctx->event_handlers)) {
        return;
    }

    int count = cJSON_GetArraySize(ctx->event_handlers);
    if (count == 0) return;

    fprintf(ctx->output, "// Event handlers\n");
    for (int i = 0; i < count; i++) {
        cJSON* handler = cJSON_GetArrayItem(ctx->event_handlers, i);
        cJSON* return_type = cJSON_GetObjectItem(handler, "return_type");
        cJSON* name = cJSON_GetObjectItem(handler, "function_name");
        cJSON* params = cJSON_GetObjectItem(handler, "parameters");
        cJSON* body = cJSON_GetObjectItem(handler, "body");

        if (!name || !name->valuestring || !return_type || !return_type->valuestring) continue;

        fprintf(ctx->output, "%s %s(%s) {\n",
                return_type->valuestring,
                name->valuestring,
                (params && params->valuestring) ? params->valuestring : "void");

        if (body && body->valuestring) {
            fprintf(ctx->output, "%s\n", body->valuestring);
        }

        fprintf(ctx->output, "}\n\n");
    }
}

// ============================================================================
// Array Declarations and Helper Functions
// ============================================================================

/**
 * Generate array declarations from source_structures.const_declarations
 * Also generates helper array manipulation functions
 */
void generate_array_declarations(CCodegenContext* ctx) {
    if (!ctx || !ctx->root_json) return;

    cJSON* source_structures = cJSON_GetObjectItem(ctx->root_json, "source_structures");
    if (!source_structures) return;

    cJSON* const_decls = cJSON_GetObjectItem(source_structures, "const_declarations");
    if (!const_decls || !cJSON_IsArray(const_decls)) return;

    // Check if we have any arrays
    bool has_arrays = false;
    cJSON* decl;
    cJSON_ArrayForEach(decl, const_decls) {
        cJSON* value_type = cJSON_GetObjectItem(decl, "value_type");
        if (value_type && value_type->valuestring && strcmp(value_type->valuestring, "array") == 0) {
            has_arrays = true;
            break;
        }
    }

    if (!has_arrays) return;

    // Generate array type definition and helper macros
    fprintf(ctx->output, "// ============================================================================\n");
    fprintf(ctx->output, "// Dynamic Array Support\n");
    fprintf(ctx->output, "// ============================================================================\n\n");

    fprintf(ctx->output, "#define KRYON_ARRAY_INITIAL_CAPACITY 16\n\n");

    fprintf(ctx->output, "typedef struct {\n");
    fprintf(ctx->output, "    char** items;\n");
    fprintf(ctx->output, "    size_t count;\n");
    fprintf(ctx->output, "    size_t capacity;\n");
    fprintf(ctx->output, "} KryonStringArray;\n\n");

    // Generate array helper functions
    fprintf(ctx->output, "static void kryon_array_init(KryonStringArray* arr) {\n");
    fprintf(ctx->output, "    arr->items = malloc(sizeof(char*) * KRYON_ARRAY_INITIAL_CAPACITY);\n");
    fprintf(ctx->output, "    arr->count = 0;\n");
    fprintf(ctx->output, "    arr->capacity = KRYON_ARRAY_INITIAL_CAPACITY;\n");
    fprintf(ctx->output, "}\n\n");

    fprintf(ctx->output, "static void kryon_array_push_string(KryonStringArray* arr, const char* str) {\n");
    fprintf(ctx->output, "    if (arr->count >= arr->capacity) {\n");
    fprintf(ctx->output, "        arr->capacity *= 2;\n");
    fprintf(ctx->output, "        arr->items = realloc(arr->items, sizeof(char*) * arr->capacity);\n");
    fprintf(ctx->output, "    }\n");
    fprintf(ctx->output, "    arr->items[arr->count++] = strdup(str);\n");
    fprintf(ctx->output, "}\n\n");

    fprintf(ctx->output, "static void kryon_array_free(KryonStringArray* arr) {\n");
    fprintf(ctx->output, "    for (size_t i = 0; i < arr->count; i++) {\n");
    fprintf(ctx->output, "        free(arr->items[i]);\n");
    fprintf(ctx->output, "    }\n");
    fprintf(ctx->output, "    free(arr->items);\n");
    fprintf(ctx->output, "    arr->items = NULL;\n");
    fprintf(ctx->output, "    arr->count = 0;\n");
    fprintf(ctx->output, "    arr->capacity = 0;\n");
    fprintf(ctx->output, "}\n\n");

    // Generate dynamic list container tracking
    fprintf(ctx->output, "// Dynamic list support - tracks FOR_EACH containers for runtime updates\n");
    fprintf(ctx->output, "typedef struct {\n");
    fprintf(ctx->output, "    IRComponent* container;      // Parent component containing list items\n");
    fprintf(ctx->output, "    KryonStringArray* array;     // Pointer to source array\n");
    fprintf(ctx->output, "    size_t rendered_count;       // Number of items currently rendered\n");
    fprintf(ctx->output, "    const char* format_str;      // Format string for text (e.g., \"- %%s\")\n");
    fprintf(ctx->output, "} KryonDynamicList;\n\n");

    fprintf(ctx->output, "#define MAX_DYNAMIC_LISTS 8\n");
    fprintf(ctx->output, "static KryonDynamicList _dynamic_lists[MAX_DYNAMIC_LISTS];\n");
    fprintf(ctx->output, "static int _dynamic_list_count = 0;\n\n");

    fprintf(ctx->output, "static void kryon_register_dynamic_list(IRComponent* container, KryonStringArray* array, const char* format) {\n");
    fprintf(ctx->output, "    if (_dynamic_list_count >= MAX_DYNAMIC_LISTS) return;\n");
    fprintf(ctx->output, "    _dynamic_lists[_dynamic_list_count].container = container;\n");
    fprintf(ctx->output, "    _dynamic_lists[_dynamic_list_count].array = array;\n");
    fprintf(ctx->output, "    _dynamic_lists[_dynamic_list_count].rendered_count = array->count;\n");
    fprintf(ctx->output, "    _dynamic_lists[_dynamic_list_count].format_str = format;\n");
    fprintf(ctx->output, "    _dynamic_list_count++;\n");
    fprintf(ctx->output, "}\n\n");

    fprintf(ctx->output, "// Update dynamic lists - adds new items to FOR_EACH containers\n");
    fprintf(ctx->output, "static void kryon_update_dynamic_lists(void) {\n");
    fprintf(ctx->output, "    for (int i = 0; i < _dynamic_list_count; i++) {\n");
    fprintf(ctx->output, "        KryonDynamicList* list = &_dynamic_lists[i];\n");
    fprintf(ctx->output, "        if (!list->container || !list->array) continue;\n");
    fprintf(ctx->output, "        \n");
    fprintf(ctx->output, "        // Check if new items were added\n");
    fprintf(ctx->output, "        while (list->rendered_count < list->array->count) {\n");
    fprintf(ctx->output, "            const char* item = list->array->items[list->rendered_count];\n");
    fprintf(ctx->output, "            \n");
    fprintf(ctx->output, "            // Create new TEXT component\n");
    fprintf(ctx->output, "            char buf[256];\n");
    fprintf(ctx->output, "            snprintf(buf, sizeof(buf), list->format_str, item);\n");
    fprintf(ctx->output, "            IRComponent* text = kryon_text(buf);\n");
    fprintf(ctx->output, "            kryon_set_font_size(text, 16);\n");
    fprintf(ctx->output, "            kryon_set_color(text, 0x333333);\n");
    fprintf(ctx->output, "            \n");
    fprintf(ctx->output, "            // Add to container\n");
    fprintf(ctx->output, "            kryon_add_child(list->container, text);\n");
    fprintf(ctx->output, "            \n");
    fprintf(ctx->output, "            list->rendered_count++;\n");
    fprintf(ctx->output, "        }\n");
    fprintf(ctx->output, "    }\n");
    fprintf(ctx->output, "}\n\n");

    fprintf(ctx->output, "// UI update request - updates dynamic lists\n");
    fprintf(ctx->output, "static void kryon_request_rerender(void) {\n");
    fprintf(ctx->output, "    kryon_update_dynamic_lists();\n");
    fprintf(ctx->output, "}\n\n");

    // Generate TEXT_FMT helper for formatted strings in for-loops
    fprintf(ctx->output, "// Helper for formatted text in for-loops\n");
    fprintf(ctx->output, "static char _kryon_text_fmt_buf[512];\n");
    fprintf(ctx->output, "#define TEXT_FMT(fmt, val, ...) \\\n");
    fprintf(ctx->output, "    (snprintf(_kryon_text_fmt_buf, sizeof(_kryon_text_fmt_buf), fmt, val), \\\n");
    fprintf(ctx->output, "     TEXT(_kryon_text_fmt_buf, ##__VA_ARGS__))\n\n");

    // Generate TEXT_ITEM helper for use inside component property lists
    // This is used when a text template uses a for-loop iterator variable
    fprintf(ctx->output, "#define TEXT_ITEM(fmt, val) \\\n");
    fprintf(ctx->output, "    (snprintf(_kryon_text_fmt_buf, sizeof(_kryon_text_fmt_buf), fmt, val), \\\n");
    fprintf(ctx->output, "     _kryon_set_component_text(_comp, _kryon_text_fmt_buf), (void)0)\n\n");

    // Generate array variable declarations
    fprintf(ctx->output, "// Array variables\n");
    cJSON_ArrayForEach(decl, const_decls) {
        cJSON* name = cJSON_GetObjectItem(decl, "name");
        cJSON* value_type = cJSON_GetObjectItem(decl, "value_type");
        cJSON* value_json = cJSON_GetObjectItem(decl, "value_json");

        if (!name || !name->valuestring) continue;
        if (!value_type || !value_type->valuestring || strcmp(value_type->valuestring, "array") != 0) continue;

        // Declare the array
        fprintf(ctx->output, "KryonStringArray %s_array;\n", name->valuestring);
    }
    fprintf(ctx->output, "\n");

    // Generate array initialization function
    fprintf(ctx->output, "static void kryon_init_arrays(void) {\n");
    cJSON_ArrayForEach(decl, const_decls) {
        cJSON* name = cJSON_GetObjectItem(decl, "name");
        cJSON* value_type = cJSON_GetObjectItem(decl, "value_type");
        cJSON* value_json = cJSON_GetObjectItem(decl, "value_json");

        if (!name || !name->valuestring) continue;
        if (!value_type || !value_type->valuestring || strcmp(value_type->valuestring, "array") != 0) continue;

        fprintf(ctx->output, "    kryon_array_init(&%s_array);\n", name->valuestring);

        // Parse initial values from value_json (e.g., "[\"item1\", \"item2\"]")
        if (value_json && value_json->valuestring) {
            cJSON* initial_array = cJSON_Parse(value_json->valuestring);
            if (initial_array && cJSON_IsArray(initial_array)) {
                cJSON* item;
                cJSON_ArrayForEach(item, initial_array) {
                    if (cJSON_IsString(item)) {
                        // Escape quotes in string
                        fprintf(ctx->output, "    kryon_array_push_string(&%s_array, \"%s\");\n",
                                name->valuestring, item->valuestring);
                    }
                }
                cJSON_Delete(initial_array);
            }
        }
    }
    fprintf(ctx->output, "}\n\n");

    // Generate array cleanup function
    fprintf(ctx->output, "static void kryon_cleanup_arrays(void) {\n");
    cJSON_ArrayForEach(decl, const_decls) {
        cJSON* name = cJSON_GetObjectItem(decl, "name");
        cJSON* value_type = cJSON_GetObjectItem(decl, "value_type");

        if (!name || !name->valuestring) continue;
        if (!value_type || !value_type->valuestring || strcmp(value_type->valuestring, "array") != 0) continue;

        fprintf(ctx->output, "    kryon_array_free(&%s_array);\n", name->valuestring);
    }
    fprintf(ctx->output, "}\n\n");
}

// ============================================================================
// KRY Event Handler Transpilation
// ============================================================================

// Statement types for KRY parser
typedef enum {
    KRY_STMT_UNKNOWN,
    KRY_STMT_METHOD_CALL,     // object.method(args)
    KRY_STMT_ASSIGNMENT,      // variable = value
    KRY_STMT_COMPOUND_ASSIGN, // variable += value, variable -= value
    KRY_STMT_BOOL_TOGGLE      // variable = !variable
} KryStmtType;

typedef struct {
    KryStmtType type;
    char object[128];     // For method calls: the object (e.g., "todos")
    char method[64];      // For method calls: the method (e.g., "add")
    char args[256];       // For method calls: the arguments (e.g., "newTodo")
    char target[128];     // For assignments: the target variable
    char value[256];      // For assignments: the value
    char op[4];           // For compound assignments: the operator (+= / -=)
    int delta;            // For compound assignments: the numeric delta
} KryParsedStmt;

/**
 * Skip whitespace in a string
 */
static const char* skip_whitespace(const char* s) {
    while (*s && (*s == ' ' || *s == '\t' || *s == '\n' || *s == '\r')) {
        s++;
    }
    return s;
}

/**
 * Parse an identifier (variable name, method name)
 * Returns pointer to character after identifier, or NULL on failure
 */
static const char* parse_identifier(const char* s, char* out, size_t out_size) {
    s = skip_whitespace(s);
    size_t len = 0;

    // First char must be letter or underscore
    if (!*s || !((*s >= 'a' && *s <= 'z') || (*s >= 'A' && *s <= 'Z') || *s == '_')) {
        return NULL;
    }

    while (*s && ((*s >= 'a' && *s <= 'z') || (*s >= 'A' && *s <= 'Z') ||
                  (*s >= '0' && *s <= '9') || *s == '_')) {
        if (len < out_size - 1) {
            out[len++] = *s;
        }
        s++;
    }
    out[len] = '\0';
    return s;
}

/**
 * Parse a string literal (including quotes)
 * Returns pointer to character after closing quote, or NULL on failure
 */
static const char* parse_string_literal(const char* s, char* out, size_t out_size) {
    s = skip_whitespace(s);
    if (*s != '"') return NULL;

    size_t len = 0;
    out[len++] = *s++; // Opening quote

    while (*s && *s != '"') {
        if (*s == '\\' && s[1]) {
            // Handle escape sequences
            if (len < out_size - 2) {
                out[len++] = *s++;
                out[len++] = *s++;
            } else {
                s += 2;
            }
        } else {
            if (len < out_size - 1) {
                out[len++] = *s;
            }
            s++;
        }
    }

    if (*s == '"') {
        if (len < out_size - 1) {
            out[len++] = *s;
        }
        s++;
    }
    out[len] = '\0';
    return s;
}

/**
 * Parse a simple value (identifier or string literal)
 * Returns pointer to character after value, or NULL on failure
 */
static const char* parse_value(const char* s, char* out, size_t out_size) {
    s = skip_whitespace(s);
    if (*s == '"') {
        return parse_string_literal(s, out, out_size);
    } else {
        return parse_identifier(s, out, out_size);
    }
}

/**
 * Parse a single KRY statement
 * Returns true if parsed successfully
 */
static bool parse_kry_statement(const char* stmt, KryParsedStmt* out) {
    if (!stmt || !out) return false;

    memset(out, 0, sizeof(*out));
    out->type = KRY_STMT_UNKNOWN;

    const char* p = skip_whitespace(stmt);
    if (!*p || *p == '}') return false; // Empty or closing brace

    // Parse the first identifier
    char first_ident[128] = {0};
    const char* after_first = parse_identifier(p, first_ident, sizeof(first_ident));
    if (!after_first) return false;

    const char* after_ws = skip_whitespace(after_first);

    // Check what follows the first identifier
    if (*after_ws == '.') {
        // Method call: object.method(args)
        after_ws++; // Skip '.'

        char method[64] = {0};
        const char* after_method = parse_identifier(after_ws, method, sizeof(method));
        if (!after_method) return false;

        after_ws = skip_whitespace(after_method);
        if (*after_ws != '(') return false;
        after_ws++; // Skip '('

        // Parse arguments (for now, just capture until closing paren)
        char args[256] = {0};
        size_t arg_len = 0;
        int paren_depth = 1;

        while (*after_ws && paren_depth > 0) {
            if (*after_ws == '(') paren_depth++;
            else if (*after_ws == ')') paren_depth--;

            if (paren_depth > 0 && arg_len < sizeof(args) - 1) {
                args[arg_len++] = *after_ws;
            }
            after_ws++;
        }
        args[arg_len] = '\0';

        // Trim whitespace from args
        while (arg_len > 0 && (args[arg_len-1] == ' ' || args[arg_len-1] == '\t')) {
            args[--arg_len] = '\0';
        }

        out->type = KRY_STMT_METHOD_CALL;
        strncpy(out->object, first_ident, sizeof(out->object) - 1);
        strncpy(out->method, method, sizeof(out->method) - 1);
        strncpy(out->args, args, sizeof(out->args) - 1);
        return true;

    } else if (*after_ws == '+' && after_ws[1] == '=') {
        // Compound assignment: variable += value
        after_ws += 2; // Skip '+='

        char value[256] = {0};
        const char* after_val = parse_value(after_ws, value, sizeof(value));
        if (!after_val) return false;

        out->type = KRY_STMT_COMPOUND_ASSIGN;
        strncpy(out->target, first_ident, sizeof(out->target) - 1);
        strcpy(out->op, "+=");
        out->delta = atoi(value);
        return true;

    } else if (*after_ws == '-' && after_ws[1] == '=') {
        // Compound assignment: variable -= value
        after_ws += 2; // Skip '-='

        char value[256] = {0};
        const char* after_val = parse_value(after_ws, value, sizeof(value));
        if (!after_val) return false;

        out->type = KRY_STMT_COMPOUND_ASSIGN;
        strncpy(out->target, first_ident, sizeof(out->target) - 1);
        strcpy(out->op, "-=");
        out->delta = atoi(value);
        return true;

    } else if (*after_ws == '=') {
        // Assignment or boolean toggle
        after_ws++; // Skip '='
        after_ws = skip_whitespace(after_ws);

        // Save position for regular assignment parsing
        const char* value_start = after_ws;

        // Check for boolean toggle: variable = !variable
        if (*after_ws == '!') {
            const char* after_bang = after_ws + 1; // Skip '!'
            char negated[128] = {0};
            parse_identifier(after_bang, negated, sizeof(negated));

            if (strcmp(first_ident, negated) == 0) {
                out->type = KRY_STMT_BOOL_TOGGLE;
                strncpy(out->target, first_ident, sizeof(out->target) - 1);
                return true;
            }
            // Not a toggle, fall through to regular assignment
        }

        // Regular assignment - parse value from saved position
        char value[256] = {0};
        const char* after_val = parse_value(value_start, value, sizeof(value));
        if (!after_val) {
            // parse_value failed, try parsing as raw expression
            size_t val_len = 0;
            const char* p = value_start;
            while (*p && *p != '\n' && *p != ';' && *p != '}') {
                if (val_len < sizeof(value) - 1) {
                    value[val_len++] = *p;
                }
                p++;
            }
            value[val_len] = '\0';
            // Trim trailing whitespace
            while (val_len > 0 && (value[val_len-1] == ' ' || value[val_len-1] == '\t')) {
                value[--val_len] = '\0';
            }
        }

        out->type = KRY_STMT_ASSIGNMENT;
        strncpy(out->target, first_ident, sizeof(out->target) - 1);
        strncpy(out->value, value, sizeof(out->value) - 1);
        return true;
    }

    return false;
}

/**
 * Check if a variable is an array (from source_structures.const_declarations)
 */
static bool is_array_variable(CCodegenContext* ctx, const char* name) {
    if (!ctx || !ctx->root_json || !name) return false;

    cJSON* source_structures = cJSON_GetObjectItem(ctx->root_json, "source_structures");
    if (!source_structures) return false;

    cJSON* const_decls = cJSON_GetObjectItem(source_structures, "const_declarations");
    if (!const_decls || !cJSON_IsArray(const_decls)) return false;

    cJSON* decl;
    cJSON_ArrayForEach(decl, const_decls) {
        cJSON* decl_name = cJSON_GetObjectItem(decl, "name");
        cJSON* decl_type = cJSON_GetObjectItem(decl, "value_type");

        if (decl_name && decl_name->valuestring &&
            strcmp(decl_name->valuestring, name) == 0 &&
            decl_type && decl_type->valuestring &&
            strcmp(decl_type->valuestring, "array") == 0) {
            return true;
        }
    }
    return false;
}

/**
 * Get the type of a reactive variable
 * Returns NULL if not found
 */
static const char* get_reactive_var_type(CCodegenContext* ctx, const char* name) {
    if (!ctx || !ctx->reactive_vars || !name) return NULL;

    cJSON* var;
    cJSON_ArrayForEach(var, ctx->reactive_vars) {
        cJSON* var_name = cJSON_GetObjectItem(var, "name");
        cJSON* var_type = cJSON_GetObjectItem(var, "type");

        if (var_name && var_name->valuestring &&
            strcmp(var_name->valuestring, name) == 0 &&
            var_type && var_type->valuestring) {
            return var_type->valuestring;
        }
    }
    return NULL;
}

/**
 * Transpile a KRY method call to C code
 * Handles: array.add(value) → kryon_array_push_*(array_name, value)
 */
static void transpile_kry_method_call_to_c(CCodegenContext* ctx, KryParsedStmt* stmt) {
    if (!ctx || !stmt) return;

    const char* object = stmt->object;
    const char* method = stmt->method;
    const char* args = stmt->args;

    // Check if object is an array
    if (is_array_variable(ctx, object)) {
        if (strcmp(method, "add") == 0 || strcmp(method, "push") == 0) {
            // array.add(value) → kryon_array_push_string(array_name, value)
            // Check if arg is a reactive variable
            const char* arg_type = get_reactive_var_type(ctx, args);

            if (arg_type && strcmp(arg_type, "string") == 0) {
                // Get the signal value first
                fprintf(ctx->output, "    const char* _new_item = kryon_signal_get_string(%s_global_signal);\n", args);
                fprintf(ctx->output, "    kryon_array_push_string(&%s_array, _new_item);\n", object);
            } else if (arg_type) {
                // Other reactive types - get as string
                fprintf(ctx->output, "    kryon_array_push_string(&%s_array, kryon_signal_get_string(%s_global_signal));\n", object, args);
            } else {
                // Literal or unknown - pass directly
                fprintf(ctx->output, "    kryon_array_push_string(&%s_array, %s);\n", object, args);
            }
            return;
        }
    }

    // Fallback: generate generic method call comment
    fprintf(ctx->output, "    // TODO: %s.%s(%s)\n", object, method, args);
}

/**
 * Transpile a KRY assignment to C code
 * Handles: variable = value → kryon_signal_set_*(signal, value)
 */
static void transpile_kry_assignment_to_c(CCodegenContext* ctx, KryParsedStmt* stmt) {
    if (!ctx || !stmt) return;

    const char* target = stmt->target;
    const char* value = stmt->value;

    // Check if target is a reactive variable
    const char* var_type = get_reactive_var_type(ctx, target);

    if (var_type) {
        if (strcmp(var_type, "string") == 0) {
            // String assignment: kryon_signal_set_string(signal, value)
            // Value might be a string literal with quotes or a variable
            fprintf(ctx->output, "    kryon_signal_set_string(%s_global_signal, %s);\n", target, value);
        } else if (strcmp(var_type, "bool") == 0 || strcmp(var_type, "boolean") == 0) {
            fprintf(ctx->output, "    kryon_signal_set_bool(%s_global_signal, %s);\n", target, value);
        } else {
            // Numeric assignment
            fprintf(ctx->output, "    kryon_signal_set(%s_global_signal, %s);\n", target, value);
        }
    } else {
        // Non-reactive variable - direct assignment
        fprintf(ctx->output, "    %s = %s;\n", target, value);
    }
}

/**
 * Transpile multiple KRY statements to C code
 * Parses the source and generates C code for each statement
 */
static bool transpile_kry_statements_to_c(CCodegenContext* ctx, const char* kry_source, const char* handler_name) {
    if (!ctx || !kry_source || !handler_name) return false;

    // Generate function header
    fprintf(ctx->output, "void %s(void) {\n", handler_name);

    // Parse and process each statement
    // Statements are separated by newlines or semicolons
    const char* p = kry_source;
    bool any_statement = false;

    while (*p) {
        // Skip whitespace and statement separators
        while (*p && (*p == ' ' || *p == '\t' || *p == '\n' || *p == '\r' || *p == ';')) {
            p++;
        }

        if (!*p || *p == '}') break;

        // Find end of statement (newline, semicolon, or closing brace)
        const char* end = p;
        while (*end && *end != '\n' && *end != ';' && *end != '}') {
            end++;
        }

        if (end > p) {
            // Extract statement
            size_t stmt_len = end - p;
            char* stmt_str = malloc(stmt_len + 1);
            if (stmt_str) {
                strncpy(stmt_str, p, stmt_len);
                stmt_str[stmt_len] = '\0';

                // Parse and transpile the statement
                KryParsedStmt parsed;
                if (parse_kry_statement(stmt_str, &parsed)) {
                    any_statement = true;

                    switch (parsed.type) {
                        case KRY_STMT_METHOD_CALL:
                            transpile_kry_method_call_to_c(ctx, &parsed);
                            break;

                        case KRY_STMT_ASSIGNMENT:
                            transpile_kry_assignment_to_c(ctx, &parsed);
                            break;

                        case KRY_STMT_COMPOUND_ASSIGN: {
                            // Handle += and -=
                            const char* var_type = get_reactive_var_type(ctx, parsed.target);
                            if (var_type) {
                                fprintf(ctx->output, "    int _current = kryon_signal_get(%s_global_signal);\n", parsed.target);
                                if (strcmp(parsed.op, "+=") == 0) {
                                    fprintf(ctx->output, "    kryon_signal_set(%s_global_signal, _current + %d);\n", parsed.target, parsed.delta);
                                } else {
                                    fprintf(ctx->output, "    kryon_signal_set(%s_global_signal, _current - %d);\n", parsed.target, parsed.delta);
                                }
                            } else {
                                fprintf(ctx->output, "    %s %s %d;\n", parsed.target, parsed.op, parsed.delta);
                            }
                            break;
                        }

                        case KRY_STMT_BOOL_TOGGLE: {
                            const char* var_type = get_reactive_var_type(ctx, parsed.target);
                            if (var_type && (strcmp(var_type, "bool") == 0 || strcmp(var_type, "boolean") == 0)) {
                                fprintf(ctx->output, "    bool _current = kryon_signal_get_bool(%s_global_signal);\n", parsed.target);
                                fprintf(ctx->output, "    kryon_signal_set_bool(%s_global_signal, !_current);\n", parsed.target);
                            } else {
                                fprintf(ctx->output, "    %s = !%s;\n", parsed.target, parsed.target);
                            }
                            break;
                        }

                        default:
                            fprintf(ctx->output, "    // TODO: %s\n", stmt_str);
                            break;
                    }
                }

                free(stmt_str);
            }
        }

        p = end;
    }

    // Add rerender call if any statements were processed
    if (any_statement) {
        fprintf(ctx->output, "\n    // Trigger UI update\n");
        fprintf(ctx->output, "    kryon_request_rerender();\n");
    }

    fprintf(ctx->output, "}\n\n");
    return any_statement;
}

/**
 * Transpile a KRY expression to C code
 * Handles simple increment/decrement expressions like:
 *   - value += 1  →  kryon_signal_set(value_signal, kryon_signal_get(value_signal) + 1)
 *   - value -= 1  →  kryon_signal_set(value_signal, kryon_signal_get(value_signal) - 1)
 */
static void transpile_kry_expression_to_c(CCodegenContext* ctx, const char* scoped_var_name, const char* op, int delta) {
    if (!scoped_var_name || !op) return;

    fprintf(ctx->output, "    int current_%s = kryon_signal_get(%s_signal);\n", scoped_var_name, scoped_var_name);

    if (strcmp(op, "+=") == 0) {
        fprintf(ctx->output, "    kryon_signal_set(%s_signal, current_%s + %d);\n", scoped_var_name, scoped_var_name, delta);
    } else if (strcmp(op, "-=") == 0) {
        fprintf(ctx->output, "    kryon_signal_set(%s_signal, current_%s - %d);\n", scoped_var_name, scoped_var_name, delta);
    } else if (strcmp(op, "=") == 0) {
        fprintf(ctx->output, "    kryon_signal_set(%s_signal, %d);\n", scoped_var_name, delta);
    }
}

/**
 * Transpile a boolean toggle expression to C code
 * Handles: variable = !variable
 */
static void transpile_kry_bool_toggle_to_c(CCodegenContext* ctx, const char* var_name, const char* scope) {
    if (!var_name) return;

    // Build scoped signal name
    char signal_name[256];
    if (scope && strcmp(scope, "global") == 0) {
        snprintf(signal_name, sizeof(signal_name), "%s_global_signal", var_name);
    } else if (scope && strcmp(scope, "component") != 0) {
        snprintf(signal_name, sizeof(signal_name), "%s_%s_signal", var_name, scope);
    } else {
        snprintf(signal_name, sizeof(signal_name), "%s_signal", var_name);
    }

    fprintf(ctx->output, "    bool _current = kryon_signal_get_bool(%s);\n", signal_name);
    fprintf(ctx->output, "    kryon_signal_set_bool(%s, !_current);\n", signal_name);
}

/**
 * Parse arrow function: () => { variable = !variable }
 * Returns true if parsed successfully, fills var_name and op
 */
static bool parse_arrow_function_toggle(const char* source, char* var_name, size_t var_size, char* op) {
    if (!source || !var_name || !op) return false;

    // Find "= !" pattern for boolean toggle
    const char* toggle = strstr(source, "= !");
    if (!toggle) return false;

    // Find start of variable name (skip "() => {" and whitespace)
    const char* start = source;
    const char* brace = strchr(source, '{');
    if (brace && brace < toggle) {
        start = brace + 1;
    }
    // Skip whitespace and newlines
    while (*start && (*start == ' ' || *start == '\t' || *start == '\n' || *start == '\r')) {
        start++;
    }

    // Extract variable name (from start to "= !")
    size_t len = toggle - start;
    // Trim trailing whitespace
    while (len > 0 && (start[len-1] == ' ' || start[len-1] == '\t' || start[len-1] == '\n')) {
        len--;
    }

    if (len > 0 && len < var_size - 1) {
        strncpy(var_name, start, len);
        var_name[len] = '\0';
        strcpy(op, "!");
        return true;
    }
    return false;
}

/**
 * Generate C event handler functions from KRY logic_block.functions
 *
 * KIR input (C source from @c blocks):
 *   {
 *     "name": "handleButtonClick",
 *     "sources": [{"language": "c", "source": "void handleButtonClick(void) {\n  printf(...);\n}"}]
 *   }
 *
 * KIR input (KRY lambda):
 *   {
 *     "name": "handler_1_click",
 *     "sources": [{"language": "kry", "source": "() => { value -= 1 }"}]
 *   }
 *
 * C output (from C source): direct code output
 * C output (from KRY lambda): transpiled C code
 */
void c_generate_kry_event_handlers(CCodegenContext* ctx, cJSON* logic_block) {
    if (!logic_block) return;

    cJSON* functions = cJSON_GetObjectItem(logic_block, "functions");
    if (!functions || !cJSON_IsArray(functions)) return;

    int func_count = cJSON_GetArraySize(functions);
    if (func_count == 0) return;

    fprintf(ctx->output, "// Event handlers (transpiled from logic_block)\n");

    cJSON* func;
    cJSON_ArrayForEach(func, functions) {
        cJSON* name = cJSON_GetObjectItem(func, "name");
        cJSON* sources = cJSON_GetObjectItem(func, "sources");
        if (!name || !name->valuestring || !sources || !cJSON_IsArray(sources)) continue;

        // Skip auto-generated top-level code block functions (they contain the @c/@lua/@js blocks)
        // The actual handlers will be extracted from the sources
        if (strncmp(name->valuestring, "_top_level_code_block_", 21) == 0) {
            // Extract the function definitions from these blocks
            for (int i = 0; i < cJSON_GetArraySize(sources); i++) {
                cJSON* src = cJSON_GetArrayItem(sources, i);
                cJSON* lang = cJSON_GetObjectItem(src, "language");
                cJSON* src_item = cJSON_GetObjectItem(src, "source");

                if (lang && lang->valuestring && src_item && src_item->valuestring) {
                    if (strcmp(lang->valuestring, "c") == 0) {
                        // Output C source code directly
                        fprintf(ctx->output, "%s\n", src_item->valuestring);
                    }
                }
            }
            continue;
        }

        // Find C source first (priority over KRY source)
        const char* c_source = NULL;
        const char* kry_source = NULL;

        for (int i = 0; i < cJSON_GetArraySize(sources); i++) {
            cJSON* src = cJSON_GetArrayItem(sources, i);
            cJSON* lang = cJSON_GetObjectItem(src, "language");
            if (!lang || !lang->valuestring) continue;

            cJSON* src_item = cJSON_GetObjectItem(src, "source");
            if (!src_item || !src_item->valuestring) continue;

            if (strcmp(lang->valuestring, "c") == 0) {
                c_source = src_item->valuestring;
                break;  // Found C source, use it
            } else if (strcmp(lang->valuestring, "kry") == 0) {
                kry_source = src_item->valuestring;
            }
        }

        // Output C source directly if found
        if (c_source) {
            fprintf(ctx->output, "%s\n", c_source);
            continue;
        }

        // Fall back to KRY source transpilation
        if (!kry_source) continue;

        // Parse KRY expression to extract variable name, operator, and delta
        char var_name[128] = {0};
        char op[4] = {0};
        int delta = 0;
        bool parsed = false;

        if (sscanf(kry_source, "() => { %127s %3s %d }", var_name, op, &delta) == 3) {
            parsed = true;
        } else if (sscanf(kry_source, "()=>{%127s %3s %d}", var_name, op, &delta) == 3) {
            parsed = true;
        } else {
            // Fallback: try to match += 1 or -= 1 patterns
            if (strstr(kry_source, "+= 1")) {
                const char* start = strchr(kry_source, '{');
                if (start) {
                    start++;
                    while (*start == ' ') start++;
                    const char* end = strstr(start, "+= 1");
                    if (end) {
                        size_t len = end - start;
                        if (len < sizeof(var_name) - 1) {
                            strncpy(var_name, start, len);
                            var_name[len] = '\0';
                            strcpy(op, "+=");
                            delta = 1;
                            parsed = true;
                        }
                    }
                }
            } else if (strstr(kry_source, "-= 1")) {
                const char* start = strchr(kry_source, '{');
                if (start) {
                    start++;
                    while (*start == ' ') start++;
                    const char* end = strstr(start, "-= 1");
                    if (end) {
                        size_t len = end - start;
                        if (len < sizeof(var_name) - 1) {
                            strncpy(var_name, start, len);
                            var_name[len] = '\0';
                            strcpy(op, "-=");
                            delta = 1;
                            parsed = true;
                        }
                    }
                }
            }
        }

        // Pattern: () => { variable = !variable } (boolean toggle)
        if (!parsed && strstr(kry_source, "= !")) {
            parsed = parse_arrow_function_toggle(kry_source, var_name, sizeof(var_name), op);
        }

        if (!parsed) {
            // Try the new multi-statement parser
            if (transpile_kry_statements_to_c(ctx, kry_source, name->valuestring)) {
                continue;  // Successfully transpiled
            }

            // Final fallback: generate stub handler with multiline comment
            fprintf(ctx->output, "void %s(void) {\n", name->valuestring);
            fprintf(ctx->output, "    /* TODO: Transpile expression:\n");
            // Output each line of source as a comment
            const char* line = kry_source;
            while (*line) {
                const char* end = strchr(line, '\n');
                if (end) {
                    fprintf(ctx->output, "     * %.*s\n", (int)(end - line), line);
                    line = end + 1;
                } else {
                    fprintf(ctx->output, "     * %s\n", line);
                    break;
                }
            }
            fprintf(ctx->output, "     */\n");
            fprintf(ctx->output, "}\n\n");
            continue;
        }

        // Find all scopes for this variable and generate a scoped handler for each
        // For each variable, check if there are multiple scopes
        cJSON* scopes_for_var[16];  // Max 16 scopes per variable (should be enough)
        int scope_count = 0;
        const char* base_var_name = var_name;

        // Collect all scopes for this variable
        if (ctx->reactive_vars && cJSON_IsArray(ctx->reactive_vars)) {
            int var_count = cJSON_GetArraySize(ctx->reactive_vars);
            for (int i = 0; i < var_count && scope_count < 16; i++) {
                cJSON* var = cJSON_GetArrayItem(ctx->reactive_vars, i);
                cJSON* vname = cJSON_GetObjectItem(var, "name");
                cJSON* scope = cJSON_GetObjectItem(var, "scope");

                if (vname && vname->valuestring &&
                    strcmp(vname->valuestring, base_var_name) == 0 &&
                    scope && scope->valuestring) {
                    scopes_for_var[scope_count++] = scope;
                }
            }
        }

        // Generate a handler function for each scope
        for (int s = 0; s < scope_count; s++) {
            cJSON* scope_item = scopes_for_var[s];
            const char* scope_str = scope_item->valuestring;

            // For component and global scope, use the base handler name
            if (strcmp(scope_str, "component") == 0 || strcmp(scope_str, "global") == 0) {
                // Generate base handler (for component definition or global scope)
                fprintf(ctx->output, "void %s(void) {\n", name->valuestring);
                if (strcmp(op, "!") == 0) {
                    // Boolean toggle
                    transpile_kry_bool_toggle_to_c(ctx, base_var_name, scope_str);
                } else {
                    // Arithmetic operations (+= / -=)
                    transpile_kry_expression_to_c(ctx, base_var_name, op, delta);
                }
                fprintf(ctx->output, "}\n\n");
            } else {
                // Generate scoped handler (e.g., "handler_1_click_Counter_0")
                char* scoped_handler_name = generate_scoped_var_name(name->valuestring, scope_str);
                char* scoped_var_name = generate_scoped_var_name(base_var_name, scope_str);

                fprintf(ctx->output, "void %s(void) {\n", scoped_handler_name);
                if (strcmp(op, "!") == 0) {
                    // Boolean toggle
                    transpile_kry_bool_toggle_to_c(ctx, base_var_name, scope_str);
                } else {
                    // Arithmetic operations (+= / -=)
                    transpile_kry_expression_to_c(ctx, scoped_var_name, op, delta);
                }
                fprintf(ctx->output, "}\n\n");

                free(scoped_handler_name);
                free(scoped_var_name);
            }
        }
    }
}

// ============================================================================
// Reactive Signal Generation (moved to ir_c_reactive.c)
// ============================================================================
// Functions: is_reactive_variable, get_scoped_var_name, generate_scoped_var_name,
// get_signal_creator, generate_reactive_signal_declarations,
// generate_reactive_signal_initialization, generate_reactive_signal_cleanup

// ============================================================================
// Component Generation (moved to ir_c_components.c)
// ============================================================================
// Functions: generate_component_recursive, generate_property_macro,
// generate_component_definitions

/**
 * Generate C struct definitions from source_structures.struct_types
 */

bool ir_generate_c_code_multi(const char* kir_path, const char* output_dir) {
    if (!kir_path || !output_dir) {
        fprintf(stderr, "Error: Invalid arguments to ir_generate_c_code_multi\n");
        return false;
    }

    // Set error prefix for this codegen
    codegen_set_error_prefix("C");

    // Read main KIR file
    char* main_kir_json = codegen_read_kir_file(kir_path, NULL);
    if (!main_kir_json) {
        return false;
    }

    // Parse main KIR JSON
    cJSON* main_root = cJSON_Parse(main_kir_json);
    if (!main_root) {
        fprintf(stderr, "Error: Failed to parse main KIR JSON\n");
        free(main_kir_json);
        return false;
    }

    // Check if output_dir is actually a file path (ends with .c)
    size_t output_len = strlen(output_dir);
    bool is_file_output = (output_len > 2 && strcmp(output_dir + output_len - 2, ".c") == 0);

    char actual_output_dir[2048];
    char main_output_path[2048];

    if (is_file_output) {
        // Extract directory from file path
        const char* last_slash = strrchr(output_dir, '/');
        if (last_slash) {
            size_t dir_len = last_slash - output_dir;
            strncpy(actual_output_dir, output_dir, dir_len);
            actual_output_dir[dir_len] = '\0';
        } else {
            strcpy(actual_output_dir, ".");
        }
        // Use the provided path as-is for main.c
        strncpy(main_output_path, output_dir, sizeof(main_output_path) - 1);
        main_output_path[sizeof(main_output_path) - 1] = '\0';
    } else {
        // Treat as directory, append /main.c
        strncpy(actual_output_dir, output_dir, sizeof(actual_output_dir) - 1);
        actual_output_dir[sizeof(actual_output_dir) - 1] = '\0';
        snprintf(main_output_path, sizeof(main_output_path), "%s/main.c", output_dir);
    }

    // Create output directory if it doesn't exist
    if (!codegen_mkdir_p(actual_output_dir)) {
        fprintf(stderr, "Error: Could not create output directory: %s\n", actual_output_dir);
        cJSON_Delete(main_root);
        free(main_kir_json);
        return false;
    }

    int files_written = 0;

    // 1. Generate main.c from main.kir

    if (ir_generate_c_code_from_string(main_kir_json, main_output_path)) {
        printf("✓ Generated: main.c\n");
        files_written++;
    } else {
        fprintf(stderr, "Warning: Failed to generate main.c from KIR\n");
    }

    free(main_kir_json);

    // 2. Get the KIR directory (parent of kir_path)
    char kir_dir[2048];
    codegen_get_parent_dir(kir_path, kir_dir, sizeof(kir_dir));

    // 3. Track processed modules to avoid duplicates
    CodegenProcessedModules processed = {0};
    codegen_processed_modules_add(&processed, "main");  // Mark main as processed

    // 4. Process each import recursively (including transitive imports)
    // Imports are in source_structures.requires[].module
    cJSON* source_structures = cJSON_GetObjectItem(main_root, "source_structures");
    cJSON* requires = source_structures ? cJSON_GetObjectItem(source_structures, "requires") : NULL;
    if (requires && cJSON_IsArray(requires)) {
        cJSON* import_item = NULL;
        cJSON_ArrayForEach(import_item, requires) {
            cJSON* module_obj = cJSON_GetObjectItem(import_item, "module");
            if (!module_obj || !cJSON_IsString(module_obj)) continue;

            const char* module_path = cJSON_GetStringValue(module_obj);
            if (module_path) {
                // Convert module path (e.g., "components.habit_panel") to file path format
                char module_id[512];
                strncpy(module_id, module_path, sizeof(module_id) - 1);
                module_id[sizeof(module_id) - 1] = '\0';
                // Replace dots with slashes for file path
                for (char* p = module_id; *p; p++) {
                    if (*p == '.') *p = '/';
                }
                files_written += c_process_module_recursive(module_id, kir_dir,
                                                            actual_output_dir, &processed);
            }
        }
    }

    codegen_processed_modules_free(&processed);
    cJSON_Delete(main_root);

    if (files_written == 0) {
        fprintf(stderr, "Warning: No C files were generated\n");
        return false;
    }

    printf("✓ Generated %d C files in %s\n", files_written, actual_output_dir);
    return true;
}
