/**
 * Patch for compile_command.c to integrate KIR support
 *
 * Changes:
 * 1. Add --kir-output flag to specify KIR output path
 * 2. Add --no-krb flag to skip KRB generation (KIR only)
 * 3. Support .kir input files (skip lex/parse, use KIR reader)
 * 4. Generate KIR after AST transformation
 */

// Add to includes at top of file:
#include "kir_format.h"

// Add to compile_command() function variables (around line 786-790):
const char *kir_output_file = NULL;  // KIR output path
bool no_krb = false;                   // Skip KRB generation
bool is_kir_input = false;             // Input is .kir file

// Add to argument parsing loop (around line 816-870):
// In the while ((opt = getopt_long(...))) loop, add these cases:

static struct option long_options[] = {
    {"output", required_argument, 0, 'o'},
    {"verbose", no_argument, 0, 'v'},
    {"optimize", no_argument, 0, 'O'},
    {"debug", no_argument, 0, 'd'},
    {"kir-output", required_argument, 0, 'k'},  // NEW
    {"no-krb", no_argument, 0, 'n'},            // NEW
    {"help", no_argument, 0, 'h'},
    {0, 0, 0, 0}
};

// Add these cases in the switch statement:
case 'k':
    kir_output_file = optarg;
    break;
case 'n':
    no_krb = true;
    break;

// After parsing arguments, check if input is .kir file (around line 880):
// Detect .kir input files
if (input_file) {
    size_t len = strlen(input_file);
    if (len > 4 && strcmp(input_file + len - 4, ".kir") == 0) {
        is_kir_input = true;
        KRYON_LOG_INFO("Detected KIR input file");
    }
}

// If input is .kir, use KIR reader instead of lexer/parser (around line 900):
const KryonASTNode *ast = NULL;

if (is_kir_input) {
    // --- Read KIR file ---
    KRYON_LOG_INFO("Reading KIR file: %s", input_file);

    KryonKIRReader *kir_reader = kryon_kir_reader_create(NULL);
    if (!kir_reader) {
        KRYON_ERROR_SET(KRYON_ERROR_COMPILATION_FAILED, KRYON_SEVERITY_ERROR, "Failed to create KIR reader");
        result = KRYON_ERROR_COMPILATION_FAILED;
        goto cleanup;
    }

    KryonASTNode *kir_ast = NULL;
    if (!kryon_kir_read_file(kir_reader, input_file, &kir_ast)) {
        size_t error_count;
        const char **kir_errors = kryon_kir_reader_get_errors(kir_reader, &error_count);
        KRYON_LOG_ERROR("Failed to read KIR file:");
        for (size_t i = 0; i < error_count; i++) {
            KRYON_LOG_ERROR("  %s", kir_errors[i]);
        }
        kryon_kir_reader_destroy(kir_reader);
        KRYON_ERROR_SET(KRYON_ERROR_COMPILATION_FAILED, KRYON_SEVERITY_ERROR, "KIR parsing failed");
        result = KRYON_ERROR_COMPILATION_FAILED;
        goto cleanup;
    }

    kryon_kir_reader_destroy(kir_reader);
    ast = kir_ast;
    KRYON_LOG_INFO("KIR file read successfully");

    // Skip to code generation (no need for lexing/parsing/transformation)
    // transformed_ast = ast; (set below)
} else {
    // ... existing lexer/parser code ...
}

// After AST transformation (around line 1018), add KIR generation:
// --- KIR Generation (if requested) ---
if (kir_output_file || no_krb) {
    const char *kir_path = kir_output_file;
    char *auto_kir_path = NULL;

    // Auto-generate KIR path if not specified
    if (!kir_path && no_krb) {
        auto_kir_path = kryon_kir_get_output_path(input_file);
        kir_path = auto_kir_path;
    }

    if (kir_path) {
        KRYON_LOG_INFO("Writing KIR to: %s", kir_path);

        KryonKIRConfig kir_config = kryon_kir_default_config();
        kir_config.source_file = input_file;

        KryonKIRWriter *kir_writer = kryon_kir_writer_create(&kir_config);
        if (!kir_writer) {
            KRYON_ERROR_SET(KRYON_ERROR_COMPILATION_FAILED, KRYON_SEVERITY_ERROR, "Failed to create KIR writer");
            if (auto_kir_path) free(auto_kir_path);
            result = KRYON_ERROR_COMPILATION_FAILED;
            goto cleanup;
        }

        if (!kryon_kir_write_file(kir_writer, transformed_ast, kir_path)) {
            size_t error_count;
            const char **kir_errors = kryon_kir_writer_get_errors(kir_writer, &error_count);
            KRYON_LOG_ERROR("Failed to write KIR file:");
            for (size_t i = 0; i < error_count; i++) {
                KRYON_LOG_ERROR("  %s", kir_errors[i]);
            }
            kryon_kir_writer_destroy(kir_writer);
            if (auto_kir_path) free(auto_kir_path);
            KRYON_ERROR_SET(KRYON_ERROR_FILE_WRITE_ERROR, KRYON_SEVERITY_ERROR, "Failed to write KIR file");
            result = KRYON_ERROR_FILE_WRITE_ERROR;
            goto cleanup;
        }

        kryon_kir_writer_destroy(kir_writer);
        printf("KIR written: %s\n", kir_path);

        if (auto_kir_path) free(auto_kir_path);
    }
}

// If --no-krb is set, skip code generation (around line 1020):
if (no_krb) {
    printf("Compilation successful (KIR only)\n");
    result = KRYON_SUCCESS;
    goto cleanup;
}

// Continue with existing code generation...

// Update help message to include new flags:
printf("Usage: kryon compile [options] <input.kry|input.kir>\n");
printf("Options:\n");
printf("  -o, --output <file>      Output .krb file path\n");
printf("  -k, --kir-output <file>  Output .kir file path\n");
printf("  -n, --no-krb             Generate KIR only (skip KRB)\n");
printf("  -v, --verbose            Enable verbose output\n");
printf("  -O, --optimize           Enable optimizations\n");
printf("  -d, --debug              Enable debug mode\n");
printf("  -h, --help               Show this help message\n");
