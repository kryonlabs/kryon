/**
 * TSX Code Generator
 * Generates TypeScript React components from KIR JSON
 */

#include "tsx_codegen.h"
#include "../react_common.h"
#include "../../ir/third_party/cJSON/cJSON.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char* tsx_codegen_from_json(const char* kir_json) {
    if (!kir_json) return NULL;

    // Parse JSON
    cJSON* root = cJSON_Parse(kir_json);
    if (!root) {
        fprintf(stderr, "Error: Failed to parse KIR JSON\n");
        return NULL;
    }

    // Build React context with TypeScript mode
    ReactContext ctx = {
        .mode = REACT_MODE_TYPESCRIPT,
        .logic_functions = NULL,
        .event_bindings = NULL,
        .indent_level = 0
    };

    // Extract logic functions if present (support both old "logic" and new "logic_block")
    cJSON* logic = cJSON_GetObjectItem(root, "logic_block");
    if (!logic) {
        logic = cJSON_GetObjectItem(root, "logic");  // Fallback to old format
    }

    if (logic && cJSON_IsObject(logic)) {
        ctx.logic_functions = cJSON_GetObjectItem(logic, "functions");
        ctx.event_bindings = cJSON_GetObjectItem(logic, "event_bindings");
    }

    // Get root component
    cJSON* component = cJSON_GetObjectItem(root, "root");
    if (!component) component = cJSON_GetObjectItem(root, "component");
    if (!component) component = root;

    // Extract window configuration
    WindowConfig win_config = react_extract_window_config(component);

    // Get reactive manifest for state hooks
    cJSON* manifest = cJSON_GetObjectItem(root, "reactive_manifest");

    // Start generating TSX
    StringBuilder* sb = sb_create(8192);

    // Add header
    sb_append(sb, "// Generated by Kryon Code Generator (TypeScript React-Hooks Style)\n\n");
    sb_append(sb, react_generate_imports(ctx.mode));
    sb_append(sb, "\n\n");

    // Generate state hooks if there's a reactive manifest
    char* state_hooks = react_generate_state_hooks(manifest, &ctx);

    // Generate main app export
    sb_append(sb, "export default kryonApp({\n");
    sb_append_fmt(sb, "  width: %d,\n", win_config.width);
    sb_append_fmt(sb, "  height: %d,\n", win_config.height);
    sb_append_fmt(sb, "  title: \"%s\",\n", win_config.title);
    sb_append_fmt(sb, "  background: \"%s\",\n\n", win_config.background);

    sb_append(sb, "  render: () => {\n");

    // Add state hooks inside render
    if (state_hooks && strlen(state_hooks) > 0) {
        sb_append(sb, state_hooks);
        sb_append(sb, "\n");
    }

    sb_append(sb, "    return (\n");

    // Generate root element (not just children!)
    char* root_elem = react_generate_element(component, &ctx, 3);
    sb_append(sb, root_elem);
    free(root_elem);

    sb_append(sb, "\n    );\n");
    sb_append(sb, "  }\n");
    sb_append(sb, "});\n");

    // Clean up
    free(state_hooks);
    react_free_window_config(&win_config);
    cJSON_Delete(root);

    char* result = strdup(sb_get(sb));
    sb_free(sb);
    return result;
}

bool tsx_codegen_generate(const char* kir_path, const char* output_path) {
    if (!kir_path || !output_path) return false;

    // Read KIR file
    FILE* f = fopen(kir_path, "r");
    if (!f) {
        fprintf(stderr, "Error: Could not open KIR file: %s\n", kir_path);
        return false;
    }

    fseek(f, 0, SEEK_END);
    long size = ftell(f);
    fseek(f, 0, SEEK_SET);

    char* kir_json = malloc(size + 1);
    if (!kir_json) {
        fclose(f);
        return false;
    }

    fread(kir_json, 1, size, f);
    kir_json[size] = '\0';
    fclose(f);

    // Generate TSX code
    char* tsx_code = tsx_codegen_from_json(kir_json);
    free(kir_json);

    if (!tsx_code) {
        return false;
    }

    // Write output
    f = fopen(output_path, "w");
    if (!f) {
        fprintf(stderr, "Error: Could not write output file: %s\n", output_path);
        free(tsx_code);
        return false;
    }

    fputs(tsx_code, f);
    fclose(f);
    free(tsx_code);

    printf("✓ Generated TSX code: %s\n", output_path);
    return true;
}

bool tsx_codegen_generate_with_options(const char* kir_path,
                                        const char* output_path,
                                        TsxCodegenOptions* options) {
    if (!kir_path || !output_path) {
        return false;
    }

    // Use defaults if no options provided
    TsxCodegenOptions default_opts = {
        .format = true,
        .use_prettier = false,
        .semicolons = true
    };
    if (!options) {
        options = &default_opts;
    }

    // Read KIR file
    FILE* f = fopen(kir_path, "r");
    if (!f) {
        fprintf(stderr, "Error: Could not open KIR file: %s\n", kir_path);
        return false;
    }

    fseek(f, 0, SEEK_END);
    long size = ftell(f);
    fseek(f, 0, SEEK_SET);

    char* kir_json = malloc(size + 1);
    if (!kir_json) {
        fclose(f);
        return false;
    }

    fread(kir_json, 1, size, f);
    kir_json[size] = '\0';
    fclose(f);

    // Generate TSX code
    char* tsx_code = tsx_codegen_from_json(kir_json);
    free(kir_json);

    if (!tsx_code) {
        return false;
    }

    // Write output
    f = fopen(output_path, "w");
    if (!f) {
        fprintf(stderr, "Error: Could not write output file: %s\n", output_path);
        free(tsx_code);
        return false;
    }

    fputs(tsx_code, f);
    fclose(f);
    free(tsx_code);

    printf("✓ Generated TSX code: %s\n", output_path);

    // Apply formatting if requested
    if (options->use_prettier) {
        char cmd[2048];
        snprintf(cmd, sizeof(cmd), "prettier --write \"%s\" 2>/dev/null", output_path);
        int result = system(cmd);
        if (result == 0) {
            printf("  Formatted with Prettier\n");
        }
    }

    // Note: semicolons option would affect generation in tsx_codegen_from_json
    // For now, TypeScript style defaults to including semicolons

    return true;
}
