## TSX Code Generator for Kryon
## Generates TypeScript React components with type annotations from .kir files

import json, strformat, os, strutils, tables
import codegen_react_common

# =============================================================================
# TypeScript-Specific Component Generation
# =============================================================================

proc generateComponentFunction(def: ComponentDef, ctx: var ReactContext): string =
  ## Generate a TypeScript React function component with interface
  let name = def.name

  # Generate interface for props (TypeScript-specific)
  if ctx.mode.shouldGenerateInterface():
    result = &"interface {name}Props {{\n"
    for prop in def.props:
      let tsType = case prop.typ
        of "int", "float": "number"
        of "string": "string"
        of "bool": "boolean"
        else: "any"
      if prop.default != "":
        result.add(&"  {prop.name}?: {tsType};\n")  # Optional
      else:
        result.add(&"  {prop.name}: {tsType};\n")   # Required
    result.add("}\n\n")

  # Generate function signature with type annotation
  result.add(&"function {name}({{ ")
  var propParams: seq[string] = @[]
  for prop in def.props:
    if prop.default != "":
      propParams.add(&"{prop.name} = {prop.default}")
    else:
      propParams.add(prop.name)
  result.add(propParams.join(", "))

  # Add type annotation for TypeScript
  if ctx.mode == TypeScript:
    result.add(&" }}: {name}Props) {{\n")
  else:
    result.add(" }) {\n")

  # Generate state hooks (use shared function)
  result.add(generateStateHooks(def.state, ctx))

  result.add("\n  return (\n")

  # Generate template (use shared function)
  if not def.templateNode.isNil:
    result.add(generateReactElement(def.templateNode, ctx, 2))

  result.add("\n  );\n}\n")

# =============================================================================
# Main Generation
# =============================================================================

proc generateTsxFromKir*(kirPath: string): string =
  ## Generate TSX code from .kir file (TypeScript React-Hooks style)
  if not fileExists(kirPath):
    raise newException(IOError, "File not found: " & kirPath)

  let kirJson = parseFile(kirPath)

  # Build context with TypeScript mode
  var ctx = ReactContext(
    mode: TypeScript,
    componentDefs: initTable[string, ComponentDef](),
    logicFunctions: if kirJson.hasKey("logic") and kirJson["logic"].hasKey("functions"):
                      kirJson["logic"]["functions"]
                    else:
                      newJObject(),
    eventBindings: if kirJson.hasKey("logic") and kirJson["logic"].hasKey("event_bindings"):
                     kirJson["logic"]["event_bindings"]
                   else:
                     newJArray(),
    indentLevel: 0
  )

  # Parse component definitions
  if kirJson.hasKey("component_definitions"):
    for compDef in kirJson["component_definitions"]:
      var def = ComponentDef(
        name: compDef["name"].getStr(),
        props: @[],
        state: @[],
        templateNode: if compDef.hasKey("template"): compDef["template"] else: nil
      )

      if compDef.hasKey("props"):
        for prop in compDef["props"]:
          var defaultVal = ""
          if prop.hasKey("default"):
            let defaultNode = prop["default"]
            case defaultNode.kind
            of JInt: defaultVal = $defaultNode.getInt()
            of JFloat: defaultVal = $defaultNode.getFloat()
            of JString: defaultVal = defaultNode.getStr()
            of JBool: defaultVal = if defaultNode.getBool(): "true" else: "false"
            else: discard
          def.props.add(PropDef(
            name: prop["name"].getStr(),
            typ: prop{"type"}.getStr("any"),
            default: defaultVal
          ))

      if compDef.hasKey("state"):
        for stateVar in compDef["state"]:
          def.state.add(StateDef(
            name: stateVar["name"].getStr(),
            typ: stateVar{"type"}.getStr("any"),
            initial: stateVar{"initial"}.getStr("0")
          ))

      ctx.componentDefs[def.name] = def

  # Get root and window config
  let root = if kirJson.hasKey("root"): kirJson["root"]
             elif kirJson.hasKey("component"): kirJson["component"]
             else: kirJson

  let (width, height, title, background) = extractWindowConfig(root)

  # Generate TSX file
  result = &"// Generated from {extractFilename(kirPath)}\n"
  result.add("// Generated by Kryon Code Generator (TypeScript React-Hooks Style)\n\n")
  result.add(generateReactImports(ctx.mode))
  result.add("\n\n")

  # Generate component definitions
  for name, def in ctx.componentDefs:
    result.add(generateComponentFunction(def, ctx))
    result.add("\n")

  # Generate main app export
  result.add("export default kryonApp({\n")
  result.add(&"  width: {width},\n")
  result.add(&"  height: {height},\n")
  result.add(&"  title: \"{title}\",\n")
  result.add(&"  background: \"{background}\",\n")
  result.add("\n  render: () => (\n")

  # Generate root children (skip the outer container, just render children)
  if root.hasKey("children") and root["children"].len > 0:
    for child in root["children"]:
      result.add(generateReactElement(child, ctx, 2))
      result.add("\n")

  result.add("  )\n")
  result.add("});\n")

# CLI entry point for standalone use
when isMainModule:
  import os

  if paramCount() < 1:
    echo "Usage: codegen_tsx <input.kir> [output.tsx]"
    quit(1)

  let inputPath = paramStr(1)
  let outputPath = if paramCount() >= 2: paramStr(2)
                   else: inputPath.changeFileExt("tsx")

  try:
    let tsxCode = generateTsxFromKir(inputPath)
    writeFile(outputPath, tsxCode)
    echo &"Generated: {outputPath}"
  except IOError as e:
    echo &"Error: {e.msg}"
    quit(1)
