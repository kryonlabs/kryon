/**
 * Compile Command
 * Compiles source files to KIR (no code generation)
 */

#include "kryon_cli.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "ir_core.h"
#include "ir_kry_parser.h"
#include "ir_markdown_parser.h"
#include "ir_html_parser.h"
#include "ir_serialization.h"
#include "parsers/c/ir_c_parser.h"
#include "parsers/tsx/ir_tsx_parser.h"

// Import compile_to_kir from cmd_build.c (we'll need to expose it)
// For now, duplicate the logic

static const char* detect_frontend(const char* source_file) {
    const char* ext = path_extension(source_file);

    if (strcmp(ext, ".kry") == 0) return "kry";
    else if (strcmp(ext, ".kir") == 0) return "kir";
    else if (strcmp(ext, ".md") == 0) return "markdown";
    else if (strcmp(ext, ".html") == 0) return "html";
    else if (strcmp(ext, ".tsx") == 0 || strcmp(ext, ".jsx") == 0) return "tsx";
    else if (strcmp(ext, ".nim") == 0) return "nim";
    else if (strcmp(ext, ".lua") == 0) return "lua";
    else if (strcmp(ext, ".c") == 0 || strcmp(ext, ".h") == 0) return "c";
    else return NULL;
}

static int compile_to_kir(const char* source_file, const char* output_kir, const char* frontend) {
    printf("Compiling %s → %s (frontend: %s)\n", source_file, output_kir, frontend);

    if (strcmp(frontend, "markdown") == 0 || strcmp(frontend, "html") == 0 || strcmp(frontend, "kry") == 0) {
        // Read the source file
        FILE* f = fopen(source_file, "r");
        if (!f) {
            fprintf(stderr, "Error: Failed to open %s\n", source_file);
            return 1;
        }

        fseek(f, 0, SEEK_END);
        long size = ftell(f);
        fseek(f, 0, SEEK_SET);

        char* source = (char*)malloc(size + 1);
        if (!source) {
            fprintf(stderr, "Error: Out of memory\n");
            fclose(f);
            return 1;
        }

        fread(source, 1, size, f);
        source[size] = '\0';
        fclose(f);

        // Convert to KIR JSON based on frontend type
        char* json = NULL;
        if (strcmp(frontend, "kry") == 0) {
            IRComponent* root = ir_kry_parse(source, size);
            if (!root) {
                fprintf(stderr, "Error: Failed to parse %s\n", source_file);
                free(source);
                return 1;
            }
            json = ir_serialize_json_v2(root);
            ir_destroy_component(root);
        } else if (strcmp(frontend, "markdown") == 0) {
            json = ir_markdown_to_kir(source, size);
        } else if (strcmp(frontend, "html") == 0) {
            json = ir_html_to_kir(source, size);
        }

        free(source);

        if (!json) {
            fprintf(stderr, "Error: Failed to convert %s to KIR\n", source_file);
            return 1;
        }

        // Write to output file
        FILE* out = fopen(output_kir, "w");
        if (!out) {
            fprintf(stderr, "Error: Failed to open output file: %s\n", output_kir);
            free(json);
            return 1;
        }

        fprintf(out, "%s\n", json);
        fclose(out);

        free(json);
        return 0;
    }
    else if (strcmp(frontend, "tsx") == 0 || strcmp(frontend, "jsx") == 0) {
        // Use C TSX parser (takes file path directly)
        char* json = ir_tsx_file_to_kir(source_file);

        if (!json) {
            fprintf(stderr, "Error: Failed to convert %s to KIR\n", source_file);
            return 1;
        }

        // Write to output file
        FILE* out = fopen(output_kir, "w");
        if (!out) {
            fprintf(stderr, "Error: Failed to open output file: %s\n", output_kir);
            free(json);
            return 1;
        }

        fprintf(out, "%s\n", json);
        fclose(out);

        free(json);
        return 0;
    }
    else if (strcmp(frontend, "c") == 0) {
        // Use C parser (compile-and-execute approach, takes file path directly)
        char* json = ir_c_file_to_kir(source_file);

        if (!json) {
            fprintf(stderr, "Error: Failed to convert %s to KIR\n", source_file);
            return 1;
        }

        // Write to output file
        FILE* out = fopen(output_kir, "w");
        if (!out) {
            fprintf(stderr, "Error: Failed to open output file: %s\n", output_kir);
            free(json);
            return 1;
        }

        fprintf(out, "%s\n", json);
        fclose(out);

        free(json);
        return 0;
    }
    else if (strcmp(frontend, "nim") == 0 || strcmp(frontend, "lua") == 0) {
        fprintf(stderr, "Error: %s is not an input format\n",
                frontend[0] == 'n' ? "Nim" : "Lua");
        fprintf(stderr, "\n");
        fprintf(stderr, "%s is an OUTPUT format generated by the codegen:\n",
                frontend[0] == 'n' ? "Nim" : "Lua");
        fprintf(stderr, "  kryon codegen %s <input.kir> <output.%s>\n\n",
                frontend, frontend);
        fprintf(stderr, "Input formats (frontends):\n");
        fprintf(stderr, "  .kry        - Kryon DSL\n");
        fprintf(stderr, "  .md         - Markdown documents\n");
        fprintf(stderr, "  .html       - HTML documents\n");
        fprintf(stderr, "  .tsx, .jsx  - TypeScript/JavaScript with JSX\n");
        fprintf(stderr, "  .c          - C source with Kryon API\n");
        fprintf(stderr, "\n");
        fprintf(stderr, "Output formats (codegens):\n");
        fprintf(stderr, "  .nim        - Nim with Kryon DSL\n");
        fprintf(stderr, "  .lua        - Lua with Kryon API\n");
        fprintf(stderr, "  .c          - C source code\n");
        return 1;
    }
    else {
        fprintf(stderr, "Error: Frontend '%s' not yet implemented in compile command\n", frontend);
        return 1;
    }
}

int cmd_compile(int argc, char** argv) {
    if (argc < 1) {
        fprintf(stderr, "Error: No source file specified\n");
        fprintf(stderr, "Usage: kryon compile <file>\n");
        return 1;
    }

    const char* source_file = argv[0];

    if (!file_exists(source_file)) {
        fprintf(stderr, "Error: Source file not found: %s\n", source_file);
        return 1;
    }

    // Detect frontend
    const char* frontend = detect_frontend(source_file);
    if (!frontend) {
        fprintf(stderr, "Error: Could not detect frontend for %s\n", source_file);
        fprintf(stderr, "Supported extensions: .kry, .kir, .md, .html, .tsx, .jsx, .nim, .lua, .c\n");
        return 1;
    }

    // Create cache directory
    if (!file_is_directory(".kryon_cache")) {
        dir_create(".kryon_cache");
    }

    // Generate KIR filename
    const char* basename = strrchr(source_file, '/');
    basename = basename ? basename + 1 : source_file;

    char* name_copy = str_copy(basename);
    char* dot = strrchr(name_copy, '.');
    if (dot) *dot = '\0';

    char kir_file[1024];
    snprintf(kir_file, sizeof(kir_file), ".kryon_cache/%s.kir", name_copy);
    free(name_copy);

    // Compile to KIR
    int result = compile_to_kir(source_file, kir_file, frontend);

    if (result == 0) {
        printf("✓ KIR generated: %s\n", kir_file);
    } else {
        fprintf(stderr, "✗ Compilation failed\n");
    }

    return result;
}
