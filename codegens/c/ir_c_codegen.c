/**
 * C Code Generator - KIR → C Source Code
 *
 * Generates idiomatic C code with Kryon DSL from KIR JSON files
 */

#include "ir_c_codegen.h"
#include "../codegen_common.h"
#include "../../ir/src/utils/ir_c_metadata.h"
#include "../../third_party/cJSON/cJSON.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <ctype.h>

// ============================================================================
// Code Generation Context
// ============================================================================

typedef struct {
    FILE* output;
    int indent_level;
    cJSON* root_json;           // Full KIR JSON
    cJSON* component_tree;      // Root component
    cJSON* c_metadata;          // C metadata section
    cJSON* variables;           // Variables array
    cJSON* event_handlers;      // Event handlers array
    cJSON* helper_functions;    // Helper functions array
    cJSON* includes;            // Includes array
    cJSON* preprocessor_dirs;   // Preprocessor directives array

    // Reactive state tracking
    cJSON* reactive_manifest;   // reactive_manifest from KIR
    cJSON* reactive_vars;       // reactive_manifest.variables array
    bool has_reactive_state;    // True if any reactive variables exist
} CCodegenContext;

// ============================================================================
// Utility Functions
// ============================================================================

static void write_indent(CCodegenContext* ctx) {
    for (int i = 0; i < ctx->indent_level; i++) {
        fprintf(ctx->output, "    ");
    }
}

static void writeln(CCodegenContext* ctx, const char* str) {
    write_indent(ctx);
    fprintf(ctx->output, "%s\n", str);
}

static void write_raw(CCodegenContext* ctx, const char* str) __attribute__((unused));
static void write_raw(CCodegenContext* ctx, const char* str) {
    fprintf(ctx->output, "%s", str);
}

// Get variable name for a component ID
static const char* get_variable_for_component_id(CCodegenContext* ctx, int component_id) {
    if (!ctx->variables) return NULL;

    int var_count = cJSON_GetArraySize(ctx->variables);
    for (int i = 0; i < var_count; i++) {
        cJSON* var = cJSON_GetArrayItem(ctx->variables, i);
        cJSON* id_item = cJSON_GetObjectItem(var, "component_id");
        if (id_item && id_item->valueint == component_id) {
            cJSON* name = cJSON_GetObjectItem(var, "name");
            if (name && name->valuestring) {
                return name->valuestring;
            }
        }
    }
    return NULL;
}

// Map component type to C DSL macro name
static const char* get_component_macro(const char* type) {
    if (strcmp(type, "Container") == 0) return "CONTAINER";
    if (strcmp(type, "Column") == 0) return "COLUMN";
    if (strcmp(type, "Row") == 0) return "ROW";
    if (strcmp(type, "Center") == 0) return "CENTER";
    if (strcmp(type, "Text") == 0) return "TEXT";
    if (strcmp(type, "Button") == 0) return "BUTTON";
    if (strcmp(type, "Input") == 0) return "INPUT";
    if (strcmp(type, "Checkbox") == 0) return "CHECKBOX";
    if (strcmp(type, "Dropdown") == 0) return "DROPDOWN";
    if (strcmp(type, "Image") == 0) return "IMAGE";
    if (strcmp(type, "TabGroup") == 0) return "TAB_GROUP";
    if (strcmp(type, "TabBar") == 0) return "TAB_BAR";
    if (strcmp(type, "Tab") == 0) return "TAB";
    if (strcmp(type, "TabContent") == 0) return "TAB_CONTENT";
    if (strcmp(type, "TabPanel") == 0) return "TAB_PANEL";
    if (strcmp(type, "Table") == 0) return "TABLE";
    if (strcmp(type, "TableHead") == 0) return "TABLE_HEAD";
    if (strcmp(type, "TableBody") == 0) return "TABLE_BODY";
    if (strcmp(type, "TableRow") == 0) return "TABLE_ROW";
    if (strcmp(type, "TableCell") == 0) return "TABLE_CELL";
    if (strcmp(type, "TableHeaderCell") == 0) return "TABLE_HEADER_CELL";
    if (strcmp(type, "For") == 0) return "FOR_EACH";
    if (strcmp(type, "Custom") == 0) return "COMPONENT";
    return "CONTAINER";  // Fallback
}

// ============================================================================
// Header Generation
// ============================================================================

static void generate_includes(CCodegenContext* ctx) {
    fprintf(ctx->output, "/**\n");
    fprintf(ctx->output, " * Auto-generated C code from .kir file\n");
    fprintf(ctx->output, " * Generated by Kryon C Code Generator\n");
    fprintf(ctx->output, " */\n\n");

    // Check if we need reactive includes
    bool needs_reactive = ctx->has_reactive_state;

    // Generate includes from metadata
    if (ctx->includes && cJSON_IsArray(ctx->includes)) {
        int count = cJSON_GetArraySize(ctx->includes);
        for (int i = 0; i < count; i++) {
            cJSON* inc = cJSON_GetArrayItem(ctx->includes, i);
            cJSON* include_str = cJSON_GetObjectItem(inc, "include");
            if (include_str && include_str->valuestring) {
                fprintf(ctx->output, "#include %s\n", include_str->valuestring);
            }
        }
    } else {
        // Default includes if no metadata
        fprintf(ctx->output, "#include <kryon.h>\n");
        fprintf(ctx->output, "#include <kryon_dsl.h>\n");
        if (needs_reactive) {
            fprintf(ctx->output, "#include <kryon_reactive.h>\n");
            fprintf(ctx->output, "#include <kryon_reactive_ui.h>\n");
        }
        fprintf(ctx->output, "#include <stdio.h>\n");
        fprintf(ctx->output, "#include <stdbool.h>\n");
    }

    // ALWAYS add reactive headers if needed (even if metadata has includes)
    if (needs_reactive && ctx->includes && cJSON_IsArray(ctx->includes)) {
        bool has_reactive_headers = false;
        int count = cJSON_GetArraySize(ctx->includes);
        for (int i = 0; i < count; i++) {
            cJSON* inc = cJSON_GetArrayItem(ctx->includes, i);
            cJSON* include_str = cJSON_GetObjectItem(inc, "include");
            if (include_str && include_str->valuestring) {
                if (strstr(include_str->valuestring, "kryon_reactive") != NULL) {
                    has_reactive_headers = true;
                    break;
                }
            }
        }
        if (!has_reactive_headers) {
            fprintf(ctx->output, "#include <kryon_reactive.h>\n");
            fprintf(ctx->output, "#include <kryon_reactive_ui.h>\n");
        }
    }
    fprintf(ctx->output, "\n");
}

static void generate_preprocessor_directives(CCodegenContext* ctx) {
    if (!ctx->preprocessor_dirs || !cJSON_IsArray(ctx->preprocessor_dirs)) {
        return;
    }

    int count = cJSON_GetArraySize(ctx->preprocessor_dirs);
    if (count == 0) return;

    for (int i = 0; i < count; i++) {
        cJSON* dir = cJSON_GetArrayItem(ctx->preprocessor_dirs, i);
        cJSON* type = cJSON_GetObjectItem(dir, "directive_type");
        cJSON* condition = cJSON_GetObjectItem(dir, "condition");
        cJSON* value = cJSON_GetObjectItem(dir, "value");

        if (!type || !type->valuestring) continue;

        if (strcmp(type->valuestring, "define") == 0) {
            fprintf(ctx->output, "#define ");
            if (condition && condition->valuestring) {
                fprintf(ctx->output, "%s ", condition->valuestring);
            }
            if (value && value->valuestring) {
                fprintf(ctx->output, "%s", value->valuestring);
            }
            fprintf(ctx->output, "\n");
        } else if (strcmp(type->valuestring, "ifdef") == 0 && condition && condition->valuestring) {
            fprintf(ctx->output, "#ifdef %s\n", condition->valuestring);
        } else if (strcmp(type->valuestring, "ifndef") == 0 && condition && condition->valuestring) {
            fprintf(ctx->output, "#ifndef %s\n", condition->valuestring);
        } else if (strcmp(type->valuestring, "if") == 0 && condition && condition->valuestring) {
            fprintf(ctx->output, "#if %s\n", condition->valuestring);
        } else if (strcmp(type->valuestring, "elif") == 0 && condition && condition->valuestring) {
            fprintf(ctx->output, "#elif %s\n", condition->valuestring);
        } else if (strcmp(type->valuestring, "else") == 0) {
            fprintf(ctx->output, "#else\n");
        } else if (strcmp(type->valuestring, "endif") == 0) {
            fprintf(ctx->output, "#endif\n");
        }
    }
    fprintf(ctx->output, "\n");
}

// ============================================================================
// KIR Expression/Statement to C Conversion (for exported functions)
// ============================================================================

// Forward declarations
static char* expr_to_c(cJSON* expr);
static bool stmt_to_c(FILE* output, cJSON* stmt, int indent, const char* output_path);

/**
 * Check if expression is a __range__ call and extract start/end
 * Returns true if it's a range, false otherwise
 */
static bool is_range_call(cJSON* expr, cJSON** out_start, cJSON** out_end) {
    if (!expr) return false;

    cJSON* op = cJSON_GetObjectItem(expr, "op");
    if (!op || !cJSON_IsString(op) || strcmp(op->valuestring, "call") != 0) {
        return false;
    }

    cJSON* func = cJSON_GetObjectItem(expr, "function");
    if (!func || !cJSON_IsString(func) || strcmp(func->valuestring, "__range__") != 0) {
        return false;
    }

    cJSON* args = cJSON_GetObjectItem(expr, "args");
    if (!args || !cJSON_IsArray(args) || cJSON_GetArraySize(args) < 2) {
        return false;
    }

    *out_start = cJSON_GetArrayItem(args, 0);
    *out_end = cJSON_GetArrayItem(args, 1);
    return true;
}

/**
 * Convert KIR expression to C code string
 * Returns malloc'd string, caller must free
 */
static char* expr_to_c(cJSON* expr) {
    if (!expr) return strdup("NULL");

    // String literal
    if (cJSON_IsString(expr)) {
        // Escape quotes in string
        const char* str = expr->valuestring;
        size_t len = strlen(str);
        char* result = malloc(len * 2 + 3);  // Worst case: all chars escaped + quotes + null
        char* p = result;
        *p++ = '"';
        for (size_t i = 0; i < len; i++) {
            if (str[i] == '"' || str[i] == '\\') {
                *p++ = '\\';
            }
            *p++ = str[i];
        }
        *p++ = '"';
        *p = '\0';
        return result;
    }

    // Number literal
    if (cJSON_IsNumber(expr)) {
        char* result = malloc(32);
        if (expr->valuedouble == (int)expr->valuedouble) {
            sprintf(result, "%d", expr->valueint);
        } else {
            sprintf(result, "%g", expr->valuedouble);
        }
        return result;
    }

    // Boolean
    if (cJSON_IsBool(expr)) {
        return strdup(cJSON_IsTrue(expr) ? "true" : "false");
    }

    // Null
    if (cJSON_IsNull(expr)) {
        return strdup("NULL");
    }

    // Variable reference: {"var": "name"}
    cJSON* var = cJSON_GetObjectItem(expr, "var");
    if (var && cJSON_IsString(var)) {
        return strdup(var->valuestring);
    }

    // Non-op based index access: {"index": arr, "at": idx}
    // This pattern is used in KIR for array indexing without explicit "op" field
    cJSON* index_arr = cJSON_GetObjectItem(expr, "index");
    cJSON* at_expr = cJSON_GetObjectItem(expr, "at");
    if (index_arr && at_expr) {
        char* arr_c = expr_to_c(index_arr);
        char* at_c = expr_to_c(at_expr);
        char* result = malloc(strlen(arr_c) + strlen(at_c) + 4);
        sprintf(result, "%s[%s]", arr_c, at_c);
        free(arr_c); free(at_c);
        return result;
    }

    // Operation
    cJSON* op = cJSON_GetObjectItem(expr, "op");
    if (!op || !cJSON_IsString(op)) {
        return strdup("/* unknown expr */");
    }

    const char* op_str = op->valuestring;

    // Binary arithmetic operations
    if (strcmp(op_str, "add") == 0) {
        char* left = expr_to_c(cJSON_GetObjectItem(expr, "left"));
        char* right = expr_to_c(cJSON_GetObjectItem(expr, "right"));
        char* result = malloc(strlen(left) + strlen(right) + 10);
        sprintf(result, "(%s + %s)", left, right);
        free(left); free(right);
        return result;
    }
    if (strcmp(op_str, "sub") == 0) {
        char* left = expr_to_c(cJSON_GetObjectItem(expr, "left"));
        char* right = expr_to_c(cJSON_GetObjectItem(expr, "right"));
        char* result = malloc(strlen(left) + strlen(right) + 10);
        sprintf(result, "(%s - %s)", left, right);
        free(left); free(right);
        return result;
    }
    if (strcmp(op_str, "mul") == 0) {
        char* left = expr_to_c(cJSON_GetObjectItem(expr, "left"));
        char* right = expr_to_c(cJSON_GetObjectItem(expr, "right"));
        char* result = malloc(strlen(left) + strlen(right) + 10);
        sprintf(result, "(%s * %s)", left, right);
        free(left); free(right);
        return result;
    }
    if (strcmp(op_str, "div") == 0) {
        char* left = expr_to_c(cJSON_GetObjectItem(expr, "left"));
        char* right = expr_to_c(cJSON_GetObjectItem(expr, "right"));
        char* result = malloc(strlen(left) + strlen(right) + 10);
        sprintf(result, "(%s / %s)", left, right);
        free(left); free(right);
        return result;
    }
    if (strcmp(op_str, "mod") == 0) {
        char* left = expr_to_c(cJSON_GetObjectItem(expr, "left"));
        char* right = expr_to_c(cJSON_GetObjectItem(expr, "right"));
        char* result = malloc(strlen(left) + strlen(right) + 10);
        sprintf(result, "(%s %% %s)", left, right);
        free(left); free(right);
        return result;
    }

    // Comparison operations
    if (strcmp(op_str, "eq") == 0) {
        char* left = expr_to_c(cJSON_GetObjectItem(expr, "left"));
        char* right = expr_to_c(cJSON_GetObjectItem(expr, "right"));
        char* result = malloc(strlen(left) + strlen(right) + 10);
        sprintf(result, "(%s == %s)", left, right);
        free(left); free(right);
        return result;
    }
    if (strcmp(op_str, "ne") == 0) {
        char* left = expr_to_c(cJSON_GetObjectItem(expr, "left"));
        char* right = expr_to_c(cJSON_GetObjectItem(expr, "right"));
        char* result = malloc(strlen(left) + strlen(right) + 10);
        sprintf(result, "(%s != %s)", left, right);
        free(left); free(right);
        return result;
    }
    if (strcmp(op_str, "lt") == 0) {
        char* left = expr_to_c(cJSON_GetObjectItem(expr, "left"));
        char* right = expr_to_c(cJSON_GetObjectItem(expr, "right"));
        char* result = malloc(strlen(left) + strlen(right) + 10);
        sprintf(result, "(%s < %s)", left, right);
        free(left); free(right);
        return result;
    }
    if (strcmp(op_str, "gt") == 0) {
        char* left = expr_to_c(cJSON_GetObjectItem(expr, "left"));
        char* right = expr_to_c(cJSON_GetObjectItem(expr, "right"));
        char* result = malloc(strlen(left) + strlen(right) + 10);
        sprintf(result, "(%s > %s)", left, right);
        free(left); free(right);
        return result;
    }
    if (strcmp(op_str, "le") == 0) {
        char* left = expr_to_c(cJSON_GetObjectItem(expr, "left"));
        char* right = expr_to_c(cJSON_GetObjectItem(expr, "right"));
        char* result = malloc(strlen(left) + strlen(right) + 10);
        sprintf(result, "(%s <= %s)", left, right);
        free(left); free(right);
        return result;
    }
    if (strcmp(op_str, "ge") == 0) {
        char* left = expr_to_c(cJSON_GetObjectItem(expr, "left"));
        char* right = expr_to_c(cJSON_GetObjectItem(expr, "right"));
        char* result = malloc(strlen(left) + strlen(right) + 10);
        sprintf(result, "(%s >= %s)", left, right);
        free(left); free(right);
        return result;
    }

    // Logical operations
    if (strcmp(op_str, "and") == 0) {
        char* left = expr_to_c(cJSON_GetObjectItem(expr, "left"));
        char* right = expr_to_c(cJSON_GetObjectItem(expr, "right"));
        char* result = malloc(strlen(left) + strlen(right) + 10);
        sprintf(result, "(%s && %s)", left, right);
        free(left); free(right);
        return result;
    }
    if (strcmp(op_str, "or") == 0) {
        char* left = expr_to_c(cJSON_GetObjectItem(expr, "left"));
        char* right = expr_to_c(cJSON_GetObjectItem(expr, "right"));
        char* result = malloc(strlen(left) + strlen(right) + 10);
        sprintf(result, "(%s || %s)", left, right);
        free(left); free(right);
        return result;
    }
    if (strcmp(op_str, "not") == 0) {
        char* operand = expr_to_c(cJSON_GetObjectItem(expr, "operand"));
        char* result = malloc(strlen(operand) + 5);
        sprintf(result, "(!%s)", operand);
        free(operand);
        return result;
    }

    // Unary minus
    if (strcmp(op_str, "neg") == 0) {
        char* operand = expr_to_c(cJSON_GetObjectItem(expr, "operand"));
        char* result = malloc(strlen(operand) + 5);
        sprintf(result, "(-%s)", operand);
        free(operand);
        return result;
    }

    // Member access: obj.property
    if (strcmp(op_str, "member_access") == 0) {
        char* obj = expr_to_c(cJSON_GetObjectItem(expr, "object"));
        cJSON* prop = cJSON_GetObjectItem(expr, "property");
        const char* prop_str = prop && cJSON_IsString(prop) ? prop->valuestring : "unknown";
        char* result = malloc(strlen(obj) + strlen(prop_str) + 2);
        sprintf(result, "%s.%s", obj, prop_str);
        free(obj);
        return result;
    }

    // Index access: arr[index]
    if (strcmp(op_str, "index_access") == 0) {
        char* obj = expr_to_c(cJSON_GetObjectItem(expr, "object"));
        char* index = expr_to_c(cJSON_GetObjectItem(expr, "index"));
        char* result = malloc(strlen(obj) + strlen(index) + 4);
        sprintf(result, "%s[%s]", obj, index);
        free(obj); free(index);
        return result;
    }

    // Array literal: [a, b, c]
    if (strcmp(op_str, "array_literal") == 0) {
        cJSON* elements = cJSON_GetObjectItem(expr, "elements");
        if (!elements || !cJSON_IsArray(elements)) {
            return strdup("{}");
        }

        // Calculate needed size
        size_t total_len = 3;  // { } \0
        int count = cJSON_GetArraySize(elements);
        char** elem_strs = malloc(count * sizeof(char*));

        for (int i = 0; i < count; i++) {
            elem_strs[i] = expr_to_c(cJSON_GetArrayItem(elements, i));
            total_len += strlen(elem_strs[i]) + 2;  // ", "
        }

        char* result = malloc(total_len);
        char* p = result;
        *p++ = '{';
        for (int i = 0; i < count; i++) {
            if (i > 0) {
                *p++ = ',';
                *p++ = ' ';
            }
            strcpy(p, elem_strs[i]);
            p += strlen(elem_strs[i]);
            free(elem_strs[i]);
        }
        *p++ = '}';
        *p = '\0';
        free(elem_strs);
        return result;
    }

    // Function call: func(args)
    if (strcmp(op_str, "call") == 0) {
        cJSON* func = cJSON_GetObjectItem(expr, "function");
        cJSON* args = cJSON_GetObjectItem(expr, "args");

        char* func_str = func ? expr_to_c(func) : strdup("unknown_func");

        // Build args string
        size_t total_len = strlen(func_str) + 3;  // () \0
        int arg_count = args ? cJSON_GetArraySize(args) : 0;
        char** arg_strs = NULL;

        if (arg_count > 0) {
            arg_strs = malloc(arg_count * sizeof(char*));
            for (int i = 0; i < arg_count; i++) {
                arg_strs[i] = expr_to_c(cJSON_GetArrayItem(args, i));
                total_len += strlen(arg_strs[i]) + 2;
            }
        }

        char* result = malloc(total_len);
        char* p = result;
        strcpy(p, func_str);
        p += strlen(func_str);
        *p++ = '(';
        for (int i = 0; i < arg_count; i++) {
            if (i > 0) {
                *p++ = ',';
                *p++ = ' ';
            }
            strcpy(p, arg_strs[i]);
            p += strlen(arg_strs[i]);
            free(arg_strs[i]);
        }
        *p++ = ')';
        *p = '\0';

        free(func_str);
        free(arg_strs);
        return result;
    }

    // Method call: receiver.method(args)
    if (strcmp(op_str, "method_call") == 0) {
        cJSON* receiver = cJSON_GetObjectItem(expr, "receiver");
        cJSON* method = cJSON_GetObjectItem(expr, "method");
        cJSON* args = cJSON_GetObjectItem(expr, "args");

        char* recv_str = receiver ? expr_to_c(receiver) : strdup("this");
        const char* method_str = method && cJSON_IsString(method) ? method->valuestring : "method";

        // Build args string
        size_t total_len = strlen(recv_str) + strlen(method_str) + 4;  // .() \0
        int arg_count = args ? cJSON_GetArraySize(args) : 0;
        char** arg_strs = NULL;

        if (arg_count > 0) {
            arg_strs = malloc(arg_count * sizeof(char*));
            for (int i = 0; i < arg_count; i++) {
                arg_strs[i] = expr_to_c(cJSON_GetArrayItem(args, i));
                total_len += strlen(arg_strs[i]) + 2;
            }
        }

        char* result = malloc(total_len);
        sprintf(result, "%s.%s(", recv_str, method_str);
        char* p = result + strlen(result);
        for (int i = 0; i < arg_count; i++) {
            if (i > 0) {
                *p++ = ',';
                *p++ = ' ';
            }
            strcpy(p, arg_strs[i]);
            p += strlen(arg_strs[i]);
            free(arg_strs[i]);
        }
        *p++ = ')';
        *p = '\0';

        free(recv_str);
        free(arg_strs);
        return result;
    }

    // Ternary/conditional: cond ? then : else
    if (strcmp(op_str, "ternary") == 0 || strcmp(op_str, "conditional") == 0) {
        char* cond = expr_to_c(cJSON_GetObjectItem(expr, "condition"));
        char* then_expr = expr_to_c(cJSON_GetObjectItem(expr, "then"));
        char* else_expr = expr_to_c(cJSON_GetObjectItem(expr, "else"));
        char* result = malloc(strlen(cond) + strlen(then_expr) + strlen(else_expr) + 10);
        sprintf(result, "(%s ? %s : %s)", cond, then_expr, else_expr);
        free(cond); free(then_expr); free(else_expr);
        return result;
    }

    // Unsupported operation - return a comment to indicate what's missing
    char* result = malloc(strlen(op_str) + 30);
    sprintf(result, "/* UNSUPPORTED: %s */", op_str);
    return result;
}

/**
 * Convert KIR statement to C code, write to output
 * Returns false on unsupported construct (hard error)
 */
static bool stmt_to_c(FILE* output, cJSON* stmt, int indent, const char* output_path) {
    if (!stmt || !cJSON_IsObject(stmt)) return true;

    cJSON* op = cJSON_GetObjectItem(stmt, "op");
    if (!op || !cJSON_IsString(op)) return true;

    const char* op_str = op->valuestring;

    // Variable declaration: let/const/var name = expr;
    if (strcmp(op_str, "var_decl") == 0 || strcmp(op_str, "let") == 0 || strcmp(op_str, "const") == 0) {
        cJSON* name = cJSON_GetObjectItem(stmt, "name");
        cJSON* type = cJSON_GetObjectItem(stmt, "type");
        cJSON* init = cJSON_GetObjectItem(stmt, "init");

        const char* var_name = name && cJSON_IsString(name) ? name->valuestring : "var";
        const char* var_type = type && cJSON_IsString(type) ? type->valuestring : "auto";

        // Map KIR types to C types
        const char* c_type = "void*";
        if (strcmp(var_type, "string") == 0) {
            c_type = "const char*";
        } else if (strcmp(var_type, "int") == 0 || strcmp(var_type, "number") == 0) {
            c_type = "int";
        } else if (strcmp(var_type, "float") == 0 || strcmp(var_type, "double") == 0) {
            c_type = "double";
        } else if (strcmp(var_type, "bool") == 0) {
            c_type = "bool";
        } else if (strcmp(var_type, "auto") == 0) {
            // Try to infer from init expression
            c_type = "auto";  // C23 supports this, or we use void*
        }

        fprintf(output, "%*s%s %s", indent, "", c_type, var_name);
        if (init) {
            char* init_c = expr_to_c(init);
            fprintf(output, " = %s", init_c);
            free(init_c);
        }
        fprintf(output, ";\n");
        return true;
    }

    // Assignment: target = expr;
    if (strcmp(op_str, "assign") == 0) {
        cJSON* target = cJSON_GetObjectItem(stmt, "target");
        cJSON* expr = cJSON_GetObjectItem(stmt, "expr");

        // Target is either a string (variable name) or an expression (for member/index access)
        const char* target_str;
        char* target_c = NULL;
        if (cJSON_IsString(target)) {
            target_str = target->valuestring;
        } else {
            target_c = expr_to_c(target);
            target_str = target_c;
        }

        char* expr_c = expr ? expr_to_c(expr) : strdup("NULL");
        fprintf(output, "%*s%s = %s;\n", indent, "", target_str, expr_c);
        if (target_c) free(target_c);
        free(expr_c);
        return true;
    }

    // Return: return expr;
    if (strcmp(op_str, "return") == 0) {
        cJSON* value = cJSON_GetObjectItem(stmt, "value");
        if (value) {
            char* expr_c = expr_to_c(value);
            fprintf(output, "%*sreturn %s;\n", indent, "", expr_c);
            free(expr_c);
        } else {
            fprintf(output, "%*sreturn;\n", indent, "");
        }
        return true;
    }

    // Expression statement (function call, etc.)
    if (strcmp(op_str, "expr_stmt") == 0) {
        cJSON* expr = cJSON_GetObjectItem(stmt, "expr");
        if (expr) {
            char* expr_c = expr_to_c(expr);
            fprintf(output, "%*s%s;\n", indent, "", expr_c);
            free(expr_c);
        }
        return true;
    }

    // If statement
    if (strcmp(op_str, "if") == 0) {
        cJSON* cond = cJSON_GetObjectItem(stmt, "condition");
        cJSON* then_block = cJSON_GetObjectItem(stmt, "then");
        cJSON* else_block = cJSON_GetObjectItem(stmt, "else");

        char* cond_c = expr_to_c(cond);
        fprintf(output, "%*sif (%s) {\n", indent, "", cond_c);
        free(cond_c);

        // Process then statements
        if (then_block && cJSON_IsArray(then_block)) {
            cJSON* then_stmt;
            cJSON_ArrayForEach(then_stmt, then_block) {
                if (!stmt_to_c(output, then_stmt, indent + 4, output_path)) return false;
            }
        }

        if (else_block && cJSON_IsArray(else_block) && cJSON_GetArraySize(else_block) > 0) {
            fprintf(output, "%*s} else {\n", indent, "");
            cJSON* else_stmt;
            cJSON_ArrayForEach(else_stmt, else_block) {
                if (!stmt_to_c(output, else_stmt, indent + 4, output_path)) return false;
            }
        }
        fprintf(output, "%*s}\n", indent, "");
        return true;
    }

    // While loop
    if (strcmp(op_str, "while") == 0) {
        cJSON* cond = cJSON_GetObjectItem(stmt, "condition");
        cJSON* body = cJSON_GetObjectItem(stmt, "body");

        char* cond_c = expr_to_c(cond);
        fprintf(output, "%*swhile (%s) {\n", indent, "", cond_c);
        free(cond_c);

        if (body && cJSON_IsArray(body)) {
            cJSON* body_stmt;
            cJSON_ArrayForEach(body_stmt, body) {
                if (!stmt_to_c(output, body_stmt, indent + 4, output_path)) return false;
            }
        }
        fprintf(output, "%*s}\n", indent, "");
        return true;
    }

    // For loop (classic for, not for-each)
    if (strcmp(op_str, "for") == 0) {
        cJSON* init = cJSON_GetObjectItem(stmt, "init");
        cJSON* cond = cJSON_GetObjectItem(stmt, "condition");
        cJSON* update = cJSON_GetObjectItem(stmt, "update");
        cJSON* body = cJSON_GetObjectItem(stmt, "body");

        char* init_c = init ? expr_to_c(init) : strdup("");
        char* cond_c = cond ? expr_to_c(cond) : strdup("true");
        char* update_c = update ? expr_to_c(update) : strdup("");

        fprintf(output, "%*sfor (%s; %s; %s) {\n", indent, "", init_c, cond_c, update_c);
        free(init_c); free(cond_c); free(update_c);

        if (body && cJSON_IsArray(body)) {
            cJSON* body_stmt;
            cJSON_ArrayForEach(body_stmt, body) {
                if (!stmt_to_c(output, body_stmt, indent + 4, output_path)) return false;
            }
        }
        fprintf(output, "%*s}\n", indent, "");
        return true;
    }

    // For-each loop
    if (strcmp(op_str, "for_each") == 0) {
        cJSON* item = cJSON_GetObjectItem(stmt, "item");
        cJSON* in_expr = cJSON_GetObjectItem(stmt, "in");
        cJSON* body = cJSON_GetObjectItem(stmt, "body");

        const char* item_name = item && cJSON_IsString(item) ? item->valuestring : "item";

        // Check if it's a range-based loop: __range__(start, end)
        cJSON* range_start = NULL;
        cJSON* range_end = NULL;

        if (is_range_call(in_expr, &range_start, &range_end)) {
            // Generate: for (int item = start; item < end; item++)
            char* start_c = expr_to_c(range_start);
            char* end_c = expr_to_c(range_end);

            fprintf(output, "%*sfor (int %s = %s; %s < %s; %s++) {\n",
                    indent, "", item_name, start_c, item_name, end_c, item_name);

            free(start_c);
            free(end_c);
        } else {
            // Array iteration: for (int _idx = 0; _idx < arr_len; _idx++)
            char* arr_c = expr_to_c(in_expr);

            // Generate index variable with unique name
            fprintf(output, "%*sfor (int _%s_idx = 0; _%s_idx < %s_len; _%s_idx++) {\n",
                    indent, "", item_name, item_name, arr_c, item_name);

            // Generate item assignment: type item = arr[_idx]
            fprintf(output, "%*s    %s = %s[_%s_idx];\n",
                    indent, "", item_name, arr_c, item_name);

            free(arr_c);
        }

        // Generate body statements
        if (body && cJSON_IsArray(body)) {
            cJSON* body_stmt;
            cJSON_ArrayForEach(body_stmt, body) {
                if (!stmt_to_c(output, body_stmt, indent + 4, output_path)) {
                    return false;
                }
            }
        }

        fprintf(output, "%*s}\n", indent, "");
        return true;
    }

    // Break statement
    if (strcmp(op_str, "break") == 0) {
        fprintf(output, "%*sbreak;\n", indent, "");
        return true;
    }

    // Continue statement
    if (strcmp(op_str, "continue") == 0) {
        fprintf(output, "%*scontinue;\n", indent, "");
        return true;
    }

    // Block statement
    if (strcmp(op_str, "block") == 0) {
        cJSON* stmts = cJSON_GetObjectItem(stmt, "statements");
        fprintf(output, "%*s{\n", indent, "");
        if (stmts && cJSON_IsArray(stmts)) {
            cJSON* s;
            cJSON_ArrayForEach(s, stmts) {
                if (!stmt_to_c(output, s, indent + 4, output_path)) return false;
            }
        }
        fprintf(output, "%*s}\n", indent, "");
        return true;
    }

    // Unknown statement - HARD ERROR
    fprintf(stderr, "[C Codegen] Error: Unsupported statement op '%s' in C codegen.\n", op_str);
    fprintf(stderr, "            File: %s\n", output_path ? output_path : "unknown");
    return false;
}

/**
 * Map KIR type to C type string
 */
static const char* kir_type_to_c(const char* kir_type) {
    if (!kir_type) return "void";

    if (strcmp(kir_type, "string") == 0) return "const char*";
    if (strcmp(kir_type, "int") == 0) return "int";
    if (strcmp(kir_type, "number") == 0) return "double";
    if (strcmp(kir_type, "float") == 0) return "float";
    if (strcmp(kir_type, "double") == 0) return "double";
    if (strcmp(kir_type, "bool") == 0) return "bool";
    if (strcmp(kir_type, "void") == 0) return "void";

    // Array types like "string[]" -> "const char**"
    size_t len = strlen(kir_type);
    if (len > 2 && kir_type[len-2] == '[' && kir_type[len-1] == ']') {
        // Create base type string
        char base[64];
        strncpy(base, kir_type, len - 2);
        base[len - 2] = '\0';

        if (strcmp(base, "string") == 0) return "const char**";
        if (strcmp(base, "int") == 0) return "int*";
        if (strcmp(base, "number") == 0) return "double*";
        if (strcmp(base, "float") == 0) return "float*";
        if (strcmp(base, "double") == 0) return "double*";
        if (strcmp(base, "bool") == 0) return "bool*";
    }

    return "void*";  // Unknown type
}

/**
 * Generate exported functions from logic_block
 * Returns false on hard error (unsupported constructs)
 */
static bool generate_exported_functions(FILE* output, cJSON* logic_block, cJSON* exports, const char* output_path) {
    if (!logic_block || !exports) return true;

    cJSON* functions = cJSON_GetObjectItem(logic_block, "functions");
    if (!functions || !cJSON_IsArray(functions)) return true;

    fprintf(output, "// Exported functions\n");

    // For each export, find and generate the function
    cJSON* export_item;
    cJSON_ArrayForEach(export_item, exports) {
        cJSON* name = cJSON_GetObjectItem(export_item, "name");
        cJSON* type = cJSON_GetObjectItem(export_item, "type");

        if (!name || !cJSON_IsString(name)) continue;
        const char* export_name = name->valuestring;
        const char* export_type = type && cJSON_IsString(type) ? type->valuestring : "";

        // Skip non-function exports
        if (strcmp(export_type, "function") != 0) continue;

        // Find function in logic_block.functions
        cJSON* func;
        bool found = false;
        cJSON_ArrayForEach(func, functions) {
            cJSON* func_name = cJSON_GetObjectItem(func, "name");
            if (!func_name || !cJSON_IsString(func_name)) continue;
            if (strcmp(func_name->valuestring, export_name) != 0) continue;

            found = true;

            // Check for universal statements
            cJSON* universal = cJSON_GetObjectItem(func, "universal");
            if (!universal) {
                fprintf(stderr, "[C Codegen] Error: Exported function '%s' has no universal implementation.\n",
                        export_name);
                fprintf(stderr, "            File: %s\n", output_path ? output_path : "unknown");
                return false;
            }

            cJSON* statements = cJSON_GetObjectItem(universal, "statements");
            if (!statements || !cJSON_IsArray(statements)) {
                // Empty function body - might be just a declaration
                statements = NULL;
            }

            // Get return type and parameters
            cJSON* return_type = cJSON_GetObjectItem(func, "return_type");
            cJSON* params = cJSON_GetObjectItem(func, "params");

            const char* ret_type_str = return_type && cJSON_IsString(return_type) ?
                                       return_type->valuestring : "void";
            const char* c_ret_type = kir_type_to_c(ret_type_str);

            // Generate function signature
            fprintf(output, "\n%s %s(", c_ret_type, export_name);

            // Generate parameters
            if (params && cJSON_IsArray(params) && cJSON_GetArraySize(params) > 0) {
                int param_count = cJSON_GetArraySize(params);
                for (int i = 0; i < param_count; i++) {
                    cJSON* param = cJSON_GetArrayItem(params, i);
                    cJSON* param_name = cJSON_GetObjectItem(param, "name");
                    cJSON* param_type = cJSON_GetObjectItem(param, "type");

                    const char* p_name = param_name && cJSON_IsString(param_name) ?
                                         param_name->valuestring : "arg";
                    const char* p_type = param_type && cJSON_IsString(param_type) ?
                                         param_type->valuestring : "any";

                    if (i > 0) fprintf(output, ", ");
                    fprintf(output, "%s %s", kir_type_to_c(p_type), p_name);
                }
            } else {
                fprintf(output, "void");
            }
            fprintf(output, ") {\n");

            // Generate statements
            if (statements) {
                cJSON* stmt;
                cJSON_ArrayForEach(stmt, statements) {
                    if (!stmt_to_c(output, stmt, 4, output_path)) {
                        return false;  // Hard error
                    }
                }
            }

            fprintf(output, "}\n");
            break;
        }

        if (!found) {
            fprintf(stderr, "[C Codegen] Warning: Exported function '%s' not found in logic_block.\n",
                    export_name);
        }
    }

    return true;
}

// ============================================================================
// Variable & Function Generation
// ============================================================================

static void generate_variable_declarations(CCodegenContext* ctx) {
    if (!ctx->variables || !cJSON_IsArray(ctx->variables)) {
        return;
    }

    int count = cJSON_GetArraySize(ctx->variables);
    if (count == 0) return;

    fprintf(ctx->output, "// Component variables\n");
    for (int i = 0; i < count; i++) {
        cJSON* var = cJSON_GetArrayItem(ctx->variables, i);
        cJSON* storage = cJSON_GetObjectItem(var, "storage");
        cJSON* type = cJSON_GetObjectItem(var, "type");
        cJSON* name = cJSON_GetObjectItem(var, "name");
        cJSON* initial = cJSON_GetObjectItem(var, "initial_value");

        if (!name || !name->valuestring || !type || !type->valuestring) continue;

        if (storage && storage->valuestring) {
            fprintf(ctx->output, "%s ", storage->valuestring);
        }
        fprintf(ctx->output, "%s %s", type->valuestring, name->valuestring);

        if (initial && initial->valuestring) {
            fprintf(ctx->output, " = %s", initial->valuestring);
        }
        fprintf(ctx->output, ";\n");
    }
    fprintf(ctx->output, "\n");
}

static void generate_helper_functions(CCodegenContext* ctx) {
    if (!ctx->helper_functions || !cJSON_IsArray(ctx->helper_functions)) {
        return;
    }

    int count = cJSON_GetArraySize(ctx->helper_functions);
    if (count == 0) return;

    fprintf(ctx->output, "// Helper functions\n");
    for (int i = 0; i < count; i++) {
        cJSON* func = cJSON_GetArrayItem(ctx->helper_functions, i);
        cJSON* return_type = cJSON_GetObjectItem(func, "return_type");
        cJSON* name = cJSON_GetObjectItem(func, "name");
        cJSON* params = cJSON_GetObjectItem(func, "parameters");
        cJSON* body = cJSON_GetObjectItem(func, "body");

        if (!name || !name->valuestring || !return_type || !return_type->valuestring) continue;

        fprintf(ctx->output, "%s %s(%s) {\n",
                return_type->valuestring,
                name->valuestring,
                (params && params->valuestring) ? params->valuestring : "void");

        if (body && body->valuestring) {
            fprintf(ctx->output, "%s\n", body->valuestring);
        }

        fprintf(ctx->output, "}\n\n");
    }
}

static void generate_event_handlers(CCodegenContext* ctx) {
    if (!ctx->event_handlers || !cJSON_IsArray(ctx->event_handlers)) {
        return;
    }

    int count = cJSON_GetArraySize(ctx->event_handlers);
    if (count == 0) return;

    fprintf(ctx->output, "// Event handlers\n");
    for (int i = 0; i < count; i++) {
        cJSON* handler = cJSON_GetArrayItem(ctx->event_handlers, i);
        cJSON* return_type = cJSON_GetObjectItem(handler, "return_type");
        cJSON* name = cJSON_GetObjectItem(handler, "function_name");
        cJSON* params = cJSON_GetObjectItem(handler, "parameters");
        cJSON* body = cJSON_GetObjectItem(handler, "body");

        if (!name || !name->valuestring || !return_type || !return_type->valuestring) continue;

        fprintf(ctx->output, "%s %s(%s) {\n",
                return_type->valuestring,
                name->valuestring,
                (params && params->valuestring) ? params->valuestring : "void");

        if (body && body->valuestring) {
            fprintf(ctx->output, "%s\n", body->valuestring);
        }

        fprintf(ctx->output, "}\n\n");
    }
}

// ============================================================================
// KRY Event Handler Transpilation
// ============================================================================

/**
 * Transpile a KRY expression to C code
 * Handles simple increment/decrement expressions like:
 *   - value += 1  →  kryon_signal_set(value_signal, kryon_signal_get(value_signal) + 1)
 *   - value -= 1  →  kryon_signal_set(value_signal, kryon_signal_get(value_signal) - 1)
 */
static void transpile_kry_expression_to_c(CCodegenContext* ctx, const char* var_name, const char* op, int delta) {
    if (!var_name || !op) return;

    fprintf(ctx->output, "    int current_%s = kryon_signal_get(%s_signal);\n", var_name, var_name);

    if (strcmp(op, "+=") == 0) {
        fprintf(ctx->output, "    kryon_signal_set(%s_signal, current_%s + %d);\n", var_name, var_name, delta);
    } else if (strcmp(op, "-=") == 0) {
        fprintf(ctx->output, "    kryon_signal_set(%s_signal, current_%s - %d);\n", var_name, var_name, delta);
    } else if (strcmp(op, "=") == 0) {
        fprintf(ctx->output, "    kryon_signal_set(%s_signal, %d);\n", var_name, delta);
    }
}

/**
 * Generate C event handler functions from KRY logic_block.functions
 *
 * KIR input (C source from @c blocks):
 *   {
 *     "name": "handleButtonClick",
 *     "sources": [{"language": "c", "source": "void handleButtonClick(void) {\n  printf(...);\n}"}]
 *   }
 *
 * KIR input (KRY lambda):
 *   {
 *     "name": "handler_1_click",
 *     "sources": [{"language": "kry", "source": "() => { value -= 1 }"}]
 *   }
 *
 * C output (from C source): direct code output
 * C output (from KRY lambda): transpiled C code
 */
static void generate_kry_event_handlers(CCodegenContext* ctx, cJSON* logic_block) {
    if (!logic_block) return;

    cJSON* functions = cJSON_GetObjectItem(logic_block, "functions");
    if (!functions || !cJSON_IsArray(functions)) return;

    int func_count = cJSON_GetArraySize(functions);
    if (func_count == 0) return;

    fprintf(ctx->output, "// Event handlers (transpiled from logic_block)\n");

    cJSON* func;
    cJSON_ArrayForEach(func, functions) {
        cJSON* name = cJSON_GetObjectItem(func, "name");
        cJSON* sources = cJSON_GetObjectItem(func, "sources");
        if (!name || !name->valuestring || !sources || !cJSON_IsArray(sources)) continue;

        // Skip auto-generated top-level code block functions (they contain the @c/@lua/@js blocks)
        // The actual handlers will be extracted from the sources
        if (strncmp(name->valuestring, "_top_level_code_block_", 21) == 0) {
            // Extract the function definitions from these blocks
            for (int i = 0; i < cJSON_GetArraySize(sources); i++) {
                cJSON* src = cJSON_GetArrayItem(sources, i);
                cJSON* lang = cJSON_GetObjectItem(src, "language");
                cJSON* src_item = cJSON_GetObjectItem(src, "source");

                if (lang && lang->valuestring && src_item && src_item->valuestring) {
                    if (strcmp(lang->valuestring, "c") == 0) {
                        // Output C source code directly
                        fprintf(ctx->output, "%s\n", src_item->valuestring);
                    }
                }
            }
            continue;
        }

        // Find C source first (priority over KRY source)
        const char* c_source = NULL;
        const char* kry_source = NULL;

        for (int i = 0; i < cJSON_GetArraySize(sources); i++) {
            cJSON* src = cJSON_GetArrayItem(sources, i);
            cJSON* lang = cJSON_GetObjectItem(src, "language");
            if (!lang || !lang->valuestring) continue;

            cJSON* src_item = cJSON_GetObjectItem(src, "source");
            if (!src_item || !src_item->valuestring) continue;

            if (strcmp(lang->valuestring, "c") == 0) {
                c_source = src_item->valuestring;
                break;  // Found C source, use it
            } else if (strcmp(lang->valuestring, "kry") == 0) {
                kry_source = src_item->valuestring;
            }
        }

        // Output C source directly if found
        if (c_source) {
            fprintf(ctx->output, "%s\n", c_source);
            continue;
        }

        // Fall back to KRY source transpilation
        if (!kry_source) continue;

        // Parse KRY expression and generate C function
        fprintf(ctx->output, "void %s(void) {\n", name->valuestring);

        // Simple expression parser for increment/decrement
        // Pattern: "variable += number" or "variable -= number"
        char var_name[128] = {0};
        char op[4] = {0};
        int delta = 0;

        if (sscanf(kry_source, "() => { %127s %3s %d }", var_name, op, &delta) == 3) {
            transpile_kry_expression_to_c(ctx, var_name, op, delta);
        } else if (sscanf(kry_source, "()=>{%127s %3s %d}", var_name, op, &delta) == 3) {
            // Compact format without spaces
            transpile_kry_expression_to_c(ctx, var_name, op, delta);
        } else {
            // Fallback: try to match += 1 or -= 1 patterns
            if (strstr(kry_source, "+= 1")) {
                // Extract variable name before "+= 1"
                const char* start = strchr(kry_source, '{');
                if (start) {
                    start++;
                    while (*start == ' ') start++;
                    const char* end = strstr(start, "+= 1");
                    if (end) {
                        size_t len = end - start;
                        if (len < sizeof(var_name) - 1) {
                            strncpy(var_name, start, len);
                            var_name[len] = '\0';
                            transpile_kry_expression_to_c(ctx, var_name, "+=", 1);
                        }
                    }
                }
            } else if (strstr(kry_source, "-= 1")) {
                const char* start = strchr(kry_source, '{');
                if (start) {
                    start++;
                    while (*start == ' ') start++;
                    const char* end = strstr(start, "-= 1");
                    if (end) {
                        size_t len = end - start;
                        if (len < sizeof(var_name) - 1) {
                            strncpy(var_name, start, len);
                            var_name[len] = '\0';
                            transpile_kry_expression_to_c(ctx, var_name, "-=", 1);
                        }
                    }
                }
            } else {
                fprintf(ctx->output, "    // TODO: Transpile expression: %s\n", kry_source);
            }
        }

        fprintf(ctx->output, "}\n\n");
    }
}

// ============================================================================
// Reactive Signal Generation
// ============================================================================

/**
 * Check if a name matches any reactive variable
 * Returns true if the name is in reactive_manifest.variables
 */
static bool is_reactive_variable(CCodegenContext* ctx, const char* name) {
    if (!ctx->reactive_vars || !cJSON_IsArray(ctx->reactive_vars) || !name) {
        return false;
    }

    int var_count = cJSON_GetArraySize(ctx->reactive_vars);
    for (int i = 0; i < var_count; i++) {
        cJSON* var = cJSON_GetArrayItem(ctx->reactive_vars, i);
        cJSON* var_name = cJSON_GetObjectItem(var, "name");
        if (var_name && var_name->valuestring && strcmp(name, var_name->valuestring) == 0) {
            return true;
        }
    }
    return false;
}

/**
 * Map KIR type to C signal creation function
 */
static const char* get_signal_creator(const char* kir_type) {
    if (!kir_type) return "kryon_signal_create";

    if (strcmp(kir_type, "string") == 0) {
        return "kryon_signal_create_string";
    }
    if (strcmp(kir_type, "bool") == 0 || strcmp(kir_type, "boolean") == 0) {
        return "kryon_signal_create_bool";
    }
    return "kryon_signal_create";  // Default: float signal
}

/**
 * Generate signal declarations from reactive_manifest.variables
 *
 * KIR input: {"id": 1, "name": "value", "type": "int", "initial_value": "0"}
 * C output: KryonSignal* value_signal;
 */
static void generate_reactive_signal_declarations(CCodegenContext* ctx) {
    if (!ctx->reactive_vars || !cJSON_IsArray(ctx->reactive_vars)) return;

    int var_count = cJSON_GetArraySize(ctx->reactive_vars);
    if (var_count == 0) return;

    fprintf(ctx->output, "// Reactive state signals\n");

    for (int i = 0; i < var_count; i++) {
        cJSON* var = cJSON_GetArrayItem(ctx->reactive_vars, i);
        cJSON* name = cJSON_GetObjectItem(var, "name");

        if (!name || !name->valuestring) continue;

        fprintf(ctx->output, "KryonSignal* %s_signal;\n", name->valuestring);
    }
    fprintf(ctx->output, "\n");
}

/**
 * Check if a string is a numeric literal (integer or float)
 */
static bool is_numeric(const char* str) {
    if (!str) return false;
    if (*str == '-' || *str == '+') str++;
    bool has_digit = false;
    while (*str) {
        if (*str >= '0' && *str <= '9') {
            has_digit = true;
        } else if (*str == '.') {
            // Allow decimal point
        } else {
            return false;  // Non-numeric character
        }
        str++;
    }
    return has_digit;
}

/**
 * Generate signal initialization code
 *
 * C output: value_signal = kryon_signal_create(0);
 */
static void generate_reactive_signal_initialization(CCodegenContext* ctx) {
    if (!ctx->reactive_vars || !cJSON_IsArray(ctx->reactive_vars)) return;

    int var_count = cJSON_GetArraySize(ctx->reactive_vars);
    if (var_count == 0) return;

    fprintf(ctx->output, "    // Initialize reactive state\n");

    for (int i = 0; i < var_count; i++) {
        cJSON* var = cJSON_GetArrayItem(ctx->reactive_vars, i);
        cJSON* name = cJSON_GetObjectItem(var, "name");
        cJSON* type = cJSON_GetObjectItem(var, "type");
        cJSON* init = cJSON_GetObjectItem(var, "initial_value");

        if (!name || !name->valuestring) continue;

        const char* var_name = name->valuestring;
        const char* init_val_raw = (init && init->valuestring) ? init->valuestring : "0";

        // For component definitions, initial_value may be a prop reference (e.g., "initialValue")
        // In this case, use the default value "0" instead
        const char* init_val;
        if (is_numeric(init_val_raw)) {
            init_val = init_val_raw;
        } else {
            // Non-numeric values are prop references - use default
            init_val = "0";
        }

        const char* signal_creator = get_signal_creator(
            type && type->valuestring ? type->valuestring : "int"
        );

        if (strcmp(signal_creator, "kryon_signal_create_string") == 0) {
            fprintf(ctx->output, "    %s_signal = %s(\"%s\");\n",
                    var_name, signal_creator, init_val);
        } else if (strcmp(signal_creator, "kryon_signal_create_bool") == 0) {
            bool bool_val = (strcmp(init_val, "true") == 0);
            fprintf(ctx->output, "    %s_signal = %s(%s);\n",
                    var_name, signal_creator, bool_val ? "true" : "false");
        } else {
            fprintf(ctx->output, "    %s_signal = %s(%s);\n",
                    var_name, signal_creator, init_val);
        }
    }
    fprintf(ctx->output, "\n");
}

/**
 * Generate signal cleanup code (before KRYON_RUN)
 *
 * C output: kryon_signal_destroy(value_signal);
 */
static void generate_reactive_signal_cleanup(CCodegenContext* ctx) {
    if (!ctx->reactive_vars || !cJSON_IsArray(ctx->reactive_vars)) return;

    int var_count = cJSON_GetArraySize(ctx->reactive_vars);
    if (var_count == 0) return;

    fprintf(ctx->output, "    // Cleanup reactive state\n");

    for (int i = 0; i < var_count; i++) {
        cJSON* var = cJSON_GetArrayItem(ctx->reactive_vars, i);
        cJSON* name = cJSON_GetObjectItem(var, "name");

        if (!name || !name->valuestring) continue;

        fprintf(ctx->output, "    kryon_signal_destroy(%s_signal);\n", name->valuestring);
    }
    fprintf(ctx->output, "\n");
}

// ============================================================================
// Component Tree Generation
// ============================================================================

static bool generate_property_macro(CCodegenContext* ctx, const char* key, cJSON* value, bool* first_prop);

static void generate_component_recursive(CCodegenContext* ctx, cJSON* component, bool is_root) {
    cJSON* type_obj = cJSON_GetObjectItem(component, "type");
    cJSON* id_obj = cJSON_GetObjectItem(component, "id");
    cJSON* children_obj = cJSON_GetObjectItem(component, "children");
    cJSON* text_obj = cJSON_GetObjectItem(component, "text");

    if (!type_obj || !type_obj->valuestring) return;

    const char* type = type_obj->valuestring;

    // Special handling for For loops - emit FOR_EACH macro
    if (strcmp(type, "For") == 0) {
        cJSON* for_def = cJSON_GetObjectItem(component, "for_def");
        if (for_def) {
            cJSON* item_name = cJSON_GetObjectItem(for_def, "item_name");
            cJSON* source = cJSON_GetObjectItem(for_def, "source");
            cJSON* source_expr = source ? cJSON_GetObjectItem(source, "expression") : NULL;

            const char* item_var = item_name ? item_name->valuestring : "item";
            const char* source_var = source_expr ? source_expr->valuestring : "items";

            // Generate FOR_EACH macro call
            write_indent(ctx);
            fprintf(ctx->output, "FOR_EACH(%s, %s, %s_count,\n",
                    item_var, source_var, source_var);

            ctx->indent_level++;

            // Generate template children as the body
            if (children_obj && cJSON_IsArray(children_obj)) {
                int child_count = cJSON_GetArraySize(children_obj);
                for (int i = 0; i < child_count; i++) {
                    cJSON* child = cJSON_GetArrayItem(children_obj, i);
                    generate_component_recursive(ctx, child, false);
                    if (i < child_count - 1) {
                        fprintf(ctx->output, ",\n");
                    }
                }
            }

            ctx->indent_level--;
            fprintf(ctx->output, "\n");
            write_indent(ctx);
            fprintf(ctx->output, ")");
            return;
        }
    }

    // Special handling for Custom components (component references)
    cJSON* component_ref = cJSON_GetObjectItem(component, "component_ref");
    if (component_ref && component_ref->valuestring) {
        write_indent(ctx);
        cJSON* arg_obj = cJSON_GetObjectItem(component, "arg");
        if (arg_obj && arg_obj->valuestring) {
            fprintf(ctx->output, "%s(%s)", component_ref->valuestring, arg_obj->valuestring);
        } else {
            fprintf(ctx->output, "%s()", component_ref->valuestring);
        }
        return;
    }

    // Check if this is a custom component (type is PascalCase and not a builtin)
    // Custom components have their type set to the component name (e.g., "HabitPanel")
    const char* macro_check = get_component_macro(type);
    bool is_custom_component = (strcmp(macro_check, "CONTAINER") == 0 &&
                                type[0] >= 'A' && type[0] <= 'Z' &&
                                strcmp(type, "Container") != 0);
    if (is_custom_component) {
        write_indent(ctx);
        cJSON* arg_obj = cJSON_GetObjectItem(component, "arg");
        if (arg_obj && arg_obj->valuestring) {
            fprintf(ctx->output, "%s(%s)", type, arg_obj->valuestring);
        } else {
            fprintf(ctx->output, "%s()", type);
        }
        return;
    }

    const char* macro = get_component_macro(type);

    // Check if this component has a variable assignment
    const char* var_name = NULL;
    if (id_obj) {
        var_name = get_variable_for_component_id(ctx, id_obj->valueint);
    }

    // Write indentation
    write_indent(ctx);

    // Variable assignment if needed
    if (var_name && !is_root) {
        fprintf(ctx->output, "%s = ", var_name);
    }

    // Component macro
    fprintf(ctx->output, "%s(", macro);

    // Note: BIND_TEXT for reactive text should be handled specially
    // It should be output immediately after the TEXT component, not as a separate child

    // Output text parameter
    cJSON* text_expr_obj = cJSON_GetObjectItem(component, "text_expression");

    // Check for reactive text binding via property_bindings
    cJSON* property_bindings = cJSON_GetObjectItem(component, "property_bindings");
    bool has_property_binding_bind_text = false;

    if (property_bindings) {
        cJSON* text_binding = cJSON_GetObjectItem(property_bindings, "text");
        if (text_binding) {
            cJSON* binding_type = cJSON_GetObjectItem(text_binding, "binding_type");
            if (binding_type && binding_type->valuestring &&
                strcmp(binding_type->valuestring, "static_template") == 0) {
                has_property_binding_bind_text = true;
            }
        }
    }

    // Fallback: check if text_expression references a reactive variable
    // (property_bindings may not be present in expanded component instances)
    bool has_fallback_bind_text = !has_property_binding_bind_text &&
                                     text_expr_obj && text_expr_obj->valuestring &&
                                     is_reactive_variable(ctx, text_expr_obj->valuestring);

    // Output text parameter
    bool has_text = (text_obj && text_obj->valuestring) || (text_expr_obj && text_expr_obj->valuestring);

    if (has_property_binding_bind_text || has_fallback_bind_text) {
        // Reactive binding - use empty string, actual value comes from signal
        fprintf(ctx->output, "\"\"");
    } else if (text_obj && text_obj->valuestring) {
        fprintf(ctx->output, "\"%s\"", text_obj->valuestring);
    } else if (text_expr_obj && text_expr_obj->valuestring) {
        fprintf(ctx->output, "\"\"");
    }

    // Special handling for Checkbox: output 'checked' parameter after label
    if (strcmp(type, "Checkbox") == 0) {
        cJSON* checked_obj = cJSON_GetObjectItem(component, "checked");
        bool checked_val = checked_obj && cJSON_IsTrue(checked_obj);
        fprintf(ctx->output, ", %s", checked_val ? "true" : "false");
    }

    // Special handling for Dropdown/Input: output 'placeholder' parameter
    if (strcmp(type, "Dropdown") == 0 || strcmp(type, "Input") == 0) {
        // For Dropdown/Input with no text, output placeholder as the first argument
        if (!has_text) {
            cJSON* placeholder_obj = cJSON_GetObjectItem(component, "placeholder");
            const char* placeholder_val = placeholder_obj && placeholder_obj->valuestring ?
                                          placeholder_obj->valuestring : "";
            fprintf(ctx->output, "\"%s\"", placeholder_val);
        }
    }

    // Check for FULL_SIZE pattern (width=100.0px AND height=100.0px)
    cJSON* width_prop = cJSON_GetObjectItem(component, "width");
    cJSON* height_prop = cJSON_GetObjectItem(component, "height");
    bool is_full_size = (width_prop && width_prop->valuestring &&
                         height_prop && height_prop->valuestring &&
                         (strcmp(width_prop->valuestring, "100.0px") == 0 ||
                          strcmp(width_prop->valuestring, "100.0%") == 0) &&
                         (strcmp(height_prop->valuestring, "100.0px") == 0 ||
                          strcmp(height_prop->valuestring, "100.0%") == 0));

    // Check if we have properties or children
    bool has_properties = false;
    cJSON* prop = NULL;
    cJSON_ArrayForEach(prop, component) {
        const char* key = prop->string;
        if (!key) continue;
        if (strcmp(key, "id") != 0 && strcmp(key, "type") != 0 &&
            strcmp(key, "text") != 0 && strcmp(key, "children") != 0 &&
            strcmp(key, "TEST_MARKER") != 0 && strcmp(key, "direction") != 0 &&
            strcmp(key, "background") != 0 && strcmp(key, "color") != 0 &&
            strcmp(key, "placeholder") != 0 &&  // Skip placeholder for Dropdown/Input
            strcmp(key, "checked") != 0) {     // Skip checked for Checkbox
            has_properties = true;
            break;
        }
        // Check if background/color are non-default
        if (strcmp(key, "background") == 0 && prop->valuestring && strcmp(prop->valuestring, "#00000000") != 0) {
            has_properties = true;
            break;
        }
        if (strcmp(key, "color") == 0 && prop->valuestring && strcmp(prop->valuestring, "#00000000") != 0) {
            has_properties = true;
            break;
        }
    }

    bool has_children = (children_obj && cJSON_GetArraySize(children_obj) > 0);

    // Check if this component has a placeholder argument (Dropdown/Input)
    // For Dropdown/Input, we always output a placeholder (even if empty), so check based on type and !has_text
    bool has_placeholder = (strcmp(type, "Dropdown") == 0 || strcmp(type, "Input") == 0) &&
                          !has_text;

    // Add comma after text/placeholder if there are properties or children
    if ((has_text || has_placeholder) && (has_properties || has_children)) {
        fprintf(ctx->output, ",\n");
    } else if (!has_text && !has_placeholder) {
        fprintf(ctx->output, "\n");
    } else if (!has_properties && !has_children) {
        fprintf(ctx->output, "\n");
    }

    ctx->indent_level++;

    // Generate FULL_SIZE if applicable
    bool first_prop = true;
    if (is_full_size) {
        if (!first_prop) {
            fprintf(ctx->output, ",\n");
        }
        write_indent(ctx);
        fprintf(ctx->output, "FULL_SIZE");
        first_prop = false;
    }

    // Special handling for dropdown_state (Dropdown components)
    cJSON* dropdown_state = cJSON_GetObjectItem(component, "dropdown_state");
    if (dropdown_state && cJSON_IsObject(dropdown_state) && strcmp(type, "Dropdown") == 0) {
        // Handle options array
        cJSON* options_array = cJSON_GetObjectItem(dropdown_state, "options");
        if (options_array && cJSON_IsArray(options_array)) {
            int count = cJSON_GetArraySize(options_array);
            if (count > 0) {
                if (!first_prop) fprintf(ctx->output, ",\n");
                write_indent(ctx);

                // Generate OPTIONS macro call with array elements
                fprintf(ctx->output, "OPTIONS(%d", count);
                for (int i = 0; i < count; i++) {
                    cJSON* item = cJSON_GetArrayItem(options_array, i);
                    if (item && cJSON_IsString(item)) {
                        fprintf(ctx->output, ", \"%s\"", item->valuestring);
                    }
                }
                fprintf(ctx->output, ")");
                first_prop = false;
            }
        }

        // Handle selectedIndex
        cJSON* selected_index = cJSON_GetObjectItem(dropdown_state, "selectedIndex");
        if (selected_index && cJSON_IsNumber(selected_index)) {
            if (!first_prop) fprintf(ctx->output, ",\n");
            write_indent(ctx);
            fprintf(ctx->output, "SELECTED_INDEX(%d)", selected_index->valueint);
            first_prop = false;
        }
    }

    // Special handling for TEXT components with reactive text_expression
    // Generate BIND_TEXT_EXPR as a property for fallback case (no property_bindings)
    if (strcmp(type, "Text") == 0) {
        cJSON* text_expr_obj = cJSON_GetObjectItem(component, "text_expression");
        if (text_expr_obj && text_expr_obj->valuestring && is_reactive_variable(ctx, text_expr_obj->valuestring)) {
            // Check that there's no property_bindings (which would be handled elsewhere)
            cJSON* property_bindings = cJSON_GetObjectItem(component, "property_bindings");
            bool has_property_binding = false;
            if (property_bindings) {
                cJSON* text_binding = cJSON_GetObjectItem(property_bindings, "text");
                if (text_binding) {
                    cJSON* binding_type = cJSON_GetObjectItem(text_binding, "binding_type");
                    if (binding_type && binding_type->valuestring &&
                        strcmp(binding_type->valuestring, "static_template") == 0) {
                        has_property_binding = true;
                    }
                }
            }

            // Only generate BIND_TEXT_EXPR for fallback case (no property_bindings)
            if (!has_property_binding) {
                if (!first_prop) fprintf(ctx->output, ",\n");
                write_indent(ctx);
                char signal_name[256];
                snprintf(signal_name, sizeof(signal_name), "%s_signal", text_expr_obj->valuestring);
                fprintf(ctx->output, "BIND_TEXT_EXPR(%s)", signal_name);
                first_prop = false;
            }
        }
    }

    // Generate properties
    cJSON* prop2 = NULL;
    cJSON_ArrayForEach(prop2, component) {
        const char* key = prop2->string;
        if (!key) continue;

        // Skip internal fields
        if (strcmp(key, "id") == 0 || strcmp(key, "type") == 0 ||
            strcmp(key, "text") == 0 || strcmp(key, "children") == 0 ||
            strcmp(key, "TEST_MARKER") == 0 || strcmp(key, "direction") == 0 ||
            strcmp(key, "placeholder") == 0 ||  // Skip placeholder for Dropdown/Input (handled as argument)
            strcmp(key, "checked") == 0 ||      // Skip checked for Checkbox (handled as argument)
            strcmp(key, "dropdown_state") == 0) { // Skip dropdown_state (handled separately below)
            continue;
        }

        // Skip width/height if we already generated FULL_SIZE
        if (is_full_size && (strcmp(key, "width") == 0 || strcmp(key, "height") == 0)) {
            continue;
        }

        // Skip transparent/default colors
        if ((strcmp(key, "background") == 0 || strcmp(key, "color") == 0) &&
            prop2->valuestring && strcmp(prop2->valuestring, "#00000000") == 0) {
            continue;
        }

        // Skip events property if there are no event handlers in metadata OR logic_block
        // KRY handlers are in logic_block.functions, C handlers are in c_metadata.event_handlers
        if (strcmp(key, "events") == 0) {
            bool has_kry_handlers = false;
            // Check if we have logic_block with functions (KRY handlers)
            cJSON* logic_block = cJSON_GetObjectItem(ctx->root_json, "logic_block");
            if (logic_block) {
                cJSON* functions = cJSON_GetObjectItem(logic_block, "functions");
                if (functions && cJSON_IsArray(functions) && cJSON_GetArraySize(functions) > 0) {
                    has_kry_handlers = true;
                }
            }
            bool has_c_handlers = (ctx->event_handlers && cJSON_GetArraySize(ctx->event_handlers) > 0);
            if (!has_kry_handlers && !has_c_handlers) {
                continue;
            }
        }

        // Generate the property (comma handling is internal now)
        generate_property_macro(ctx, key, prop2, &first_prop);
    }

    // Generate children
    if (children_obj && cJSON_IsArray(children_obj)) {
        int child_count = cJSON_GetArraySize(children_obj);
        if (child_count > 0) {
            // Print comma before children if we had properties
            if (!first_prop) {
                fprintf(ctx->output, ",\n");
                fprintf(ctx->output, "\n");  // Blank line for readability
            }

            for (int i = 0; i < child_count; i++) {
                cJSON* child = cJSON_GetArrayItem(children_obj, i);
                generate_component_recursive(ctx, child, false);
                if (i < child_count - 1) {
                    fprintf(ctx->output, ",\n");
                } else {
                    fprintf(ctx->output, "\n");
                }
            }
        }
    }

    ctx->indent_level--;
    write_indent(ctx);
    fprintf(ctx->output, ")");
}

static bool generate_property_macro(CCodegenContext* ctx, const char* key, cJSON* value, bool* first_prop) {
    // NOTE: Each case that generates output must:
    // 1. Print comma if not first_prop
    // 2. Set *first_prop = false after printing

    // Width/Height
    if (strcmp(key, "width") == 0 && value->valuestring) {
        if (!*first_prop) fprintf(ctx->output, ",\n");
        write_indent(ctx);
        if (strcmp(value->valuestring, "100.0px") == 0 || strcmp(value->valuestring, "100.0%") == 0) {
            fprintf(ctx->output, "FULL_WIDTH");
        } else {
            // Parse numeric value (e.g., "200.0px" → 200)
            int width_val = 0;
            if (sscanf(value->valuestring, "%d", &width_val) == 1 && width_val > 0) {
                fprintf(ctx->output, "WIDTH(%d)", width_val);
            } else {
                fprintf(ctx->output, "WIDTH(\"%s\")", value->valuestring);
            }
        }
        *first_prop = false;
        return true;
    }
    if (strcmp(key, "height") == 0 && value->valuestring) {
        if (!*first_prop) fprintf(ctx->output, ",\n");
        write_indent(ctx);
        if (strcmp(value->valuestring, "100.0px") == 0 || strcmp(value->valuestring, "100.0%") == 0) {
            fprintf(ctx->output, "FULL_HEIGHT");
        } else {
            // Parse numeric value (e.g., "60.0px" → 60)
            int height_val = 0;
            if (sscanf(value->valuestring, "%d", &height_val) == 1 && height_val > 0) {
                fprintf(ctx->output, "HEIGHT(%d)", height_val);
            } else {
                fprintf(ctx->output, "HEIGHT(\"%s\")", value->valuestring);
            }
        }
        *first_prop = false;
        return true;
    }

    // Min/Max Width
    if (strcmp(key, "minWidth") == 0 && value->valuestring) {
        if (!*first_prop) fprintf(ctx->output, ",\n");
        write_indent(ctx);
        int val = 0;
        if (sscanf(value->valuestring, "%d", &val) == 1 && val > 0) {
            fprintf(ctx->output, "MIN_WIDTH(%d)", val);
        } else {
            fprintf(ctx->output, "MIN_WIDTH(\"%s\")", value->valuestring);
        }
        *first_prop = false;
        return true;
    }
    if (strcmp(key, "maxWidth") == 0 && value->valuestring) {
        if (!*first_prop) fprintf(ctx->output, ",\n");
        write_indent(ctx);
        int val = 0;
        if (sscanf(value->valuestring, "%d", &val) == 1 && val > 0) {
            fprintf(ctx->output, "MAX_WIDTH(%d)", val);
        } else {
            fprintf(ctx->output, "MAX_WIDTH(\"%s\")", value->valuestring);
        }
        *first_prop = false;
        return true;
    }
    // Min/Max Height
    if (strcmp(key, "minHeight") == 0 && value->valuestring) {
        if (!*first_prop) fprintf(ctx->output, ",\n");
        write_indent(ctx);
        int val = 0;
        if (sscanf(value->valuestring, "%d", &val) == 1 && val > 0) {
            fprintf(ctx->output, "MIN_HEIGHT(%d)", val);
        } else {
            fprintf(ctx->output, "MIN_HEIGHT(\"%s\")", value->valuestring);
        }
        *first_prop = false;
        return true;
    }
    if (strcmp(key, "maxHeight") == 0 && value->valuestring) {
        if (!*first_prop) fprintf(ctx->output, ",\n");
        write_indent(ctx);
        int val = 0;
        if (sscanf(value->valuestring, "%d", &val) == 1 && val > 0) {
            fprintf(ctx->output, "MAX_HEIGHT(%d)", val);
        } else {
            fprintf(ctx->output, "MAX_HEIGHT(\"%s\")", value->valuestring);
        }
        *first_prop = false;
        return true;
    }

    // Colors
    if (strcmp(key, "background") == 0 && value->valuestring) {
        if (!*first_prop) fprintf(ctx->output, ",\n");
        write_indent(ctx);
        // Convert color string "#RRGGBB" to hex 0xRRGGBB
        const char* color_str = value->valuestring;
        if (color_str[0] == '#' && strlen(color_str) >= 7) {
            fprintf(ctx->output, "BG_COLOR(0x%s)", color_str + 1);  // Skip '#'
        } else {
            // Fallback for non-hex colors
            fprintf(ctx->output, "BG_COLOR(0x%s)", color_str);
        }
        *first_prop = false;
        return true;
    }
    if (strcmp(key, "color") == 0 && value->valuestring) {
        if (!*first_prop) fprintf(ctx->output, ",\n");
        write_indent(ctx);
        // Check for named colors
        if (strcmp(value->valuestring, "#ffffff") == 0) {
            fprintf(ctx->output, "COLOR_WHITE");
        } else if (strcmp(value->valuestring, "#000000") == 0) {
            fprintf(ctx->output, "COLOR_BLACK");
        } else if (strcmp(value->valuestring, "#ff0000") == 0) {
            fprintf(ctx->output, "COLOR_RED");
        } else if (strcmp(value->valuestring, "#00ff00") == 0) {
            fprintf(ctx->output, "COLOR_GREEN");
        } else if (strcmp(value->valuestring, "#0000ff") == 0) {
            fprintf(ctx->output, "COLOR_BLUE");
        } else if (strcmp(value->valuestring, "#ffff00") == 0) {
            fprintf(ctx->output, "COLOR_YELLOW");
        } else if (strcmp(value->valuestring, "#00ffff") == 0) {
            fprintf(ctx->output, "COLOR_CYAN");
        } else if (strcmp(value->valuestring, "#ff00ff") == 0) {
            fprintf(ctx->output, "COLOR_MAGENTA");
        } else if (strcmp(value->valuestring, "#808080") == 0) {
            fprintf(ctx->output, "COLOR_GRAY");
        } else if (strcmp(value->valuestring, "#ffa500") == 0) {
            fprintf(ctx->output, "COLOR_ORANGE");
        } else if (strcmp(value->valuestring, "#800080") == 0) {
            fprintf(ctx->output, "COLOR_PURPLE");
        } else {
            // Convert color string "#RRGGBB" to hex 0xRRGGBB
            const char* color_str = value->valuestring;
            if (color_str[0] == '#' && strlen(color_str) >= 7) {
                fprintf(ctx->output, "TEXT_COLOR(0x%s)", color_str + 1);  // Skip '#'
            } else {
                fprintf(ctx->output, "TEXT_COLOR(0x%s)", color_str);
            }
        }
        *first_prop = false;
        return true;
    }

    // Padding/Margin
    if (strcmp(key, "padding") == 0) {
        if (!*first_prop) fprintf(ctx->output, ",\n");
        write_indent(ctx);
        if (cJSON_IsNumber(value)) {
            fprintf(ctx->output, "PADDING(%.0f)", value->valuedouble);
        } else if (cJSON_IsArray(value)) {
            int size = cJSON_GetArraySize(value);
            if (size == 4) {
                fprintf(ctx->output, "PADDING_SIDES(%.0f, %.0f, %.0f, %.0f)",
                        cJSON_GetArrayItem(value, 0)->valuedouble,
                        cJSON_GetArrayItem(value, 1)->valuedouble,
                        cJSON_GetArrayItem(value, 2)->valuedouble,
                        cJSON_GetArrayItem(value, 3)->valuedouble);
            }
        }
        *first_prop = false;
        return true;
    }
    if (strcmp(key, "gap") == 0 && cJSON_IsNumber(value)) {
        if (!*first_prop) fprintf(ctx->output, ",\n");
        write_indent(ctx);
        fprintf(ctx->output, "GAP(%.0f)", value->valuedouble);
        *first_prop = false;
        return true;
    }

    // Typography
    if (strcmp(key, "fontSize") == 0 && cJSON_IsNumber(value)) {
        if (!*first_prop) fprintf(ctx->output, ",\n");
        write_indent(ctx);
        fprintf(ctx->output, "FONT_SIZE(%.0f)", value->valuedouble);
        *first_prop = false;
        return true;
    }
    if (strcmp(key, "fontBold") == 0 && cJSON_IsBool(value)) {
        if (cJSON_IsTrue(value)) {
            if (!*first_prop) fprintf(ctx->output, ",\n");
            write_indent(ctx);
            fprintf(ctx->output, "FONT_BOLD");
            *first_prop = false;
            return true;
        }
        return false;  // fontBold=false generates no output, so no comma
    }

    // Layout
    if (strcmp(key, "justifyContent") == 0 && value->valuestring) {
        if (!*first_prop) fprintf(ctx->output, ",\n");
        write_indent(ctx);
        if (strcmp(value->valuestring, "center") == 0) {
            fprintf(ctx->output, "JUSTIFY_CENTER");
        } else if (strcmp(value->valuestring, "flex-start") == 0 || strcmp(value->valuestring, "start") == 0) {
            fprintf(ctx->output, "JUSTIFY_START");
        } else if (strcmp(value->valuestring, "flex-end") == 0 || strcmp(value->valuestring, "end") == 0) {
            fprintf(ctx->output, "JUSTIFY_END");
        } else if (strcmp(value->valuestring, "space-between") == 0) {
            fprintf(ctx->output, "JUSTIFY_SPACE_BETWEEN");
        } else if (strcmp(value->valuestring, "space-around") == 0) {
            fprintf(ctx->output, "JUSTIFY_SPACE_AROUND");
        } else {
            fprintf(ctx->output, "JUSTIFY_CENTER");
        }
        *first_prop = false;
        return true;
    }
    if (strcmp(key, "alignItems") == 0 && value->valuestring) {
        if (!*first_prop) fprintf(ctx->output, ",\n");
        write_indent(ctx);
        if (strcmp(value->valuestring, "center") == 0) {
            fprintf(ctx->output, "ALIGN_CENTER");
        } else if (strcmp(value->valuestring, "flex-start") == 0 || strcmp(value->valuestring, "start") == 0) {
            fprintf(ctx->output, "ALIGN_START");
        } else if (strcmp(value->valuestring, "flex-end") == 0 || strcmp(value->valuestring, "end") == 0) {
            fprintf(ctx->output, "ALIGN_END");
        } else if (strcmp(value->valuestring, "stretch") == 0) {
            fprintf(ctx->output, "ALIGN_STRETCH");
        } else {
            fprintf(ctx->output, "ALIGN_CENTER");
        }
        *first_prop = false;
        return true;
    }
    if (strcmp(key, "flexShrink") == 0 && cJSON_IsNumber(value)) {
        if (!*first_prop) fprintf(ctx->output, ",\n");
        write_indent(ctx);
        fprintf(ctx->output, "FLEX_SHRINK(%.0f)", value->valuedouble);
        *first_prop = false;
        return true;
    }

    // Visibility
    if (strcmp(key, "visible") == 0 && cJSON_IsBool(value)) {
        if (!*first_prop) fprintf(ctx->output, ",\n");
        write_indent(ctx);
        fprintf(ctx->output, "VISIBLE(%s)", cJSON_IsTrue(value) ? "true" : "false");
        *first_prop = false;
        return true;
    }

    // Events
    if (strcmp(key, "events") == 0 && cJSON_IsArray(value)) {
        int event_count = cJSON_GetArraySize(value);
        bool printed = false;
        for (int i = 0; i < event_count; i++) {
            cJSON* event = cJSON_GetArrayItem(value, i);
            cJSON* event_type = cJSON_GetObjectItem(event, "type");
            cJSON* logic_id = cJSON_GetObjectItem(event, "logic_id");

            if (event_type && event_type->valuestring && logic_id && logic_id->valuestring) {
                // For KRY handlers, logic_id is the function name directly (e.g., "handler_1_click")
                // For C metadata handlers, we need to look up the function name
                const char* func_name = logic_id->valuestring;  // Default: use logic_id as function name

                // Try to find function name in c_metadata.event_handlers (legacy C handlers)
                if (ctx->event_handlers) {
                    int handler_count = cJSON_GetArraySize(ctx->event_handlers);
                    for (int j = 0; j < handler_count; j++) {
                        cJSON* handler = cJSON_GetArrayItem(ctx->event_handlers, j);
                        cJSON* h_logic_id = cJSON_GetObjectItem(handler, "logic_id");
                        cJSON* h_func_name = cJSON_GetObjectItem(handler, "function_name");

                        if (h_logic_id && h_logic_id->valuestring &&
                            h_func_name && h_func_name->valuestring &&
                            strcmp(h_logic_id->valuestring, logic_id->valuestring) == 0) {
                            func_name = h_func_name->valuestring;
                            break;
                        }
                    }
                }

                if (strcmp(event_type->valuestring, "click") == 0) {
                    if (!*first_prop) fprintf(ctx->output, ",\n");
                    write_indent(ctx);
                    fprintf(ctx->output, "ON_CLICK(%s)", func_name);
                    *first_prop = false;
                    printed = true;
                }
            }
        }
        return printed;
    }

    // Dropdown options array
    if (strcmp(key, "options") == 0 && cJSON_IsArray(value)) {
        if (!*first_prop) fprintf(ctx->output, ",\n");
        write_indent(ctx);

        // Generate OPTIONS macro call with array elements
        int count = cJSON_GetArraySize(value);
        fprintf(ctx->output, "OPTIONS(%d", count);

        // Output each option string
        for (int i = 0; i < count; i++) {
            cJSON* item = cJSON_GetArrayItem(value, i);
            if (item && cJSON_IsString(item)) {
                fprintf(ctx->output, ", \"%s\"", item->valuestring);
            }
        }
        fprintf(ctx->output, ")");

        *first_prop = false;
        return true;
    }

    // Handle reactive property bindings
    if (strcmp(key, "property_bindings") == 0 && cJSON_IsObject(value)) {
        bool printed = false;
        cJSON* binding = NULL;

        cJSON_ArrayForEach(binding, value) {
            const char* prop_name = binding->string;
            if (!prop_name) continue;

            cJSON* source_expr = cJSON_GetObjectItem(binding, "source_expr");
            cJSON* binding_type = cJSON_GetObjectItem(binding, "binding_type");

            if (source_expr && source_expr->valuestring &&
                binding_type && binding_type->valuestring &&
                strcmp(binding_type->valuestring, "static_template") == 0) {

                if (!*first_prop) fprintf(ctx->output, ",\n");
                write_indent(ctx);

                // Generate binding macro call
                if (strcmp(prop_name, "text") == 0) {
                    fprintf(ctx->output, "BIND_TEXT(%s_signal)", source_expr->valuestring);
                } else if (strcmp(prop_name, "visible") == 0) {
                    fprintf(ctx->output, "BIND_VISIBLE(%s_signal)", source_expr->valuestring);
                } else if (strcmp(prop_name, "background") == 0) {
                    fprintf(ctx->output, "BIND_BACKGROUND(%s_signal)", source_expr->valuestring);
                } else if (strcmp(prop_name, "color") == 0) {
                    fprintf(ctx->output, "BIND_COLOR(%s_signal)", source_expr->valuestring);
                } else if (strcmp(prop_name, "selectedIndex") == 0) {
                    fprintf(ctx->output, "SELECTED_INDEX(%s)", source_expr->valuestring);
                } else {
                    fprintf(ctx->output, "BIND(%s, %s)", prop_name, source_expr->valuestring);
                }

                *first_prop = false;
                printed = true;
            }
        }
        return printed;
    }

    // Fallback: skip unknown properties (no comma printed)
    return false;
}

// ============================================================================
// Component Definition Generation (for module files)
// ============================================================================

/**
 * Generate C code for component definitions (non-app modules)
 */
static void generate_component_definitions(CCodegenContext* ctx, cJSON* component_defs) {
    if (!component_defs || !cJSON_IsArray(component_defs)) return;

    cJSON* def;
    cJSON_ArrayForEach(def, component_defs) {
        cJSON* name = cJSON_GetObjectItem(def, "name");
        cJSON* props = cJSON_GetObjectItem(def, "props");
        cJSON* template = cJSON_GetObjectItem(def, "template");

        if (!name || !cJSON_IsString(name)) continue;

        const char* comp_name = cJSON_GetStringValue(name);

        // Generate component function signature
        fprintf(ctx->output, "/**\n");
        fprintf(ctx->output, " * Component: %s\n", comp_name);

        // Document props
        if (props && cJSON_IsArray(props)) {
            cJSON* prop;
            cJSON_ArrayForEach(prop, props) {
                cJSON* prop_name = cJSON_GetObjectItem(prop, "name");
                cJSON* prop_type = cJSON_GetObjectItem(prop, "type");
                if (prop_name && cJSON_IsString(prop_name)) {
                    fprintf(ctx->output, " * @param %s %s\n",
                            cJSON_GetStringValue(prop_name),
                            prop_type && cJSON_IsString(prop_type) ?
                            cJSON_GetStringValue(prop_type) : "any");
                }
            }
        }
        fprintf(ctx->output, " */\n");

        // Generate KRYON_COMPONENT macro call
        fprintf(ctx->output, "KRYON_COMPONENT(%s", comp_name);

        // Add props as macro parameters
        if (props && cJSON_IsArray(props)) {
            cJSON* prop;
            cJSON_ArrayForEach(prop, props) {
                cJSON* prop_name = cJSON_GetObjectItem(prop, "name");
                if (prop_name && cJSON_IsString(prop_name)) {
                    fprintf(ctx->output, ", %s", cJSON_GetStringValue(prop_name));
                }
            }
        }
        fprintf(ctx->output, ",\n");

        // Generate template content
        ctx->indent_level++;
        if (template) {
            generate_component_recursive(ctx, template, true);
        }
        ctx->indent_level--;

        fprintf(ctx->output, "\n);\n\n");
    }
}

/**
 * Generate C struct definitions from source_structures.struct_types
 */
static void generate_struct_definitions(CCodegenContext* ctx, cJSON* struct_types) {
    if (!struct_types || !cJSON_IsArray(struct_types)) return;

    cJSON* struct_def;
    cJSON_ArrayForEach(struct_def, struct_types) {
        cJSON* name = cJSON_GetObjectItem(struct_def, "name");
        cJSON* fields = cJSON_GetObjectItem(struct_def, "fields");

        if (!name || !cJSON_IsString(name)) continue;

        const char* struct_name = cJSON_GetStringValue(name);

        fprintf(ctx->output, "/**\n");
        fprintf(ctx->output, " * Struct: %s\n", struct_name);
        fprintf(ctx->output, " */\n");
        fprintf(ctx->output, "typedef struct {\n");

        if (fields && cJSON_IsArray(fields)) {
            cJSON* field;
            cJSON_ArrayForEach(field, fields) {
                cJSON* field_name = cJSON_GetObjectItem(field, "name");
                cJSON* field_type = cJSON_GetObjectItem(field, "type");

                if (!field_name || !cJSON_IsString(field_name)) continue;

                const char* fname = cJSON_GetStringValue(field_name);
                const char* ftype = field_type && cJSON_IsString(field_type) ?
                                    cJSON_GetStringValue(field_type) : "any";

                // Map KIR types to C types
                const char* c_type = "void*";  // default for 'any'
                if (strcmp(ftype, "string") == 0) {
                    c_type = "char*";
                } else if (strcmp(ftype, "int") == 0 || strcmp(ftype, "number") == 0) {
                    c_type = "int";
                } else if (strcmp(ftype, "float") == 0) {
                    c_type = "float";
                } else if (strcmp(ftype, "bool") == 0) {
                    c_type = "bool";
                }

                fprintf(ctx->output, "    %s %s;\n", c_type, fname);
            }
        }

        fprintf(ctx->output, "} %s;\n\n", struct_name);
    }
}

// ============================================================================
// Main Function Generation
// ============================================================================

static void generate_main_function(CCodegenContext* ctx) {
    fprintf(ctx->output, "int main(void) {\n");
    ctx->indent_level++;

    // Extract window config from KIR app object
    cJSON* app = cJSON_GetObjectItem(ctx->root_json, "app");
    const char* title = "Kryon App";
    int width = 800;
    int height = 600;

    if (app) {
        cJSON* title_item = cJSON_GetObjectItem(app, "windowTitle");
        if (title_item && cJSON_IsString(title_item)) {
            title = title_item->valuestring;
        }
        cJSON* width_item = cJSON_GetObjectItem(app, "windowWidth");
        if (width_item && cJSON_IsNumber(width_item)) {
            width = width_item->valueint;
        }
        cJSON* height_item = cJSON_GetObjectItem(app, "windowHeight");
        if (height_item && cJSON_IsNumber(height_item)) {
            height = height_item->valueint;
        }
    }

    // kryon_init() call with values from KIR file
    fprintf(ctx->output, "    kryon_init(\"%s\", %d, %d);\n", title, width, height);
    fprintf(ctx->output, "\n");

    // Initialize reactive signals
    if (ctx->has_reactive_state) {
        generate_reactive_signal_initialization(ctx);
    }

    // KRYON_APP macro
    writeln(ctx, "KRYON_APP(");
    ctx->indent_level++;

    if (ctx->component_tree) {
        generate_component_recursive(ctx, ctx->component_tree, true);
        fprintf(ctx->output, "\n");
    }

    ctx->indent_level--;
    writeln(ctx, ");");
    fprintf(ctx->output, "\n");

    // Cleanup reactive signals before KRYON_RUN
    if (ctx->has_reactive_state) {
        generate_reactive_signal_cleanup(ctx);
    }

    // KRYON_RUN macro
    writeln(ctx, "KRYON_RUN();");

    ctx->indent_level--;
    fprintf(ctx->output, "}\n");
}

// ============================================================================
// Main Code Generation Entry Points
// ============================================================================

bool ir_generate_c_code_from_string(const char* kir_json, const char* output_path) {
    if (!kir_json || !output_path) return false;

    // Parse KIR JSON
    cJSON* root = cJSON_Parse(kir_json);
    if (!root) {
        fprintf(stderr, "Error: Failed to parse KIR JSON\n");
        return false;
    }

    // Open output file
    FILE* output = fopen(output_path, "w");
    if (!output) {
        fprintf(stderr, "Error: Failed to open output file: %s\n", output_path);
        cJSON_Delete(root);
        return false;
    }

    // Setup context
    CCodegenContext ctx = {0};
    ctx.output = output;
    ctx.indent_level = 0;
    ctx.root_json = root;
    ctx.component_tree = cJSON_GetObjectItem(root, "root");
    ctx.c_metadata = cJSON_GetObjectItem(root, "c_metadata");

    if (ctx.c_metadata) {
        ctx.variables = cJSON_GetObjectItem(ctx.c_metadata, "variables");
        ctx.event_handlers = cJSON_GetObjectItem(ctx.c_metadata, "event_handlers");
        ctx.helper_functions = cJSON_GetObjectItem(ctx.c_metadata, "helper_functions");
        ctx.includes = cJSON_GetObjectItem(ctx.c_metadata, "includes");
        ctx.preprocessor_dirs = cJSON_GetObjectItem(ctx.c_metadata, "preprocessor_directives");
    }

    // Parse reactive manifest
    ctx.reactive_manifest = cJSON_GetObjectItem(root, "reactive_manifest");
    if (ctx.reactive_manifest) {
        ctx.reactive_vars = cJSON_GetObjectItem(ctx.reactive_manifest, "variables");
        ctx.has_reactive_state = (ctx.reactive_vars &&
                                  cJSON_IsArray(ctx.reactive_vars) &&
                                  cJSON_GetArraySize(ctx.reactive_vars) > 0);
    }

    // Check if this is a component module (has component_definitions but no root)
    cJSON* component_defs = cJSON_GetObjectItem(root, "component_definitions");
    bool is_component_module = (component_defs && cJSON_IsArray(component_defs) &&
                                cJSON_GetArraySize(component_defs) > 0 &&
                                !ctx.component_tree);

    // Check for struct definitions in source_structures
    cJSON* source_structures = cJSON_GetObjectItem(root, "source_structures");
    cJSON* struct_types = source_structures ?
                          cJSON_GetObjectItem(source_structures, "struct_types") : NULL;
    bool has_struct_types = (struct_types && cJSON_IsArray(struct_types) &&
                             cJSON_GetArraySize(struct_types) > 0);

    // Check for exported functions or constants (utility modules)
    cJSON* exports = source_structures ?
                     cJSON_GetObjectItem(source_structures, "exports") : NULL;
    bool has_exports = (exports && cJSON_IsArray(exports) &&
                        cJSON_GetArraySize(exports) > 0);

    cJSON* const_decls = source_structures ?
                         cJSON_GetObjectItem(source_structures, "const_declarations") : NULL;
    bool has_const_decls = (const_decls && cJSON_IsArray(const_decls) &&
                            cJSON_GetArraySize(const_decls) > 0);

    // A utility module has exports/consts but no root or component definitions
    bool is_utility_module = (has_exports || has_const_decls) &&
                             !ctx.component_tree && !is_component_module;

    // Generate code sections
    generate_includes(&ctx);
    generate_preprocessor_directives(&ctx);

    // Generate struct definitions if present
    if (has_struct_types) {
        generate_struct_definitions(&ctx, struct_types);
    }

    generate_variable_declarations(&ctx);
    generate_helper_functions(&ctx);
    generate_event_handlers(&ctx);

    // Generate reactive signal declarations if needed (must come before KRY handlers)
    if (ctx.has_reactive_state) {
        generate_reactive_signal_declarations(&ctx);
    }

    // Generate KRY event handlers from logic_block (transpiled from KRY expressions)
    // Must come after signal declarations so handlers can reference the signals
    cJSON* logic_block = cJSON_GetObjectItem(root, "logic_block");
    generate_kry_event_handlers(&ctx, logic_block);

    if (is_component_module) {
        // Generate component definitions for module files
        generate_component_definitions(&ctx, component_defs);
    } else if (is_utility_module) {
        // Utility modules: generate exported functions and constants
        cJSON* logic_block = cJSON_GetObjectItem(root, "logic_block");
        if (!generate_exported_functions(output, logic_block, exports, output_path)) {
            // Hard error occurred - cleanup and return false
            fclose(output);
            cJSON_Delete(root);
            return false;
        }
    } else if (ctx.component_tree) {
        // App files with root: generate main()
        generate_main_function(&ctx);
    }
    // Struct-only modules: struct is already generated, no main() needed

    // Cleanup
    fclose(output);
    cJSON_Delete(root);

    return true;
}

bool ir_generate_c_code(const char* kir_path, const char* output_path) {
    if (!kir_path || !output_path) return false;

    // Set error prefix for this codegen
    codegen_set_error_prefix("C");

    // Read KIR file using shared utility
    char* content = codegen_read_kir_file(kir_path, NULL);
    if (!content) {
        return false;
    }

    // Generate code
    bool result = ir_generate_c_code_from_string(content, output_path);
    free(content);

    return result;
}

/**
 * Convert module_id to include guard name (uppercase with underscores)
 */
static char* c_module_to_guard_name(const char* module_id) {
    if (!module_id) return strdup("COMPONENT_H");

    size_t len = strlen(module_id);
    char* result = malloc(len + 3);  // _H\0
    if (!result) return strdup("COMPONENT_H");

    for (size_t i = 0; i < len; i++) {
        if (module_id[i] == '/') {
            result[i] = '_';
        } else if (module_id[i] >= 'a' && module_id[i] <= 'z') {
            result[i] = module_id[i] - 'a' + 'A';  // To uppercase
        } else {
            result[i] = module_id[i];
        }
    }
    result[len] = '_';
    result[len + 1] = 'H';
    result[len + 2] = '\0';

    return result;
}

/**
 * Generate a header file (.h) for a C component
 */
static bool c_generate_header_file(const char* module_id, const char* output_dir) {
    char* guard_name = c_module_to_guard_name(module_id);

    char header_path[2048];
    snprintf(header_path, sizeof(header_path), "%s/%s.h", output_dir, module_id);

    // Generate header content
    char header_content[4096];
    snprintf(header_content, sizeof(header_content),
             "/**\n"
             " * %s - Auto-generated header\n"
             " * Generated by Kryon C Code Generator\n"
             " */\n\n"
             "#ifndef %s\n"
             "#define %s\n\n"
             "#include <kryon.h>\n"
             "#include <kryon_dsl.h>\n\n"
             "// Component declaration\n"
             "IRComponent* %s_create(void);\n\n"
             "#endif // %s\n",
             module_id, guard_name, guard_name,
             strrchr(module_id, '/') ? strrchr(module_id, '/') + 1 : module_id,
             guard_name);

    bool result = codegen_write_file_with_mkdir(header_path, header_content);

    free(guard_name);
    return result;
}

/**
 * Recursively process a module and its transitive imports for C
 */
static int c_process_module_recursive(const char* module_id, const char* kir_dir,
                                      const char* output_dir, CodegenProcessedModules* processed) {
    // Skip if already processed
    if (codegen_processed_modules_contains(processed, module_id)) return 0;
    codegen_processed_modules_add(processed, module_id);

    // Skip internal modules
    if (codegen_is_internal_module(module_id)) return 0;

    // Skip external plugins (they're runtime dependencies, not source)
    if (codegen_is_external_plugin(module_id)) return 0;

    // Build path to component's KIR file
    char component_kir_path[2048];
    snprintf(component_kir_path, sizeof(component_kir_path),
             "%s/%s.kir", kir_dir, module_id);

    // Read component's KIR
    char* component_kir_json = codegen_read_kir_file(component_kir_path, NULL);
    if (!component_kir_json) {
        fprintf(stderr, "Warning: Cannot find KIR for '%s' at %s\n",
                module_id, component_kir_path);
        return 0;
    }

    // Parse to get transitive imports before generating
    cJSON* component_root = cJSON_Parse(component_kir_json);
    int files_written = 0;

    // Generate C source file
    char c_output_path[2048];
    snprintf(c_output_path, sizeof(c_output_path), "%s/%s.c", output_dir, module_id);

    // Create parent directories if needed (e.g., for components/habit_panel.c)
    char* dir_copy = strdup(c_output_path);
    if (dir_copy) {
        char* last_slash = strrchr(dir_copy, '/');
        if (last_slash) {
            *last_slash = '\0';
            codegen_mkdir_p(dir_copy);
        }
        free(dir_copy);
    }

    if (ir_generate_c_code_from_string(component_kir_json, c_output_path)) {
        printf("✓ Generated: %s.c\n", module_id);
        files_written++;

        // Also generate header file
        if (c_generate_header_file(module_id, output_dir)) {
            printf("✓ Generated: %s.h\n", module_id);
            files_written++;
        }
    } else {
        fprintf(stderr, "Warning: Failed to generate C code for '%s'\n", module_id);
    }

    free(component_kir_json);

    // Process transitive imports from this component
    // Imports are in source_structures.requires[].module
    if (component_root) {
        cJSON* source_structures = cJSON_GetObjectItem(component_root, "source_structures");
        cJSON* requires = source_structures ? cJSON_GetObjectItem(source_structures, "requires") : NULL;
        if (requires && cJSON_IsArray(requires)) {
            cJSON* import_item = NULL;
            cJSON_ArrayForEach(import_item, requires) {
                cJSON* module_obj = cJSON_GetObjectItem(import_item, "module");
                if (!module_obj || !cJSON_IsString(module_obj)) continue;
                const char* module_path = cJSON_GetStringValue(module_obj);
                if (module_path) {
                    // Convert module path to file path format
                    char sub_module_id[512];
                    strncpy(sub_module_id, module_path, sizeof(sub_module_id) - 1);
                    sub_module_id[sizeof(sub_module_id) - 1] = '\0';
                    for (char* p = sub_module_id; *p; p++) {
                        if (*p == '.') *p = '/';
                    }
                    files_written += c_process_module_recursive(sub_module_id, kir_dir,
                                                                output_dir, processed);
                }
            }
        }
        cJSON_Delete(component_root);
    }

    return files_written;
}

bool ir_generate_c_code_multi(const char* kir_path, const char* output_dir) {
    if (!kir_path || !output_dir) {
        fprintf(stderr, "Error: Invalid arguments to ir_generate_c_code_multi\n");
        return false;
    }

    // Set error prefix for this codegen
    codegen_set_error_prefix("C");

    // Read main KIR file
    char* main_kir_json = codegen_read_kir_file(kir_path, NULL);
    if (!main_kir_json) {
        return false;
    }

    // Parse main KIR JSON
    cJSON* main_root = cJSON_Parse(main_kir_json);
    if (!main_root) {
        fprintf(stderr, "Error: Failed to parse main KIR JSON\n");
        free(main_kir_json);
        return false;
    }

    // Check if output_dir is actually a file path (ends with .c)
    size_t output_len = strlen(output_dir);
    bool is_file_output = (output_len > 2 && strcmp(output_dir + output_len - 2, ".c") == 0);

    char actual_output_dir[2048];
    char main_output_path[2048];

    if (is_file_output) {
        // Extract directory from file path
        const char* last_slash = strrchr(output_dir, '/');
        if (last_slash) {
            size_t dir_len = last_slash - output_dir;
            strncpy(actual_output_dir, output_dir, dir_len);
            actual_output_dir[dir_len] = '\0';
        } else {
            strcpy(actual_output_dir, ".");
        }
        // Use the provided path as-is for main.c
        strncpy(main_output_path, output_dir, sizeof(main_output_path) - 1);
        main_output_path[sizeof(main_output_path) - 1] = '\0';
    } else {
        // Treat as directory, append /main.c
        strncpy(actual_output_dir, output_dir, sizeof(actual_output_dir) - 1);
        actual_output_dir[sizeof(actual_output_dir) - 1] = '\0';
        snprintf(main_output_path, sizeof(main_output_path), "%s/main.c", output_dir);
    }

    // Create output directory if it doesn't exist
    if (!codegen_mkdir_p(actual_output_dir)) {
        fprintf(stderr, "Error: Could not create output directory: %s\n", actual_output_dir);
        cJSON_Delete(main_root);
        free(main_kir_json);
        return false;
    }

    int files_written = 0;

    // 1. Generate main.c from main.kir

    if (ir_generate_c_code_from_string(main_kir_json, main_output_path)) {
        printf("✓ Generated: main.c\n");
        files_written++;
    } else {
        fprintf(stderr, "Warning: Failed to generate main.c from KIR\n");
    }

    free(main_kir_json);

    // 2. Get the KIR directory (parent of kir_path)
    char kir_dir[2048];
    codegen_get_parent_dir(kir_path, kir_dir, sizeof(kir_dir));

    // 3. Track processed modules to avoid duplicates
    CodegenProcessedModules processed = {0};
    codegen_processed_modules_add(&processed, "main");  // Mark main as processed

    // 4. Process each import recursively (including transitive imports)
    // Imports are in source_structures.requires[].module
    cJSON* source_structures = cJSON_GetObjectItem(main_root, "source_structures");
    cJSON* requires = source_structures ? cJSON_GetObjectItem(source_structures, "requires") : NULL;
    if (requires && cJSON_IsArray(requires)) {
        cJSON* import_item = NULL;
        cJSON_ArrayForEach(import_item, requires) {
            cJSON* module_obj = cJSON_GetObjectItem(import_item, "module");
            if (!module_obj || !cJSON_IsString(module_obj)) continue;

            const char* module_path = cJSON_GetStringValue(module_obj);
            if (module_path) {
                // Convert module path (e.g., "components.habit_panel") to file path format
                char module_id[512];
                strncpy(module_id, module_path, sizeof(module_id) - 1);
                module_id[sizeof(module_id) - 1] = '\0';
                // Replace dots with slashes for file path
                for (char* p = module_id; *p; p++) {
                    if (*p == '.') *p = '/';
                }
                files_written += c_process_module_recursive(module_id, kir_dir,
                                                            actual_output_dir, &processed);
            }
        }
    }

    codegen_processed_modules_free(&processed);
    cJSON_Delete(main_root);

    if (files_written == 0) {
        fprintf(stderr, "Warning: No C files were generated\n");
        return false;
    }

    printf("✓ Generated %d C files in %s\n", files_written, actual_output_dir);
    return true;
}
