# HTML Transpilation and Roundtrip Validation

## Overview

Kryon supports HTML as a **first-class transpilation target**, enabling you to:
- **Export** Kryon applications as static HTML
- **Parse** HTML back to KIR (Kryon Intermediate Representation)
- **Validate** roundtrip transpilation: `.kir → HTML → .kir`

This document covers the HTML transpilation pipeline, CLI tools, and roundtrip validation workflow.

---

## Quick Start

### Parse HTML to KIR

```bash
# Parse HTML file to KIR (default output: same name with .kir extension)
kryon parse-html build/app.html

# Specify custom output path
kryon parse-html build/app.html --output=/tmp/roundtrip.kir
kryon parse-html build/app.html -o=/tmp/roundtrip.kir
```

### Roundtrip Validation

```bash
# Complete roundtrip test: .kir → HTML → .kir
./scripts/test_html_roundtrip.sh build/app.kir

# Custom HTML output path
./scripts/test_html_roundtrip.sh build/app.kir /tmp/app.html
```

---

## HTML Transpilation Modes

Kryon supports two HTML generation modes:

### 1. Display Mode (Web Runtime)
**Purpose**: Generate HTML for runtime rendering with interactivity

**Features**:
- Includes JavaScript event handlers (onclick, onchange)
- Includes runtime JavaScript libraries
- Uses kryon-* CSS classes for styling
- Full HTML5 document with head/body
- Optimized for browser execution

**Use case**: Web backend rendering, interactive applications

### 2. Transpilation Mode (Static Export)
**Purpose**: Generate clean, static HTML for export and documentation

**Features**:
- Structure + styles only (no JavaScript)
- Clean semantic HTML tags (h1-h6, ul, ol, table)
- Inline CSS or external stylesheet
- Metadata preservation via `data-*` attributes
- Parseable by HTML parser (roundtrip compatible)

**Use cases**:
- Static site generation
- Component library export
- Documentation generation
- Roundtrip validation

---

## CLI Commands

### `kryon parse-html`

Parse HTML files (generated by Kryon) back to KIR format.

**Syntax**:
```bash
kryon parse-html <input.html> [--output=file.kir]
```

**Arguments**:
- `<input.html>` - Path to HTML file to parse (required)

**Options**:
- `--output=<path>` or `-o=<path>` - Custom output path (default: same directory, .kir extension)

**Examples**:
```bash
# Parse HTML with default output name
kryon parse-html build/index.html
# Output: build/index.kir

# Specify custom output location
kryon parse-html build/index.html --output=/tmp/roundtrip.kir

# Parse multiple HTML files
for html in build/*.html; do
  kryon parse-html "$html"
done
```

**Output**:
```
Parsing HTML: build/index.html
Generated: build/index.kir

Summary:
  Root type: Container
  Child count: 3
```

**Exit Codes**:
- `0` - Success
- `1` - Error (file not found, parsing failed, etc.)

---

## HTML to KIR Pipeline

The HTML parsing pipeline consists of three stages:

### Stage 1: HTML → AST (Abstract Syntax Tree)
**Location**: `ir/ir_html_parser.c`

**Responsibilities**:
- Tokenize HTML (tags, attributes, text content)
- Parse tag hierarchy (opening/closing tags)
- Extract attributes (including `data-*` metadata)
- Build AST tree structure

**Example**:
```html
<div class="container" data-ir-type="Container" data-ir-id="42">
  <h1>Hello</h1>
</div>
```
↓ Parses to:
```
HtmlNode {
  type: HTML_NODE_ELEMENT
  tag_name: "div"
  class_name: "container"
  data_ir_type: "Container"
  data_ir_id: 42
  children: [
    HtmlNode {
      type: HTML_NODE_ELEMENT
      tag_name: "h1"
      children: [
        HtmlNode {
          type: HTML_NODE_TEXT
          text_content: "Hello"
        }
      ]
    }
  ]
}
```

### Stage 2: AST → IR (Intermediate Representation)
**Location**: `ir/ir_html_to_ir.c`

**Responsibilities**:
- Map HTML tags to IR component types
  - `h1-h6` → `IR_COMPONENT_HEADING`
  - `ul` → `IR_COMPONENT_LIST`
  - `button` → `IR_COMPONENT_BUTTON`
  - `div` → `IR_COMPONENT_CONTAINER`
- Parse inline CSS styles (`style` attribute)
- Reconstruct component tree
- Apply `data-*` attributes to preserve metadata

**Example**:
```html
<h1 style="font-size: 32px; color: #333;">Hello</h1>
```
↓ Converts to:
```c
IRComponent {
  type: IR_COMPONENT_HEADING
  text: "Hello"
  style: {
    font_size: 32
    text_color: { r: 0.2, g: 0.2, b: 0.2, a: 1.0 }
  }
}
```

### Stage 3: IR → JSON (KIR Serialization)
**Location**: `ir/ir_serialization.c`

**Responsibilities**:
- Serialize IR component tree to JSON
- Format as .kir file (Kryon Intermediate Representation)
- Include all component metadata, styles, and hierarchy

**Example**:
```json
{
  "id": 42,
  "type": "Heading",
  "text": "Hello",
  "style": {
    "fontSize": 32,
    "color": "#333333"
  }
}
```

---

## Roundtrip Validation

Roundtrip validation ensures that HTML transpilation preserves IR semantics:

**Pipeline**: `.kir (original) → HTML → .kir (roundtrip) → semantic comparison`

### Using the Roundtrip Test Script

The `test_html_roundtrip.sh` script automates the complete roundtrip validation:

**Syntax**:
```bash
./scripts/test_html_roundtrip.sh <input.kir> [output.html]
```

**What it does**:
1. **Step 1**: Transpile `.kir → HTML` (using transpilation mode)
2. **Step 2**: Parse `HTML → .kir` (using HTML parser)
3. **Step 3**: Compare original and roundtrip `.kir` files (semantic comparison)

**Example**:
```bash
# Test roundtrip for a KIR file
./scripts/test_html_roundtrip.sh build/generated/kir/hello_world.kir

# Output:
Testing HTML Roundtrip
======================
Original KIR:  build/generated/kir/hello_world.kir
HTML Output:   /tmp/roundtrip_hello_world.html
Roundtrip KIR: /tmp/roundtrip_hello_world_roundtrip.kir

Step 1: KIR → HTML (transpilation)
✓ HTML generated: /tmp/roundtrip_hello_world.html

Step 2: HTML → KIR (parsing)
✓ KIR roundtrip generated: /tmp/roundtrip_hello_world_roundtrip.kir

Step 3: Comparing KIR files (semantic)
✅ Roundtrip test PASSED
   HTML transpilation preserves IR semantics
```

**Exit Codes**:
- `0` - Roundtrip test passed (semantic equivalence)
- `1` - Roundtrip test failed (semantic differences)

### Semantic Comparison

The roundtrip validation uses **semantic comparison**, not byte-for-byte comparison. This means:

**What's Compared**:
- ✅ Component types (Container, Text, Button, etc.)
- ✅ Component hierarchy (parent-child relationships)
- ✅ Text content
- ✅ Styles (colors, dimensions, spacing)
- ✅ Component-specific attributes (heading level, list type, etc.)

**What's Ignored**:
- ❌ Component IDs (can be renumbered)
- ❌ Field ordering in JSON
- ❌ Whitespace and formatting
- ❌ Default values (e.g., `color: transparent` vs missing color)
- ❌ Color representation (hex vs named colors)

**Implementation**: Uses `scripts/compare_kir.sh` with `normalize_kir.jq` filter for normalization.

---

## Metadata Preservation

To ensure lossless roundtrip, HTML transpilation preserves IR metadata using `data-*` attributes:

### Core Metadata Attributes

| Attribute | Purpose | Example |
|-----------|---------|---------|
| `data-ir-type` | Component type | `data-ir-type="Heading"` |
| `data-ir-id` | Component ID | `data-ir-id="42"` |
| `data-level` | Heading level (h1-h6) | `data-level="1"` |
| `data-list-type` | List type | `data-list-type="ordered"` |
| `data-checked` | Checkbox state | `data-checked="true"` |
| `data-value` | Input value | `data-value="example text"` |

### Style Preservation

Styles are preserved using **inline CSS** (`style` attribute):

**Example**:
```html
<div style="width: 800px; height: 600px; background-color: #f0f0f0; padding: 20px;">
  <h1 style="color: #333; font-size: 32px;">Hello World</h1>
</div>
```

**CSS Property Mapping**:

| CSS Property | IR Property |
|--------------|-------------|
| `width` | `dimension.width` |
| `height` | `dimension.height` |
| `background-color` | `fill.color` |
| `color` | `text_color` |
| `font-size` | `font_size` |
| `padding` | `spacing.padding` |
| `margin` | `spacing.margin` |
| `border-radius` | `border.radius` |

---

## CSS Parsing

The HTML parser includes a CSS parser to convert inline styles back to IR properties.

**Location**: `ir/ir_css_parser.c`

**Supported CSS Properties**:
- Dimensions: `width`, `height`, `min-width`, `max-width`, etc.
- Colors: `color`, `background-color`, `border-color`
- Spacing: `padding`, `margin`, `gap`
- Typography: `font-size`, `font-weight`, `line-height`
- Borders: `border-width`, `border-radius`
- Layout: `display`, `flex-direction`, `justify-content`, `align-items`

**Color Formats**:
- Hex: `#ff0000`, `#f00`
- RGB: `rgb(255, 0, 0)`
- RGBA: `rgba(255, 0, 0, 0.5)`
- Named colors: `red`, `blue`, `transparent`

**Dimension Units**:
- Pixels: `100px`
- Percentages: `50%`
- Auto: `auto`

**Example**:
```css
style="width: 800px; height: 600px; background-color: rgba(240, 240, 240, 0.8);"
```
↓ Parses to:
```c
IRStyle {
  dimension: { width: 800, height: 600 }
  fill: { color: { r: 0.94, g: 0.94, b: 0.94, a: 0.8 } }
}
```

---

## HTML Tag Mapping

The HTML parser maps semantic HTML tags to IR component types:

### Basic Components

| HTML Tag | IR Component | Notes |
|----------|--------------|-------|
| `<div>` | `Container` | Generic container |
| `<span>` | `Container` | Inline container |
| `<p>` | `Text` | Paragraph text |

### Headings

| HTML Tag | IR Component | Level |
|----------|--------------|-------|
| `<h1>` | `Heading` | 1 |
| `<h2>` | `Heading` | 2 |
| `<h3>` | `Heading` | 3 |
| `<h4>` | `Heading` | 4 |
| `<h5>` | `Heading` | 5 |
| `<h6>` | `Heading` | 6 |

### Lists

| HTML Tag | IR Component | List Type |
|----------|--------------|-----------|
| `<ul>` | `List` | Unordered |
| `<ol>` | `List` | Ordered |
| `<li>` | `ListItem` | - |

### Interactive Components

| HTML Tag | IR Component | Notes |
|----------|--------------|-------|
| `<button>` | `Button` | Click handler |
| `<input type="text">` | `Input` | Text input |
| `<input type="checkbox">` | `Checkbox` | Toggle state |

### Tables

| HTML Tag | IR Component | Notes |
|----------|--------------|-------|
| `<table>` | `Table` | Table container |
| `<thead>` | `TableHeader` | Header row group |
| `<tbody>` | `TableBody` | Body rows |
| `<tr>` | `TableRow` | Single row |
| `<th>` | `TableHeaderCell` | Header cell |
| `<td>` | `TableCell` | Data cell |

---

## Error Handling

### HTML Parsing Warnings

The HTML parser may emit warnings for malformed HTML:

```
Warning: Mismatched closing tag </div>, expected </span>
Warning: Unclosed tag <p>
```

**Behavior**: Parser attempts to recover and continue parsing. Warnings are informational only.

### Parsing Failures

If HTML parsing fails completely:

```
Error: Failed to parse HTML file: build/app.html
```

**Common Causes**:
- File not found
- Empty or corrupted HTML file
- Severe HTML malformation (missing `<html>`, `<body>`, etc.)

**Solution**: Check HTML file validity and ensure it was generated by Kryon.

### Roundtrip Failures

If roundtrip validation fails:

```
❌ Roundtrip test FAILED
   Original and roundtrip KIR differ semantically

Original:  build/app.kir
Roundtrip: /tmp/roundtrip.kir
HTML:      /tmp/app.html
```

**Common Causes**:
- CSS property not supported by parser
- Metadata not preserved (missing `data-*` attributes)
- HTML malformation during transpilation

**Debugging**:
1. Inspect original KIR: `jq . build/app.kir`
2. Inspect HTML: `cat /tmp/app.html`
3. Inspect roundtrip KIR: `jq . /tmp/roundtrip.kir`
4. Compare differences: `diff <(jq -S . build/app.kir) <(jq -S . /tmp/roundtrip.kir)`

---

## Use Cases

### 1. Static Site Generation

Export Kryon applications as static HTML for deployment:

```bash
# Build application to HTML
kryon build --target=html app.kry -o build/index.html

# Deploy to static hosting
cp build/index.html /var/www/html/
```

### 2. Component Library Export

Export reusable components as HTML snippets:

```bash
# Generate HTML for each component
for kry in components/*.kry; do
  kryon build --target=html "$kry" -o "dist/$(basename "$kry" .kry).html"
done
```

### 3. Documentation Generation

Generate HTML documentation from .kry sources:

```bash
# Build docs
kryon build --target=html docs/getting-started.kry -o docs/build/index.html

# Validate roundtrip
./scripts/test_html_roundtrip.sh .kryon_cache/*.kir
```

### 4. Roundtrip Testing in CI/CD

Validate HTML transpilation in continuous integration:

```bash
#!/bin/bash
# .github/workflows/test-html-roundtrip.yml

# Generate all examples
./scripts/generate_examples.sh

# Test HTML roundtrip for each example
for kir in build/generated/kir/*.kir; do
  if ! ./scripts/test_html_roundtrip.sh "$kir"; then
    echo "❌ Roundtrip failed for $kir"
    exit 1
  fi
done

echo "✅ All HTML roundtrip tests passed"
```

---

## Limitations and Future Work

### Current Limitations

1. **No External CSS**
   - Only inline CSS (`style` attribute) is supported
   - External stylesheets (`.css` files) are not parsed
   - **Workaround**: Use inline styles in transpilation mode

2. **No JavaScript Parsing**
   - Event handlers and runtime JS are not parsed
   - Only static structure is preserved
   - **Workaround**: HTML roundtrip is for structure validation only

3. **Limited HTML5 Support**
   - Parser focuses on Kryon-generated HTML
   - Not a full HTML5 parser (doesn't handle all edge cases)
   - **Workaround**: Only parse HTML generated by Kryon transpiler

4. **No Minification**
   - Generated HTML is not minified
   - File sizes larger than necessary for production
   - **Workaround**: Use external minifier (`html-minifier`)

5. **Custom Component Definitions Not Preserved**
   - HTML roundtrip flattens custom component definitions (KIR v3.0)
   - Custom component types (Header, Footer, FeatureCard, etc.) become primitives
   - Only basic IR types preserved (Column, Row, Text, Button, etc.)
   - **Why**: HTML is a flat markup language, cannot represent component abstractions
   - **Workaround**: Use roundtrip validation for primitive components only

6. **Empty Text Nodes from HTML Whitespace**
   - HTML parser creates Text nodes for whitespace between elements (per HTML spec)
   - Text component count appears inflated in roundtrip KIR
   - **Why**: Standard HTML parsing behavior to preserve document structure
   - **Workaround**: Semantic comparison should ignore empty/whitespace-only text nodes

### Roundtrip Validation Results

**Tested**: kryon-website (TSX → KIR v3.0 → HTML → KIR v2.0 roundtrip)

**Successfully Preserved**:
- ✅ **Basic IR component types**: Row, Column, Text, Button, Input, Image, etc.
- ✅ **Component hierarchy**: Parent-child relationships intact
- ✅ **Text content**: All non-whitespace text preserved
- ✅ **Inline styles**: CSS properties from `style` attributes

**Expected Differences**:
- ⚠️ **Custom components flattened**: Header → Row, FeatureCard → Column + Container
- ⚠️ **Format version change**: KIR v3.0 (with `component_definitions`) → v2.0 (flat tree)
- ⚠️ **Empty text nodes**: HTML whitespace creates additional Text components

**Example Results** (kryon-website project):
| Component | Original | Roundtrip | Status |
|-----------|----------|-----------|--------|
| Row       | 12       | 12        | ✅ Perfect match |
| Image     | 1        | 1         | ✅ Perfect match |
| Text      | 17       | 51*       | ⚠️ *32 empty nodes from whitespace |
| Column    | 14       | 21        | ⚠️ Custom components inlined |

**Conclusion**: HTML roundtrip successfully preserves **semantic structure for basic IR components**.
Custom component abstractions are an expected loss due to HTML's flat nature.

### Future Enhancements

**Phase 6: Minification** (Planned)
- Built-in HTML minification
- Remove whitespace, comments
- Collapse multiple spaces
- Inline critical CSS

**Phase 7: External CSS Support** (Future)
- Parse external `.css` files
- Map CSS classes to IR components
- Generate separate stylesheet files

**Full HTML5 Parser** (Future)
- Support arbitrary HTML input (not just Kryon-generated)
- Handle all HTML5 elements
- Robust error recovery

---

## TOML Configuration

### Web Build Settings

Configure HTML transpilation behavior in your `kryon.toml` file:

#### Basic Web Build

```toml
[build]
targets = ["web"]
output_dir = "build"
frontend = "tsx"  # or "nim", "kry"

[web]
generate_separate_files = true   # Generate separate HTML files per page
include_js_runtime = false       # true = interactive, false = static
minify_css = true                # ✅ Implemented (CSS minification)
minify_js = true                 # For JS runtime (if enabled)
```

#### Multi-Page Sites with Docs

```toml
[[build.pages]]
file = "index.tsx"
path = "/"

[build.docs]
enabled = true
directory = "docs"               # Markdown files location
template = "docs.tsx"            # Template for doc pages
base_path = "/docs"              # URL base path
index_file = "getting-started.md"  # Landing doc page
```

#### Optimization Settings

```toml
[build.optimization]
enabled = true
minify_css = true    # ✅ CSS minification (one rule per line)
minify_js = true     # JS minification (if JS runtime enabled)
# Note: HTML minification not yet implemented (future work)
```

### Build Modes

#### Development (Debug) Build

**Purpose**: Non-minified output with metadata for debugging and roundtrip validation

```toml
[build]
targets = ["web"]

[build.optimization]
enabled = false      # Disable optimizations

[web]
include_js_runtime = true   # For hot reload, dev tools
minify_css = false
minify_js = false
```

**Result**:
- Readable HTML with indentation
- Readable CSS with comments
- `data-*` attributes preserved for roundtrip

**Use case**: Local development, testing, roundtrip validation

#### Production Build

**Purpose**: Optimized output for deployment

```toml
[build]
targets = ["web"]

[build.optimization]
enabled = true
minify_css = true
minify_js = true

[web]
generate_separate_files = true
include_js_runtime = false   # Static site (no JS)
minify_css = true
minify_js = true
```

**Result**:
- ✅ CSS minified (one rule per line, ~30-40% smaller)
- ⚠️ HTML NOT minified (pretty-printed, limitation)
- Clean semantic HTML tags
- Optimized file sizes

**Use case**: Production deployment, static hosting

### Plugin Configuration

For markdown rendering support:

```toml
[plugins]
markdown = { path = "../kryon-plugin-markdown" }
```

**Note**: Markdown plugin must be built separately before use.

### Complete Example

**kryon-website/kryon.toml** (production config):

```toml
[project]
name = "kryon-website"
version = "1.0.0"
author = "Kryon Labs"
description = "Official Kryon website built with Kryon"

[build]
targets = ["web"]
output_dir = "build"
frontend = "tsx"

[[build.pages]]
file = "index.tsx"
path = "/"

[build.docs]
enabled = true
directory = "docs"
template = "docs.tsx"
base_path = "/docs"
index_file = "getting-started.md"

[build.optimization]
enabled = true
minify_css = true
minify_js = true

[plugins]
markdown = { path = "../kryon-plugin-markdown" }

[web]
generate_separate_files = true
include_js_runtime = false
minify_css = true
minify_js = true

[dev]
hot_reload = true
port = 3000
watch_paths = ["index.tsx", "docs.tsx", "docs/**/*.md"]

[metadata]
created = "2025-11-30"
kryon_version = "1.2.0"
```

### Build Commands

```bash
# Production build (uses kryon.toml config)
kryon build --targets=web

# Override output directory
kryon build --targets=web --output=dist

# Development build with watch mode (if implemented)
kryon dev

# Build specific page only
kryon build index.tsx --target=html
```

### Configuration Reference

| Setting | Type | Default | Description | Status |
|---------|------|---------|-------------|--------|
| `build.targets` | array | - | Build targets (`["web"]`) | ✅ Implemented |
| `build.output_dir` | string | `"build"` | Output directory path | ✅ Implemented |
| `build.frontend` | string | - | Frontend language (tsx/nim/kry) | ✅ Implemented |
| `build.docs.enabled` | bool | `false` | Enable markdown docs | ✅ Implemented |
| `build.docs.directory` | string | `"docs"` | Markdown files location | ✅ Implemented |
| `build.docs.template` | string | - | Template for doc pages | ✅ Implemented |
| `build.optimization.enabled` | bool | `false` | Enable all optimizations | ✅ Implemented |
| `build.optimization.minify_css` | bool | `false` | Minify CSS output | ✅ Implemented |
| `build.optimization.minify_js` | bool | `false` | Minify JS output | ⚠️ If JS enabled |
| `web.generate_separate_files` | bool | `true` | Multi-page vs single HTML | ✅ Implemented |
| `web.include_js_runtime` | bool | `false` | Include interactive JS | ✅ Implemented |
| `web.minify_css` | bool | `false` | CSS minification | ✅ Implemented |
| `web.minify_js` | bool | `false` | JS minification | ⚠️ If JS enabled |

**Legend**:
- ✅ Implemented and working
- ⚠️ Partially implemented or conditional
- ❌ Not yet implemented

**Known Limitations**:
- HTML minification flag exists but not connected (`HtmlGeneratorOptions.minify` not used)
- CSS minification works (one rule per line)
- JS minification only applies when `include_js_runtime = true`

---

## API Reference

### C API

#### HTML Parsing

```c
// Parse HTML string to AST
HtmlNode* ir_html_parse(const char* html, size_t length);

// Parse HTML file to AST
HtmlNode* ir_html_parse_file(const char* filepath);

// Free HTML AST
void html_node_free(HtmlNode* node);

// Convert AST to IR
IRComponent* ir_html_to_ir_convert(HtmlNode* html_root);

// Parse HTML string to KIR JSON
char* ir_html_to_kir(const char* html, size_t length);

// Parse HTML file to KIR JSON
char* ir_html_file_to_kir(const char* filepath);
```

#### CSS Parsing

```c
// Parse inline CSS to properties
CSSProperty* parse_inline_css(const char* style_string, uint32_t* count);

// Apply CSS properties to IR style
void apply_css_to_ir_style(IRStyle* style, CSSProperty* props, uint32_t count);
```

### Nim API

#### HTML Parsing

```nim
# Parse HTML file to KIR JSON string
proc parseHTMLToKir*(htmlPath: string): string

# Parse HTML string to KIR JSON
proc parseHTMLStringToKir*(html: string): string

# Parse HTML file and write KIR to file
proc parseHTMLToKirFile*(htmlPath: string, outputPath: string)
```

**Example**:
```nim
import html_parser

# Parse HTML to KIR
let kir = parseHTMLToKir("build/app.html")
echo "KIR JSON: ", kir

# Parse and save to file
parseHTMLToKirFile("build/app.html", "build/roundtrip.kir")
```

---

## Testing

### Unit Tests

**C Level**:
```bash
# Build test tools
cd ir
gcc -std=c99 -I. test_html_to_kir.c ../build/libkryon_ir.a \
    -lm -lharfbuzz -lfreetype -lfribidi -o ../build/test_html_to_kir

# Test HTML parsing
../build/test_html_to_kir examples/kry/build/kryon-app.html
```

### Integration Tests

**CLI Level**:
```bash
# Test parse-html command
kryon parse-html build/app.html
kryon parse-html build/app.html --output=/tmp/test.kir

# Verify output is valid JSON
jq . /tmp/test.kir
```

### Roundtrip Tests

**Automated Validation**:
```bash
# Test single example
./scripts/test_html_roundtrip.sh build/generated/kir/button_demo.kir

# Test all examples
for kir in build/generated/kir/*.kir; do
  ./scripts/test_html_roundtrip.sh "$kir"
done
```

---

## Troubleshooting

### Issue: "File not found" Error

```
Error: File not found: build/app.html
```

**Solution**: Verify file path is correct and file exists:
```bash
ls -la build/app.html
```

### Issue: "Failed to parse HTML file"

```
Error: Failed to parse HTML file: build/app.html
```

**Solution**: Check HTML file validity:
```bash
# Check file size
ls -lh build/app.html

# Check file content
head -50 build/app.html

# Validate HTML structure
grep -E '<html|<body|</html>' build/app.html
```

### Issue: Invalid KIR JSON

```
Error: Failed to serialize IR to JSON
```

**Solution**: This indicates IR conversion failed. Check debug output:
```bash
# Re-run with stderr visible
kryon parse-html build/app.html 2>&1 | less
```

### Issue: Roundtrip Test Fails

```
❌ Roundtrip test FAILED
```

**Solution**: Debug by comparing original and roundtrip KIR:
```bash
# Pretty-print both files
jq -S . build/app.kir > /tmp/original.json
jq -S . /tmp/roundtrip.kir > /tmp/roundtrip.json

# Compare side-by-side
diff -y /tmp/original.json /tmp/roundtrip.json | less
```

---

## See Also

- [KIR Format Specification](KIR_FORMAT_V2.md)
- [Developer Guide](DEVELOPER_GUIDE.md)
- [Build System Documentation](BUILD_SYSTEM.md)
- CLI Command Reference: `kryon --help`

---

## Contributors

HTML transpilation implementation by Claude Code (December 2024).

For questions, issues, or contributions, see [CONTRIBUTING.md](../CONTRIBUTING.md).
