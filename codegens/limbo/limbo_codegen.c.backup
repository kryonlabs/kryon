/**
 * Limbo Code Generator
 * Generates Limbo source (.b) files from KIR JSON for Inferno/TaijiOS
 */

#define _POSIX_C_SOURCE 200809L

#include "limbo_codegen.h"
#include "../codegen_common.h"
#include "../../third_party/cJSON/cJSON.h"
#include "../../ir/include/ir_core.h"
#include "../../ir/include/ir_serialization.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>

// Helper to append string to buffer with reallocation
static bool append_string(char** buffer, size_t* size, size_t* capacity, const char* str) {
    size_t len = strlen(str);
    if (*size + len >= *capacity) {
        *capacity *= 2;
        char* new_buffer = realloc(*buffer, *capacity);
        if (!new_buffer) return false;
        *buffer = new_buffer;
    }
    strcpy(*buffer + *size, str);
    *size += len;
    return true;
}

// Helper to append formatted string
static bool append_fmt(char** buffer, size_t* size, size_t* capacity, const char* fmt, ...) {
    char temp[4096];
    va_list args;
    va_start(args, fmt);
    vsnprintf(temp, sizeof(temp), fmt, args);
    va_end(args);
    return append_string(buffer, size, capacity, temp);
}

// Context for Limbo generation
typedef struct {
    char* buffer;
    size_t size;
    size_t capacity;
    bool include_comments;
    bool generate_types;
    const char* module_name;
    int widget_counter;
    int event_handler_counter;
    char** modules;             // Additional modules to include
    int modules_count;          // Number of additional modules

    // Handler deduplication tracking
    char* generated_handlers[256];     // Names of already-generated handlers
    int generated_handler_count;       // Number of handlers generated
} LimboContext;

// Initialize Limbo context
static LimboContext* create_limbo_context(LimboCodegenOptions* options) {
    LimboContext* ctx = malloc(sizeof(LimboContext));
    if (!ctx) return NULL;

    ctx->capacity = 8192;
    ctx->size = 0;
    ctx->buffer = malloc(ctx->capacity);
    if (!ctx->buffer) {
        free(ctx);
        return NULL;
    }
    ctx->buffer[0] = '\0';

    if (options) {
        ctx->include_comments = options->include_comments;
        ctx->generate_types = options->generate_types;
        ctx->module_name = options->module_name;
        ctx->modules = options->modules;
        ctx->modules_count = options->modules_count;
    } else {
        ctx->include_comments = true;
        ctx->generate_types = true;
        ctx->module_name = NULL;
        ctx->modules = NULL;
        ctx->modules_count = 0;
    }

    ctx->widget_counter = 0;
    ctx->event_handler_counter = 0;
    ctx->generated_handler_count = 0;

    return ctx;
}

// Free Limbo context
static void destroy_limbo_context(LimboContext* ctx) {
    if (!ctx) return;
    free(ctx->buffer);
    // Free handler tracking
    for (int i = 0; i < ctx->generated_handler_count; i++) {
        if (ctx->generated_handlers[i]) {
            free(ctx->generated_handlers[i]);
        }
    }
    free(ctx);
}

// Check if handler was already generated
static bool is_handler_already_generated(LimboContext* ctx, const char* handler_name) {
    if (!ctx || !handler_name) return false;

    for (int i = 0; i < ctx->generated_handler_count; i++) {
        if (ctx->generated_handlers[i] &&
            strcmp(ctx->generated_handlers[i], handler_name) == 0) {
            return true;
        }
    }
    return false;
}

// Mark handler as generated
static void mark_handler_generated(LimboContext* ctx, const char* handler_name) {
    if (!ctx || !handler_name || ctx->generated_handler_count >= 256) {
        return;
    }

    ctx->generated_handlers[ctx->generated_handler_count++] = strdup(handler_name);
}

// Track event handler names (for onClick mapping)
typedef struct {
    int handler_number;      // 1, 2, 3, ... (for click1, click2, etc.)
    char* handler_name;      // "handleButtonClick", etc.
} EventHandlerMapping;

static EventHandlerMapping event_handlers[256];
static int event_handler_mapping_count = 0;

// Store mapping between handler number and name
static void register_event_handler(int number, const char* name) {
    if (event_handler_mapping_count >= 256 || !name) return;

    event_handlers[event_handler_mapping_count].handler_number = number;
    event_handlers[event_handler_mapping_count].handler_name = strdup(name);
    event_handler_mapping_count++;
}

// Get handler name by number
static const char* get_handler_name_by_number(int number) {
    for (int i = 0; i < event_handler_mapping_count; i++) {
        if (event_handlers[i].handler_number == number) {
            return event_handlers[i].handler_name;
        }
    }
    return NULL;
}

// Cleanup handler mappings
static void cleanup_event_handler_mappings() {
    for (int i = 0; i < event_handler_mapping_count; i++) {
        if (event_handlers[i].handler_name) {
            free(event_handlers[i].handler_name);
        }
    }
    event_handler_mapping_count = 0;
}

// Extract module name from filename
static char* extract_module_name(const char* filename) {
    if (!filename) return strdup("KryonApp");

    // Find the last '/' or '\\'
    const char* base = strrchr(filename, '/');
    if (!base) base = strrchr(filename, '\\');
    if (base) base++;
    else base = filename;

    // Remove extension
    const char* dot = strrchr(base, '.');
    size_t len = dot ? (size_t)(dot - base) : strlen(base);

    char* name = malloc(len + 1);
    if (!name) return NULL;

    strncpy(name, base, len);
    name[len] = '\0';

    // Capitalize first letter
    if (name[0]) {
        name[0] = toupper(name[0]);
    }

    return name;
}

// Map KIR element type to Tk widget type
static const char* map_element_to_tk_widget(const char* element_type) {
    if (!element_type) return "frame";

    if (strcmp(element_type, "Container") == 0) return "frame";
    if (strcmp(element_type, "Button") == 0) return "button";
    if (strcmp(element_type, "Text") == 0) return "label";
    if (strcmp(element_type, "Label") == 0) return "label";
    if (strcmp(element_type, "Input") == 0) return "entry";
    if (strcmp(element_type, "TextInput") == 0) return "entry";
    if (strcmp(element_type, "Image") == 0) return "label";  // Use label with image
    if (strcmp(element_type, "Checkbox") == 0) return "checkbutton";
    if (strcmp(element_type, "Radio") == 0) return "radiobutton";
    if (strcmp(element_type, "Canvas") == 0) return "canvas";
    if (strcmp(element_type, "ListBox") == 0) return "listbox";
    if (strcmp(element_type, "Menu") == 0) return "menu";
    if (strcmp(element_type, "Frame") == 0) return "frame";

    return "frame";  // Default fallback
}

// Generate widget path name
static void generate_widget_path(char* buffer, size_t buffer_size, int widget_id, const char* parent_path) {
    if (parent_path && strlen(parent_path) > 0) {
        snprintf(buffer, buffer_size, "%s.w%d", parent_path, widget_id);
    } else {
        snprintf(buffer, buffer_size, ".w%d", widget_id);
    }
}

// Parse size value (e.g., "200.0px" â†’ 200)
static int parse_size_value(const char* value) {
    if (!value) return 0;
    return (int)atof(value);  // Extracts number, ignores "px"
}

// Convert hex color to TK color name or keep simple colors
static const char* convert_to_tk_color(const char* hex_color) {
    if (!hex_color) return "white";

    // Skip transparent colors
    if (strstr(hex_color, "#00000000") || strcmp(hex_color, "transparent") == 0) {
        return NULL;  // Don't set this color
    }

    // Common color mappings
    if (strcmp(hex_color, "#ffffff") == 0 || strcmp(hex_color, "#FFFFFF") == 0) return "white";
    if (strcmp(hex_color, "#000000") == 0) return "black";
    if (strcmp(hex_color, "#ff0000") == 0 || strcmp(hex_color, "#FF0000") == 0) return "red";
    if (strcmp(hex_color, "#00ff00") == 0 || strcmp(hex_color, "#00FF00") == 0) return "green";
    if (strcmp(hex_color, "#0000ff") == 0 || strcmp(hex_color, "#0000FF") == 0) return "blue";
    if (strcmp(hex_color, "#ffff00") == 0 || strcmp(hex_color, "#FFFF00") == 0) return "yellow";
    if (strcmp(hex_color, "#00ffff") == 0 || strcmp(hex_color, "#00FFFF") == 0) return "cyan";
    if (strcmp(hex_color, "#ff00ff") == 0 || strcmp(hex_color, "#FF00FF") == 0) return "magenta";
    if (strcmp(hex_color, "#808080") == 0) return "gray";

    // For other colors, use the hex value as-is (TK supports some hex)
    return hex_color;
}

// Generate Tk options from KIR properties
static void generate_tk_options(LimboContext* ctx, cJSON* component, const char* parent_bg) {
    if (!component) return;

    // Text content
    cJSON* text = cJSON_GetObjectItem(component, "text");
    if (text && text->type == cJSON_String) {
        append_fmt(&ctx->buffer, &ctx->size, &ctx->capacity, " -text {%s}", text->valuestring);
    }

    // Width (can be string like "200.0px" or number)
    cJSON* width = cJSON_GetObjectItem(component, "width");
    if (width) {
        if (width->type == cJSON_String) {
            int w = parse_size_value(width->valuestring);
            if (w > 0) {
                append_fmt(&ctx->buffer, &ctx->size, &ctx->capacity, " -width %d", w);
            }
        } else if (width->type == cJSON_Number) {
            append_fmt(&ctx->buffer, &ctx->size, &ctx->capacity, " -width %d", width->valueint);
        }
    }

    // Height
    cJSON* height = cJSON_GetObjectItem(component, "height");
    if (height) {
        if (height->type == cJSON_String) {
            int h = parse_size_value(height->valuestring);
            if (h > 0) {
                append_fmt(&ctx->buffer, &ctx->size, &ctx->capacity, " -height %d", h);
            }
        } else if (height->type == cJSON_Number) {
            append_fmt(&ctx->buffer, &ctx->size, &ctx->capacity, " -height %d", height->valueint);
        }
    }

    // Background color
    cJSON* background = cJSON_GetObjectItem(component, "background");
    cJSON* type = cJSON_GetObjectItem(component, "type");
    const char* widget_type = (type && type->type == cJSON_String) ? type->valuestring : "";
    bool is_text = (strcmp(widget_type, "Text") == 0 || strcmp(widget_type, "Label") == 0);

    if (background && background->type == cJSON_String) {
        const char* tk_color = convert_to_tk_color(background->valuestring);
        if (tk_color) {
            append_fmt(&ctx->buffer, &ctx->size, &ctx->capacity, " -bg %s", tk_color);
        } else if (is_text && parent_bg) {
            // Transparent background on text - use parent's background
            append_fmt(&ctx->buffer, &ctx->size, &ctx->capacity, " -bg %s", parent_bg);
        }
    } else if (is_text && parent_bg) {
        // No background specified on text - use parent's background
        append_fmt(&ctx->buffer, &ctx->size, &ctx->capacity, " -bg %s", parent_bg);
    }

    // Foreground color (text color)
    cJSON* color = cJSON_GetObjectItem(component, "color");
    if (color && color->type == cJSON_String) {
        const char* tk_color = convert_to_tk_color(color->valuestring);
        if (tk_color) {
            append_fmt(&ctx->buffer, &ctx->size, &ctx->capacity, " -fg %s", tk_color);
        }
    }

    // Border
    cJSON* border = cJSON_GetObjectItem(component, "border");
    if (border && cJSON_IsObject(border)) {
        cJSON* border_width = cJSON_GetObjectItem(border, "width");
        cJSON* border_color = cJSON_GetObjectItem(border, "color");

        if (border_width && border_width->type == cJSON_Number) {
            append_fmt(&ctx->buffer, &ctx->size, &ctx->capacity, " -borderwidth %d", border_width->valueint);
        }
        if (border_color && border_color->type == cJSON_String) {
            append_fmt(&ctx->buffer, &ctx->size, &ctx->capacity, " -relief raised");
        }
    }

    // Font - use TaijiOS default font if not specified
    cJSON* font = cJSON_GetObjectItem(component, "font");
    if (font && font->type == cJSON_String) {
        append_fmt(&ctx->buffer, &ctx->size, &ctx->capacity, " -font {%s}", font->valuestring);
    } else {
        // Add default font for text elements
        cJSON* type = cJSON_GetObjectItem(component, "type");
        if (type && type->type == cJSON_String) {
            if (strcmp(type->valuestring, "Text") == 0 || strcmp(type->valuestring, "Label") == 0) {
                append_string(&ctx->buffer, &ctx->size, &ctx->capacity, " -font /fonts/lucidasans/latin1.7.font");
            }
        }
    }

    // Add padding for text elements to make them visible (reuse 'type' from above)
    if (is_text) {
        append_string(&ctx->buffer, &ctx->size, &ctx->capacity, " -padx 5 -pady 5");
    }
}

// Forward declaration
static bool process_component(LimboContext* ctx, cJSON* component, const char* parent_path, int depth, const char* parent_bg, const char* parent_type);

// Generate widget creation code
static bool generate_widget(LimboContext* ctx, cJSON* component, const char* parent_path, int depth, const char* parent_bg, const char* parent_type) {
    // KIR uses "type" not "elementType"
    cJSON* element_type_obj = cJSON_GetObjectItem(component, "type");
    if (!element_type_obj || element_type_obj->type != cJSON_String) {
        return false;
    }

    const char* element_type = element_type_obj->valuestring;
    const char* tk_widget = map_element_to_tk_widget(element_type);

    ctx->widget_counter++;
    char widget_path[256];
    generate_widget_path(widget_path, sizeof(widget_path), ctx->widget_counter, parent_path);

    // Add indentation
    for (int i = 0; i < depth; i++) {
        append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "\t");
    }

    if (ctx->include_comments) {
        append_fmt(&ctx->buffer, &ctx->size, &ctx->capacity, "# Create %s widget\n", element_type);
        for (int i = 0; i < depth; i++) {
            append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "\t");
        }
    }

    // Get this widget's background color for passing to children
    cJSON* my_background = cJSON_GetObjectItem(component, "background");
    const char* my_bg = NULL;
    if (my_background && my_background->type == cJSON_String) {
        my_bg = convert_to_tk_color(my_background->valuestring);
    }

    // Generate Tk command
    append_fmt(&ctx->buffer, &ctx->size, &ctx->capacity, "tk->cmd(t, \"%s %s", tk_widget, widget_path);

    // Add properties as Tk options (KIR has properties directly on component)
    generate_tk_options(ctx, component, parent_bg);

    // Check for event handlers
    cJSON* on_click = cJSON_GetObjectItem(component, "onClick");
    if (on_click && on_click->type == cJSON_String) {
        ctx->event_handler_counter++;

        // Register the handler name with its number
        register_event_handler(ctx->event_handler_counter, on_click->valuestring);

        append_fmt(&ctx->buffer, &ctx->size, &ctx->capacity,
                  " -command {send eventch click%d}", ctx->event_handler_counter);
    }

    append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "\");\n");

    // Process children
    cJSON* children = cJSON_GetObjectItem(component, "children");
    if (children && cJSON_IsArray(children)) {
        cJSON* child = NULL;
        cJSON_ArrayForEach(child, children) {
            process_component(ctx, child, widget_path, depth, my_bg, element_type);
        }
    }

    // Pack or place the widget
    for (int i = 0; i < depth; i++) {
        append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "\t");
    }

    // Check if widget has explicit dimensions
    cJSON* width = cJSON_GetObjectItem(component, "width");
    cJSON* height = cJSON_GetObjectItem(component, "height");
    bool has_explicit_size = (width != NULL) || (height != NULL);

    cJSON* type = cJSON_GetObjectItem(component, "type");
    const char* widget_type = (type && type->type == cJSON_String) ? type->valuestring : "";
    bool is_text = (strcmp(widget_type, "Text") == 0 || strcmp(widget_type, "Label") == 0);

    // Check for positioning properties
    cJSON* left = cJSON_GetObjectItem(component, "left");
    cJSON* top = cJSON_GetObjectItem(component, "top");
    bool has_position = (left && left->type == cJSON_Number) && (top && top->type == cJSON_Number);

    // Check if parent is a Center widget
    bool parent_is_center = (parent_type && strcmp(parent_type, "Center") == 0);

    if (depth == 1) {
        // Root widget fills the window
        append_fmt(&ctx->buffer, &ctx->size, &ctx->capacity, "tk->cmd(t, \"pack %s -fill both -expand 1\");\n", widget_path);
    } else if (parent_is_center) {
        // Widget inside Center - use expand to center both X and Y
        append_fmt(&ctx->buffer, &ctx->size, &ctx->capacity, "tk->cmd(t, \"pack %s -expand 1\");\n", widget_path);
    } else if (is_text && depth > 2) {
        // Text inside a container - use pack with expand (not place, which doesn't work)
        append_fmt(&ctx->buffer, &ctx->size, &ctx->capacity, "tk->cmd(t, \"pack %s -expand 1\");\n", widget_path);
    } else if (has_position && has_explicit_size) {
        // Widget with explicit position - use pack with anchor and padding
        append_fmt(&ctx->buffer, &ctx->size, &ctx->capacity, "tk->cmd(t, \"pack %s -anchor nw -padx %d -pady %d\");\n",
                  widget_path, (int)left->valueint, (int)top->valueint);
    } else if (has_explicit_size) {
        // Widget with explicit dimensions but no position - pack with default padding
        append_fmt(&ctx->buffer, &ctx->size, &ctx->capacity, "tk->cmd(t, \"pack %s -padx 20 -pady 20\");\n", widget_path);
    } else {
        // Widget without explicit size - pack with expand
        append_fmt(&ctx->buffer, &ctx->size, &ctx->capacity, "tk->cmd(t, \"pack %s -fill both -expand 1\");\n", widget_path);
    }

    return true;
}

// Process a component recursively
static bool process_component(LimboContext* ctx, cJSON* component, const char* parent_path, int depth, const char* parent_bg, const char* parent_type) {
    return generate_widget(ctx, component, parent_path, depth + 1, parent_bg, parent_type);
}

// Generate custom Limbo functions from logic_block
static void generate_limbo_custom_functions(LimboContext* ctx, cJSON* logic_block) {
    if (!ctx || !logic_block) return;

    // Extract functions array from logic_block
    cJSON* functions = cJSON_GetObjectItem(logic_block, "functions");
    if (!functions || !cJSON_IsArray(functions)) {
        return;  // No functions defined
    }

    // Add comment separator
    if (ctx->include_comments) {
        append_string(&ctx->buffer, &ctx->size, &ctx->capacity,
                     "\n# Custom Event Handlers\n");
    }

    // Iterate through each function
    int func_count = cJSON_GetArraySize(functions);
    for (int i = 0; i < func_count; i++) {
        cJSON* func = cJSON_GetArrayItem(functions, i);
        if (!func) continue;

        // Get function name
        cJSON* name_obj = cJSON_GetObjectItem(func, "name");
        if (!name_obj || !name_obj->valuestring) continue;
        const char* func_name = name_obj->valuestring;

        // Skip if already generated
        if (is_handler_already_generated(ctx, func_name)) {
            continue;
        }

        // Get sources array
        cJSON* sources = cJSON_GetObjectItem(func, "sources");
        if (!sources || !cJSON_IsArray(sources)) continue;

        // Look for Limbo source
        const char* limbo_source = NULL;
        int source_count = cJSON_GetArraySize(sources);

        for (int j = 0; j < source_count; j++) {
            cJSON* src = cJSON_GetArrayItem(sources, j);
            if (!src) continue;

            cJSON* lang = cJSON_GetObjectItem(src, "language");
            if (!lang || !lang->valuestring) continue;

            if (strcmp(lang->valuestring, "limbo") == 0) {
                cJSON* src_code = cJSON_GetObjectItem(src, "source");
                if (src_code && src_code->valuestring) {
                    limbo_source = src_code->valuestring;
                    break;  // Found Limbo source, use it
                }
            }
        }

        // Output Limbo source if found
        if (limbo_source) {
            mark_handler_generated(ctx, func_name);
            append_string(&ctx->buffer, &ctx->size, &ctx->capacity, limbo_source);
            append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "\n\n");
        }
    }
}

// Generate module header
static bool generate_module_header(LimboContext* ctx, const char* module_name) {
    append_fmt(&ctx->buffer, &ctx->size, &ctx->capacity, "implement %s;\n\n", module_name);

    // Always include core modules
    append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "include \"sys.m\";\n");
    append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "\tsys: Sys;\n");
    append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "include \"draw.m\";\n");
    append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "\tdraw: Draw;\n");
    append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "include \"tk.m\";\n");
    append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "\ttk: Tk;\n");
    append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "include \"tkclient.m\";\n");
    append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "\ttkclient: Tkclient;\n");

    // Include additional modules from config
    if (ctx->modules && ctx->modules_count > 0) {
        for (int i = 0; i < ctx->modules_count; i++) {
            const char* module_alias = ctx->modules[i];
            if (!module_alias) continue;

            // Generate include: include "string.m";
            append_fmt(&ctx->buffer, &ctx->size, &ctx->capacity, "include \"%s.m\";\n", module_alias);

            // Generate capitalized module name for type declaration
            // Convert "string" -> "String"
            char module_type[256];
            snprintf(module_type, sizeof(module_type), "%s", module_alias);
            if (module_type[0]) {
                module_type[0] = toupper(module_type[0]);
            }

            // Generate alias:     string: String;
            append_fmt(&ctx->buffer, &ctx->size, &ctx->capacity, "\t%s: %s;\n", module_alias, module_type);
        }
    }

    append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "\n");

    append_fmt(&ctx->buffer, &ctx->size, &ctx->capacity, "%s: module {\n", module_name);
    append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "\tinit: fn(ctxt: ref Draw->Context, argv: list of string);\n");
    append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "};\n\n");

    return true;
}

// Generate init function start
static bool generate_init_start(LimboContext* ctx, const char* title) {
    append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "init(ctxt: ref Draw->Context, argv: list of string) {\n");

    if (ctx->include_comments) {
        append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "\t# Load required modules\n");
    }

    append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "\tsys = load Sys Sys->PATH;\n");
    append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "\tdraw = load Draw Draw->PATH;\n");
    append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "\ttk = load Tk Tk->PATH;\n");
    append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "\ttkclient = load Tkclient Tkclient->PATH;\n");

    // Load additional modules from config
    if (ctx->modules && ctx->modules_count > 0) {
        for (int i = 0; i < ctx->modules_count; i++) {
            const char* module_alias = ctx->modules[i];
            if (!module_alias) continue;

            // Generate capitalized module name
            // Convert "string" -> "String"
            char module_type[256];
            snprintf(module_type, sizeof(module_type), "%s", module_alias);
            if (module_type[0]) {
                module_type[0] = toupper(module_type[0]);
            }

            // Generate load statement: string = load String String->PATH;
            append_fmt(&ctx->buffer, &ctx->size, &ctx->capacity,
                      "\t%s = load %s %s->PATH;\n", module_alias, module_type, module_type);
        }
    }

    append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "\ttkclient->init();\n\n");

    if (ctx->include_comments) {
        append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "\t# Create toplevel window\n");
    }

    const char* window_title = title ? title : "Kryon App";
    append_fmt(&ctx->buffer, &ctx->size, &ctx->capacity,
              "\t(t, titlech) := tkclient->toplevel(ctxt, \"\", \"%s\", Tkclient->Appl);\n\n",
              window_title);

    if (ctx->include_comments) {
        append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "\t# Create widgets\n");
    }
    append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "\n");

    return true;
}

// Generate event loop
static bool generate_event_loop(LimboContext* ctx, int num_event_handlers) {
    append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "\n");
    if (ctx->include_comments) {
        append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "\t# Update display\n");
    }
    append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "\ttk->cmd(t, \"update\");\n\n");
    append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "\ttkclient->onscreen(t, nil);\n");
    append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "\ttkclient->startinput(t, \"kbd\" :: \"ptr\" :: nil);\n\n");

    if (num_event_handlers > 0) {
        append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "\teventch := chan of string;\n");
        append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "\ttk->namechan(t, eventch, \"eventch\");\n\n");
    }

    if (ctx->include_comments) {
        append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "\t# Event loop\n");
    }

    append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "\tfor(;;) alt {\n");
    append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "\t\ts := <-t.ctxt.kbd =>\n");
    append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "\t\t\ttk->keyboard(t, s);\n");
    append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "\t\ts := <-t.ctxt.ptr =>\n");
    append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "\t\t\ttk->pointer(t, *s);\n");
    append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "\t\ts := <-t.ctxt.ctl or s = <-t.wreq or s = <-titlech =>\n");
    append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "\t\t\ttkclient->wmctl(t, s);\n");

    if (num_event_handlers > 0) {
        append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "\t\ts := <-eventch =>\n");
        append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "\t\t\tif (s != nil) {\n");

        for (int i = 1; i <= num_event_handlers; i++) {
            append_fmt(&ctx->buffer, &ctx->size, &ctx->capacity,
                      "\t\t\t\tif (s == \"click%d\") {\n", i);

            // Get handler name for this number
            const char* handler_name = get_handler_name_by_number(i);

            if (handler_name) {
                // Call custom handler function
                append_fmt(&ctx->buffer, &ctx->size, &ctx->capacity,
                          "\t\t\t\t\t%s();\n", handler_name);
            } else {
                // Fallback to debug print
                append_fmt(&ctx->buffer, &ctx->size, &ctx->capacity,
                          "\t\t\t\t\tsys->print(\"Button %d clicked\\n\");\n", i);
            }

            append_string(&ctx->buffer, &ctx->size, &ctx->capacity,
                         "\t\t\t\t}\n");
        }

        append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "\t\t\t}\n");
    }

    append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "\t}\n");
    append_string(&ctx->buffer, &ctx->size, &ctx->capacity, "}\n");

    return true;
}

// Generate Limbo code from KIR JSON
char* limbo_codegen_from_json(const char* kir_json) {
    if (!kir_json) return NULL;

    cJSON* kir_root = cJSON_Parse(kir_json);
    if (!kir_root) return NULL;

    // Extract logic_block for custom functions
    cJSON* logic_block = codegen_extract_logic_block(kir_root);

    LimboContext* ctx = create_limbo_context(NULL);
    if (!ctx) {
        cJSON_Delete(kir_root);
        return NULL;
    }

    // Extract module name (default to "KryonApp")
    const char* module_name = ctx->module_name ? ctx->module_name : "KryonApp";

    // Get window title from app section
    cJSON* app = cJSON_GetObjectItem(kir_root, "app");
    const char* window_title = NULL;
    if (app) {
        cJSON* title_obj = cJSON_GetObjectItem(app, "windowTitle");
        if (title_obj && title_obj->type == cJSON_String) {
            window_title = title_obj->valuestring;
        }
    }

    // Generate module header
    generate_module_header(ctx, module_name);

    // Generate custom Limbo functions (BEFORE init function)
    generate_limbo_custom_functions(ctx, logic_block);

    // Generate init function start
    generate_init_start(ctx, window_title);

    // Process root component
    cJSON* root = cJSON_GetObjectItem(kir_root, "root");
    if (root) {
        process_component(ctx, root, "", 0, NULL, NULL);
    }

    // Generate event loop
    generate_event_loop(ctx, ctx->event_handler_counter);

    // Cleanup handler mappings
    cleanup_event_handler_mappings();

    // Extract buffer
    char* result = ctx->buffer;
    ctx->buffer = NULL;  // Don't free the buffer when destroying context

    destroy_limbo_context(ctx);
    cJSON_Delete(kir_root);

    return result;
}

// Generate Limbo file from KIR file
bool limbo_codegen_generate(const char* kir_path, const char* output_path) {
    if (!kir_path || !output_path) return false;

    // 1. Load using IR API (loads IRComponent tree)
    IRReactiveManifest* manifest = NULL;
    IRComponent* root = ir_read_json_file_with_manifest(kir_path, &manifest);
    if (!root) {
        fprintf(stderr, "Failed to load KIR file: %s\n", kir_path);
        return false;
    }

    // 2. Expand ForEach components BEFORE codegen
    //    This expands all For loops in-place, replacing them with concrete children
    ir_expand_foreach(root);

    // 3. Serialize expanded tree back to JSON
    char* expanded_json = ir_serialize_json(root, manifest);
    if (!expanded_json) {
        ir_destroy_component(root);
        if (manifest) ir_reactive_manifest_destroy(manifest);
        return false;
    }

    // 4. Generate Limbo code from expanded JSON (existing logic)
    char* limbo_code = limbo_codegen_from_json(expanded_json);

    // 5. Cleanup
    free(expanded_json);
    ir_destroy_component(root);
    if (manifest) ir_reactive_manifest_destroy(manifest);

    // 6. Write output (existing logic)
    if (!limbo_code) {
        fprintf(stderr, "Failed to generate Limbo code\n");
        return false;
    }

    FILE* output_file = fopen(output_path, "w");
    if (!output_file) {
        fprintf(stderr, "Failed to open output file: %s\n", output_path);
        free(limbo_code);
        return false;
    }

    fputs(limbo_code, output_file);
    fclose(output_file);
    free(limbo_code);

    return true;
}

// Generate with options
bool limbo_codegen_generate_with_options(const char* kir_path,
                                          const char* output_path,
                                          LimboCodegenOptions* options) {
    if (!kir_path || !output_path) return false;

    // Read KIR file
    FILE* kir_file = fopen(kir_path, "r");
    if (!kir_file) {
        fprintf(stderr, "Failed to open KIR file: %s\n", kir_path);
        return false;
    }

    fseek(kir_file, 0, SEEK_END);
    long file_size = ftell(kir_file);
    fseek(kir_file, 0, SEEK_SET);

    char* kir_json = malloc(file_size + 1);
    if (!kir_json) {
        fclose(kir_file);
        return false;
    }

    size_t bytes_read = fread(kir_json, 1, file_size, kir_file);
    kir_json[bytes_read] = '\0';
    fclose(kir_file);

    // Generate Limbo code with options
    cJSON* kir_root = cJSON_Parse(kir_json);
    free(kir_json);

    if (!kir_root) {
        fprintf(stderr, "Failed to parse KIR JSON\n");
        return false;
    }

    // Extract logic_block for custom functions
    cJSON* logic_block = codegen_extract_logic_block(kir_root);

    LimboContext* ctx = create_limbo_context(options);
    if (!ctx) {
        cJSON_Delete(kir_root);
        return false;
    }

    // Extract module name (default to "KryonApp")
    const char* module_name = ctx->module_name ? ctx->module_name : "KryonApp";

    // Get window title from app section
    cJSON* app = cJSON_GetObjectItem(kir_root, "app");
    const char* window_title = NULL;
    if (app) {
        cJSON* title_obj = cJSON_GetObjectItem(app, "windowTitle");
        if (title_obj && title_obj->type == cJSON_String) {
            window_title = title_obj->valuestring;
        }
    }

    // Generate module header
    generate_module_header(ctx, module_name);

    // Generate custom Limbo functions (BEFORE init function)
    generate_limbo_custom_functions(ctx, logic_block);

    // Generate init function start
    generate_init_start(ctx, window_title);

    // Process root component
    cJSON* root = cJSON_GetObjectItem(kir_root, "root");
    if (root) {
        process_component(ctx, root, "", 0, NULL, NULL);
    }

    // Generate event loop
    generate_event_loop(ctx, ctx->event_handler_counter);

    // Cleanup handler mappings
    cleanup_event_handler_mappings();

    cJSON_Delete(kir_root);

    // Write output file
    FILE* output_file = fopen(output_path, "w");
    if (!output_file) {
        fprintf(stderr, "Failed to open output file: %s\n", output_path);
        destroy_limbo_context(ctx);
        return false;
    }

    fputs(ctx->buffer, output_file);
    fclose(output_file);

    destroy_limbo_context(ctx);
    return true;
}

// Generate multiple files (currently just generates one file)
bool limbo_codegen_generate_multi(const char* kir_path, const char* output_dir) {
    if (!kir_path || !output_dir) return false;

    // Create output directory if it doesn't exist
    if (!codegen_mkdir_p(output_dir)) {
        fprintf(stderr, "Failed to create output directory: %s\n", output_dir);
        return false;
    }

    // For now, just generate a single main.b file
    char output_path[1024];
    snprintf(output_path, sizeof(output_path), "%s/main.b", output_dir);

    return limbo_codegen_generate(kir_path, output_path);
}
