/**
 * Screenshot Utilities Implementation
 *
 * X11-based screenshot capture for external windows (e.g., TaijiOS emulator)
 * Pure Kryon implementation - no target modifications required.
 */

#define _GNU_SOURCE
#define _POSIX_C_SOURCE 200809L

#include "screenshot.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <time.h>
#include <ctype.h>

/* X11 headers */
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/Xatom.h>

/* stb_image_write - single-file library */
#define STB_IMAGE_WRITE_IMPLEMENTATION
#include "../../../third_party/stb/stb_image_write.h"

/* ============================================================================
 * X11 Window Finding
 * ============================================================================ */

/**
 * Get window title using _NET_WM_NAME or WM_NAME
 */
static char* get_window_title(Display* display, Window window) {
    Atom net_wm_name = XInternAtom(display, "_NET_WM_NAME", False);
    Atom utf8_string = XInternAtom(display, "UTF8_STRING", False);
    Atom wm_name = XInternAtom(display, "WM_NAME", False);
    Atom actual_type;
    int actual_format;
    unsigned long nitems;
    unsigned long bytes_after;
    unsigned char* prop = NULL;

    // Try _NET_WM_NAME (UTF-8) first
    if (XGetWindowProperty(display, window, net_wm_name, 0, 1024, False,
                          utf8_string, &actual_type, &actual_format,
                          &nitems, &bytes_after, &prop) == Success) {
        if (prop && nitems > 0) {
            char* title = strndup((char*)prop, nitems);
            XFree(prop);
            return title;
        }
        if (prop) XFree(prop);
    }

    // Fallback to WM_NAME (legacy)
    if (XGetWindowProperty(display, window, wm_name, 0, 1024, False,
                          AnyPropertyType, &actual_type, &actual_format,
                          &nitems, &bytes_after, &prop) == Success) {
        if (prop && nitems > 0) {
            char* title = strndup((char*)prop, nitems);
            XFree(prop);
            return title;
        }
        if (prop) XFree(prop);
    }

    return NULL;
}

/**
 * Get window PID using _NET_WM_PID
 */
static pid_t get_window_pid(Display* display, Window window) {
    Atom net_wm_pid = XInternAtom(display, "_NET_WM_PID", False);
    Atom actual_type;
    int actual_format;
    unsigned long nitems;
    unsigned long bytes_after;
    unsigned char* prop = NULL;
    pid_t pid = 0;

    if (XGetWindowProperty(display, window, net_wm_pid, 0, 1, False,
                          XA_CARDINAL, &actual_type, &actual_format,
                          &nitems, &bytes_after, &prop) == Success) {
        if (prop && nitems > 0) {
            pid = prop[0] & 0xff;
            pid |= (prop[1] & 0xff) << 8;
            pid |= (prop[2] & 0xff) << 16;
            pid |= (prop[3] & 0xff) << 24;
        }
        if (prop) XFree(prop);
    }

    return pid;
}

/**
 * Check if window is visible and mapped
 */
static bool is_window_visible(Display* display, Window window) {
    XWindowAttributes attrs;
    if (XGetWindowAttributes(display, window, &attrs) == 0) {
        return false;
    }
    return attrs.map_state == IsViewable;
}

/**
 * Case-insensitive string search
 */
static bool str_contains_case_insensitive(const char* haystack, const char* needle) {
    if (!haystack || !needle) return false;

    while (*haystack && *needle) {
        if (tolower((unsigned char)*haystack) != tolower((unsigned char)*needle)) {
            haystack++;
            // Reset needle pointer
            needle = needle - (needle - needle); // This won't work, use proper approach
            return false;
        }
        haystack++;
        needle++;
    }

    return *needle == '\0';
}

/**
 * Case-insensitive substring search
 */
static bool strstr_case_insensitive(const char* haystack, const char* needle) {
    if (!haystack || !needle) return false;

    size_t needle_len = strlen(needle);
    if (needle_len == 0) return true;

    for (size_t i = 0; haystack[i]; i++) {
        bool match = true;
        for (size_t j = 0; j < needle_len; j++) {
            if (tolower((unsigned char)haystack[i + j]) !=
                tolower((unsigned char)needle[j])) {
                match = false;
                break;
            }
        }
        if (match && haystack[i + needle_len] == '\0') {
            // Only match if the needle appears at the end of haystack
            // For substring matching anywhere, remove the haystack[i + needle_len] check
            return true;
        }
    }

    return false;
}

/**
 * Recursive search for window by title (case-insensitive)
 */
static Window search_window_by_title(Display* display, Window root,
                                     const char* title_pattern) {
    Window parent;
    Window* children;
    unsigned int nchildren;

    // Check if this window matches (case-insensitive)
    char* title = get_window_title(display, root);
    if (title) {
        // Case-insensitive substring match
        size_t pattern_len = strlen(title_pattern);
        size_t title_len = strlen(title);

        bool matches = false;
        if (title_len >= pattern_len) {
            for (size_t i = 0; i <= title_len - pattern_len; i++) {
                bool substring_match = true;
                for (size_t j = 0; j < pattern_len; j++) {
                    if (tolower((unsigned char)title[i + j]) !=
                        tolower((unsigned char)title_pattern[j])) {
                        substring_match = false;
                        break;
                    }
                }
                if (substring_match) {
                    matches = true;
                    break;
                }
            }
        }

        if (matches && is_window_visible(display, root)) {
            free(title);
            return root;
        }
    }
    if (title) free(title);

    // Search children
    if (XQueryTree(display, root, &root, &parent, &children, &nchildren) == 0) {
        return None;
    }

    Window result = None;
    for (unsigned int i = 0; i < nchildren; i++) {
        result = search_window_by_title(display, children[i], title_pattern);
        if (result != None) {
            break;
        }
    }

    if (children) XFree(children);
    return result;
}

/**
 * Find window by title pattern
 */
Window find_x11_window_by_title(void* display_ptr, Window root,
                                const char* title_pattern) {
    Display* display = (Display*)display_ptr;
    if (!display || !title_pattern) {
        return None;
    }

    // Start search from root window
    return search_window_by_title(display, root, title_pattern);
}

/**
 * Recursive search for window by PID
 */
static Window search_window_by_pid(Display* display, Window root, pid_t target_pid) {
    Window parent;
    Window* children;
    unsigned int nchildren;

    // Check if this window matches
    pid_t pid = get_window_pid(display, root);
    if (pid == target_pid && is_window_visible(display, root)) {
        return root;
    }

    // Search children
    if (XQueryTree(display, root, &root, &parent, &children, &nchildren) == 0) {
        return None;
    }

    Window result = None;
    for (unsigned int i = 0; i < nchildren; i++) {
        result = search_window_by_pid(display, children[i], target_pid);
        if (result != None) {
            break;
        }
    }

    if (children) XFree(children);
    return result;
}

/**
 * Find window by process ID
 */
Window find_x11_window_by_pid(void* display_ptr, Window root, pid_t pid) {
    Display* display = (Display*)display_ptr;
    if (!display || pid <= 0) {
        return None;
    }

    return search_window_by_pid(display, root, pid);
}

/* ============================================================================
 * X11 Screenshot Capture
 * ============================================================================ */

/**
 * Convert XImage to RGBA format
 */
static uint8_t* convert_ximage_to_rgba(XImage* image, int width, int height) {
    if (!image || width <= 0 || height <= 0) {
        return NULL;
    }

    uint8_t* rgba = malloc(width * height * 4);
    if (!rgba) {
        return NULL;
    }

    // Get visual info for color channels
    Display* display = NULL; // We don't have the display here, assume default visual

    // For TrueColor visuals (most common)
    unsigned long red_mask = image->red_mask;
    unsigned long green_mask = image->green_mask;
    unsigned long blue_mask = image->blue_mask;

    int red_shift, green_shift, blue_shift;

    // Calculate bit shifts for each channel
    if (red_mask == 0xFF0000) {
        red_shift = 16;
        green_shift = 8;
        blue_shift = 0;
    } else if (red_mask == 0x0000FF) {
        red_shift = 0;
        green_shift = 8;
        blue_shift = 16;
    } else {
        // Fallback: auto-detect shifts
        red_shift = green_shift = blue_shift = 0;
        while (!(red_mask & 1)) { red_mask >>= 1; red_shift++; }
        while (!(green_mask & 1)) { green_mask >>= 1; green_shift++; }
        while (!(blue_mask & 1)) { blue_mask >>= 1; blue_shift++; }
    }

    for (int y = 0; y < height; y++) {
        for (int x = 0; x < width; x++) {
            unsigned long pixel = XGetPixel(image, x, y);
            int idx = (y * width + x) * 4;

            rgba[idx + 0] = (pixel >> red_shift) & 0xFF;   // R
            rgba[idx + 1] = (pixel >> green_shift) & 0xFF; // G
            rgba[idx + 2] = (pixel >> blue_shift) & 0xFF;  // B
            rgba[idx + 3] = 255;                            // A (fully opaque)
        }
    }

    return rgba;
}

/**
 * Capture X11 window to PNG file
 */
bool capture_x11_window_to_png(void* display_ptr, Window window,
                               const char* output_path) {
    Display* display = (Display*)display_ptr;

    if (!display || window == None || !output_path) {
        fprintf(stderr, "Error: Invalid parameters for X11 capture\n");
        return false;
    }

    // Get window attributes
    XWindowAttributes attrs;
    if (XGetWindowAttributes(display, window, &attrs) == 0) {
        fprintf(stderr, "Error: Failed to get window attributes\n");
        return false;
    }

    int width = attrs.width;
    int height = attrs.height;

    if (width <= 0 || height <= 0) {
        fprintf(stderr, "Error: Invalid window size: %dx%d\n", width, height);
        return false;
    }

    // Capture window content
    XImage* image = XGetImage(display, window, 0, 0, width, height,
                             AllPlanes, ZPixmap);

    if (!image) {
        fprintf(stderr, "Error: Failed to capture window image\n");
        return false;
    }

    // Convert to RGBA
    uint8_t* rgba = convert_ximage_to_rgba(image, width, height);
    if (!rgba) {
        XDestroyImage(image);
        fprintf(stderr, "Error: Failed to convert image to RGBA\n");
        return false;
    }

    // Write PNG using stb_image_write
    int result = stbi_write_png(output_path, width, height, 4, rgba, width * 4);

    // Cleanup
    free(rgba);
    XDestroyImage(image);

    if (result == 0) {
        fprintf(stderr, "Error: Failed to write PNG to %s\n", output_path);
        return false;
    }

    printf("Screenshot saved: %s (%dx%d)\n", output_path, width, height);
    return true;
}

/**
 * Wait for window to appear and capture screenshot
 */
bool capture_window_when_ready(const char* title_pattern, const char* output_path,
                               int timeout_ms) {
    if (!title_pattern || !output_path) {
        return false;
    }

    // Open X11 display
    Display* display = XOpenDisplay(NULL);
    if (!display) {
        fprintf(stderr, "Error: Cannot open X11 display (is DISPLAY set?)\n");
        return false;
    }

    Window root = DefaultRootWindow(display);

    // Wait for window to appear
    const int poll_interval_ms = 100;
    int elapsed = 0;
    Window window = None;

    while (elapsed < timeout_ms) {
        window = find_x11_window_by_title(display, root, title_pattern);
        if (window != None) {
            break;
        }

        usleep(poll_interval_ms * 1000);
        elapsed += poll_interval_ms;
    }

    if (window == None) {
        fprintf(stderr, "Error: Window '%s' not found after %d ms\n",
                title_pattern, timeout_ms);
        XCloseDisplay(display);
        return false;
    }

    // Wait a bit for window to fully render
    usleep(500 * 1000); // 500ms

    // Capture screenshot
    bool success = capture_x11_window_to_png(display, window, output_path);

    XCloseDisplay(display);
    return success;
}

/* ============================================================================
 * High-Level Screenshot Functions
 * ============================================================================ */

/**
 * Parse environment variables for screenshot options
 */
void screenshot_parse_env_vars(ScreenshotOptions* options) {
    if (!options) return;

    // KRYON_SCREENSHOT environment variable
    if (!options->output_path) {
        const char* env_path = getenv("KRYON_SCREENSHOT");
        if (env_path && strlen(env_path) > 0) {
            options->output_path = env_path;
        }
    }

    // KRYON_SCREENSHOT_AFTER_FRAMES environment variable
    const char* env_frames = getenv("KRYON_SCREENSHOT_AFTER_FRAMES");
    if (env_frames && options->after_frames == 0) {
        options->after_frames = atoi(env_frames);
    }
}

/**
 * Capture TaijiOS/Inferno emulator window screenshot (high-level)
 * Tries multiple window titles to find the correct emulator window
 */
bool capture_emulator_window(const ScreenshotOptions* options) {
    if (!options || !options->output_path) {
        fprintf(stderr, "Error: Screenshot output path not specified\n");
        return false;
    }

    // Try multiple window titles in order of likelihood
    // The TaijiOS/Inferno emulator can have different window titles
    const char* window_titles[] = {"Inferno", "TaijiOS", NULL};
    const char* custom_title = options->window_title;

    // If custom title is specified, only try that one
    if (custom_title) {
        printf("Looking for window: %s\n", custom_title);
        return capture_window_when_ready(custom_title, options->output_path, options->timeout_ms);
    }

    // Otherwise, try each title until we find a match
    for (int i = 0; window_titles[i] != NULL; i++) {
        printf("Looking for window: %s\n", window_titles[i]);

        // Calculate timeout based on after_frames
        // Assume 60 FPS, so after_frames * 16.67ms per frame
        int timeout_ms = options->timeout_ms;
        if (options->after_frames > 0) {
            // Add extra time for frame rendering
            timeout_ms += (options->after_frames * 1000) / 60;
        }

        if (capture_window_when_ready(window_titles[i], options->output_path, timeout_ms)) {
            return true; // Successfully captured
        }

        // If this title failed, try the next one
        printf("Window '%s' not found, trying next option...\n", window_titles[i]);
    }

    // All titles failed
    fprintf(stderr, "Error: No emulator window found (tried 'Inferno' and 'TaijiOS')\n");
    return false;
}
